<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Dynamic Form Element Demo</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e5e7eb;
      --danger: #ef4444;
      --success: #16a34a;
      --warning: #f59e0b;
      --focus: rgba(37, 99, 235, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      gap: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    h1, h2, h3 {
      margin: 0 0 12px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }

    .required-star {
      color: var(--danger);
      font-weight: 700;
    }

    .required-hint {
      font-size: 0.75rem;
      color: var(--danger);
      font-weight: 600;
    }

    .field-wrapper {
      display: grid;
      gap: 8px;
      padding: 12px 0;
      border-bottom: 1px solid #f3f4f6;
    }

    .field-wrapper:last-child {
      border-bottom: none;
    }

    .field-control {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2px;
      background: #fff;
      position: relative;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .field-control:focus-within {
      border-color: rgba(37, 99, 235, 0.75);
      box-shadow: 0 0 0 3px var(--focus);
    }

    .field-control.invalid {
      border-color: rgba(239, 68, 68, 0.75);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.18);
    }

    .field-input,
    select,
    textarea {
      width: 100%;
      border: none;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 0.95rem;
      background: transparent;
      color: var(--text);
      outline: none;
    }

    textarea.field-input {
      resize: vertical;
      min-height: 110px;
    }

    .field-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .helper-text {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .error-text {
      font-size: 0.82rem;
      color: var(--danger);
    }

    .inline-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
    }

    button.secondary {
      background: #e5e7eb;
      color: var(--text);
    }

    button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .console {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.82rem;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .chip button {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(37, 99, 235, 0.2);
    }

    .file-drop {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      color: var(--muted);
      background: #fafafa;
    }

    .file-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    .file-item {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
    }

    .file-meta {
      display: grid;
      gap: 4px;
      font-size: 0.82rem;
    }

    .file-thumb {
      width: 44px;
      height: 44px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid var(--border);
      background: #f3f4f6;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .toggle input {
      width: 40px;
      height: 22px;
    }

    .summary-box {
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <main class="page">
    <section class="card">
      <h1>Bubble Dynamic Form Element</h1>
      <p class="helper-text">
        Bu demo tek HTML dosyasƒ±nda √ßalƒ±≈üƒ±r. Bubble elementine alan ≈üemasƒ±nƒ± JSON olarak girip ‚ÄúRender Et‚Äù diyebilirsiniz.
      </p>
      <div class="grid two">
        <div>
          <label for="schemaInput">Schema (fields + config)</label>
          <textarea id="schemaInput" class="field-input" rows="12"></textarea>
        </div>
        <div class="grid">
          <div>
            <label for="currentDateTime">currentDateTimeISO</label>
            <input id="currentDateTime" class="field-input" type="text" />
          </div>
          <div class="grid two">
            <div>
              <label for="localeInput">locale</label>
              <input id="localeInput" class="field-input" type="text" value="tr-TR" />
            </div>
            <div>
              <label for="timezoneInput">timezone</label>
              <input id="timezoneInput" class="field-input" type="text" value="Europe/Istanbul" />
            </div>
          </div>
          <div class="grid two">
            <div>
              <label for="modeInput">mode</label>
              <select id="modeInput" class="field-input">
                <option value="create">create</option>
                <option value="edit">edit</option>
              </select>
            </div>
            <div>
              <label for="requiredPolicyInput">requiredPolicy</label>
              <select id="requiredPolicyInput" class="field-input">
                <option value="strict">strict</option>
                <option value="soft">soft</option>
              </select>
            </div>
          </div>
          <div class="grid two">
            <div class="inline-row">
              <input id="showInlineHelp" type="checkbox" checked />
              <label for="showInlineHelp">showInlineHelp</label>
            </div>
            <div class="inline-row">
              <input id="autoFocusInvalid" type="checkbox" checked />
              <label for="autoFocusInvalid">autoFocusFirstInvalid</label>
            </div>
          </div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="loadSample">√ñrnek Schema Y√ºkle</button>
        <button class="secondary" id="renderForm">Render Et</button>
        <button class="ghost" id="clearConsole">Console Temizle</button>
      </div>
    </section>

    <section class="card">
      <h2>Event Console</h2>
      <div id="eventConsole" class="console"></div>
    </section>

    <section class="card">
      <h2>Dynamic Form</h2>
      <div id="summaryBox" class="summary-box" style="display:none;"></div>
      <form id="dynamicForm" class="grid"></form>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="submitBtn" type="submit">Submit</button>
        <button id="clearBtn" type="button" class="ghost">Temizle</button>
      </div>
    </section>
  </main>

  <script>
    const schemaInput = document.getElementById("schemaInput");
    const currentDateTimeInput = document.getElementById("currentDateTime");
    const localeInput = document.getElementById("localeInput");
    const timezoneInput = document.getElementById("timezoneInput");
    const modeInput = document.getElementById("modeInput");
    const requiredPolicyInput = document.getElementById("requiredPolicyInput");
    const showInlineHelpInput = document.getElementById("showInlineHelp");
    const autoFocusInvalidInput = document.getElementById("autoFocusInvalid");
    const formEl = document.getElementById("dynamicForm");
    const submitBtn = document.getElementById("submitBtn");
    const clearBtn = document.getElementById("clearBtn");
    const summaryBox = document.getElementById("summaryBox");
    const consoleEl = document.getElementById("eventConsole");

    const state = {
      config: null,
      values: {},
      validMap: {},
      touched: {},
      errors: {},
      autoSaveTimer: null,
      fileBuffers: {}
    };

    const defaultSchema = {
      fields: [
        {
          key: "fullName",
          label: "Ad Soyad",
          type: "text",
          required: true,
          placeholder: "√ñrn. Ay≈üe Yƒ±lmaz",
          helpText: "Kimlikteki ad-soyad",
          minLen: 3
        },
        {
          key: "email",
          label: "E-posta",
          type: "email",
          required: true,
          placeholder: "ornek@mail.com"
        },
        {
          key: "phone",
          label: "Telefon",
          type: "phone",
          required: true,
          placeholder: "05xx xxx xx xx",
          ui: { autoTrPrefix: true }
        },
        {
          key: "website",
          label: "Website",
          type: "url",
          placeholder: "https://",
          ui: { suggestHttps: true }
        },
        {
          key: "password",
          label: "≈ûifre",
          type: "password",
          required: true,
          minLen: 8
        },
        {
          key: "bio",
          label: "A√ßƒ±klama",
          type: "textarea",
          placeholder: "Kƒ±sa notlar...",
          maxLen: 240
        },
        {
          key: "age",
          label: "Ya≈ü",
          type: "integer",
          min: 18,
          max: 99
        },
        {
          key: "salary",
          label: "Maa≈ü (‚Ç∫)",
          type: "currency",
          ui: { currency: "‚Ç∫", step: 0.01, thousandSeparator: true }
        },
        {
          key: "discount",
          label: "ƒ∞ndirim (%)",
          type: "percent",
          ui: { step: 0.1 }
        },
        {
          key: "subscribe",
          label: "KVKK Onayƒ±",
          type: "boolean",
          required: true,
          helpText: "Zorunlu onay"
        },
        {
          key: "vehicleType",
          label: "Ara√ß Tipi",
          type: "single_select",
          options: [
            { value: "hususi", label: "Hususi", group: "Binek" },
            { value: "ticari", label: "Ticari", group: "Ticari" },
            { value: "kiralik", label: "Kiralƒ±k", group: "Ticari" }
          ],
          required: true
        },
        {
          key: "extras",
          label: "Ek √ñzellikler",
          type: "multi_select",
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri g√∂r√º≈ü kamera" },
            { value: "isik", label: "LED far" }
          ]
        },
        {
          key: "appointmentDate",
          label: "Randevu Tarihi",
          type: "date",
          required: true,
          default: "$TODAY",
          ui: { showCalendar: true, allowTyping: true, quickActions: true }
        },
        {
          key: "appointmentDateTime",
          label: "Randevu Datetime",
          type: "datetime",
          default: "$NOW",
          ui: { quickActions: true }
        },
        {
          key: "appointmentTime",
          label: "Uygun Saat",
          type: "time",
          default: "$CURRENT_TIME",
          ui: { quickActions: true }
        },
        {
          key: "duration",
          label: "S√ºre",
          type: "duration",
          ui: { durationFormat: "minutes" }
        },
        {
          key: "address",
          label: "Adres",
          type: "address",
          helpText: "Minimum sokak, il√ße, il ve posta kodu"
        },
        {
          key: "attachments",
          label: "Dosyalar",
          type: "multifile",
          ui: { accept: "image/*,application/pdf", maxFiles: 5, maxSizeMB: 10, showPreview: true }
        },
        {
          key: "profileImage",
          label: "Profil Fotoƒürafƒ±",
          type: "image",
          ui: { accept: "image/*", maxFiles: 1, maxSizeMB: 5, showPreview: true }
        },
        {
          key: "metadata",
          label: "JSON (advanced)",
          type: "json",
          placeholder: "{\"foo\":\"bar\"}"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create",
      initialValues: {},
      requiredPolicy: "strict",
      showInlineHelp: true,
      autoFocusFirstInvalid: true
    };

    function setConsole(message, payload) {
      const timestamp = new Date().toLocaleTimeString("tr-TR");
      consoleEl.textContent += `[${timestamp}] ${message}` + (payload ? `\n${payload}` : "") + "\n";
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function emit(eventName, detail) {
      setConsole(eventName, JSON.stringify(detail, null, 2));
    }

    function safeJsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return null;
      }
    }

    function getCurrentDateTime(config) {
      return config.currentDateTimeISO || new Date().toISOString();
    }

    function getOffsetFromIso(iso) {
      const match = String(iso).match(/([+-]\d{2}:?\d{2}|Z)$/);
      if (!match) return "Z";
      if (match[1] === "Z") return "Z";
      const offset = match[1].includes(":") ? match[1] : `${match[1].slice(0, 3)}:${match[1].slice(3)}`;
      return offset;
    }

    function getDateFromIso(iso) {
      return String(iso).slice(0, 10);
    }

    function getTimeFromIso(iso) {
      return String(iso).slice(11, 16);
    }

    function normalizeDateInput(raw) {
      if (!raw) return "";
      const trimmed = raw.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmed)) {
        const [d, m, y] = trimmed.split(".");
        return `${y}-${m}-${d}`;
      }
      if (/^\d{8}$/.test(trimmed)) {
        const d = trimmed.slice(0, 2);
        const m = trimmed.slice(2, 4);
        const y = trimmed.slice(4, 8);
        return `${y}-${m}-${d}`;
      }
      return trimmed;
    }

    function normalizeTimeInput(raw) {
      if (!raw) return "";
      const cleaned = raw.replace(/\s/g, "");
      if (/^\d{1,2}$/.test(cleaned)) return `${cleaned.padStart(2, "0")}:00`;
      if (/^\d{3}$/.test(cleaned)) return `${cleaned.slice(0, 1).padStart(2, "0")}:${cleaned.slice(1)}`;
      if (/^\d{4}$/.test(cleaned)) return `${cleaned.slice(0, 2)}:${cleaned.slice(2)}`;
      if (/^\d{2}:\d{2}$/.test(cleaned)) return cleaned;
      return cleaned;
    }

    function normalizeNumberInput(raw) {
      if (raw === null || raw === undefined || raw === "") return "";
      const normalized = String(raw).replace(/\./g, "").replace(",", ".");
      return normalized;
    }

    function formatNumberDisplay(value, options = {}) {
      if (value === "" || value === null || value === undefined || Number.isNaN(Number(value))) return "";
      const numeric = Number(value);
      const formatter = new Intl.NumberFormat("tr-TR", {
        minimumFractionDigits: options.minimumFractionDigits || 0,
        maximumFractionDigits: options.maximumFractionDigits || 2
      });
      return formatter.format(numeric);
    }

    function getDefaultValue(field, config) {
      if (!field.default) return "";
      const token = field.default;
      const now = getCurrentDateTime(config);
      if (token === "$NOW") return now;
      if (token === "$TODAY") return getDateFromIso(now);
      if (token === "$CURRENT_TIME") return getTimeFromIso(now);
      return token;
    }

    function getInitialValue(field, config) {
      const initialValues = config.initialValues || {};
      if (initialValues[field.key] !== undefined) return initialValues[field.key];
      if (config.mode === "create") {
        return getDefaultValue(field, config);
      }
      return "";
    }

    function isEmptyValue(value) {
      if (Array.isArray(value)) return value.length === 0;
      if (value === null || value === undefined) return true;
      if (typeof value === "string") return value.trim() === "";
      return false;
    }

    function validateField(field, value) {
      if (field.required && isEmptyValue(value)) {
        if (field.type === "boolean") {
          return "Zorunlu onay gerekir.";
        }
        return "Bu alan zorunlu.";
      }
      if (field.type === "email" && value) {
        if (!String(value).includes("@")) return "Ge√ßerli bir e-posta girin.";
      }
      if (field.type === "phone" && value) {
        if (!/\d{10,}/.test(String(value).replace(/\D/g, ""))) return "Telefon formatƒ± hatalƒ±.";
      }
      if (field.type === "url" && value) {
        if (!/^https?:\/\//.test(String(value))) return "URL http(s):// ile ba≈ülamalƒ±.";
      }
      if (["integer", "decimal", "currency", "percent"].includes(field.type) && value !== "") {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) return "Ge√ßerli bir sayƒ± girin.";
        if (field.min !== undefined && numeric < field.min) return `Minimum ${field.min}`;
        if (field.max !== undefined && numeric > field.max) return `Maksimum ${field.max}`;
        if (field.type === "percent" && (numeric < 0 || numeric > 100)) return "0-100 arasƒ± girin.";
      }
      if (["text", "textarea", "password", "email", "url"].includes(field.type) && value) {
        if (field.minLen && String(value).length < field.minLen) return `En az ${field.minLen} karakter.`;
        if (field.maxLen && String(value).length > field.maxLen) return `En fazla ${field.maxLen} karakter.`;
        if (field.pattern) {
          const regex = new RegExp(field.pattern);
          if (!regex.test(String(value))) return field.validate?.find((r) => r.name === "regex")?.message || "Format hatasƒ±.";
        }
      }
      if (["date", "datetime", "time"].includes(field.type) && value) {
        if (field.type === "date" && !/^\d{4}-\d{2}-\d{2}$/.test(String(value)) && !/^\d{2}\.\d{2}\.\d{4}$/.test(String(value))) {
          return "Tarih formatƒ± gg.aa.yyyy veya yyyy-mm-dd olmalƒ±.";
        }
        if (field.type === "time" && !/^\d{2}:\d{2}$/.test(String(value))) return "Saat formatƒ± HH:mm olmalƒ±.";
        if (field.type === "datetime" && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(String(value))) return "Tarih ve saat gerekli.";
      }
      return "";
    }

    function setFieldValue(key, value, field, displayValue) {
      state.values[key] = value;
      const error = validateField(field, value);
      state.errors[key] = error;
      state.validMap[key] = !error;
      emit("onFieldChange", {
        key,
        value,
        displayValue: displayValue ?? value,
        isValid: !error
      });
      debounceFormChange();
    }

    function debounceFormChange() {
      if (state.autoSaveTimer) {
        clearTimeout(state.autoSaveTimer);
      }
      state.autoSaveTimer = setTimeout(() => {
        emit("onFormChange", {
          values: state.values,
          validMap: state.validMap,
          isFormValid: Object.values(state.validMap).every(Boolean)
        });
      }, 500);
    }

    function renderForm(config) {
      formEl.innerHTML = "";
      state.values = {};
      state.validMap = {};
      state.errors = {};
      state.touched = {};
      state.fileBuffers = {};
      summaryBox.style.display = "none";

      config.fields.forEach((field, index) => {
        const wrapper = document.createElement("div");
        wrapper.className = "field-wrapper";

        const label = document.createElement("label");
        label.htmlFor = `field-${field.key}`;
        label.textContent = field.label;
        if (field.required) {
          const star = document.createElement("span");
          star.className = "required-star";
          star.textContent = "*";
          const hint = document.createElement("span");
          hint.className = "required-hint";
          hint.textContent = "zorunlu";
          label.append(star, hint);
        }
        wrapper.append(label);

        const control = document.createElement("div");
        control.className = "field-control";

        let inputEl = null;
        let extraControls = null;
        let inlineActions = null;

        const initialValue = getInitialValue(field, config);
        state.values[field.key] = initialValue;
        state.validMap[field.key] = !validateField(field, initialValue);

        if (["text", "email", "phone", "url", "password", "integer", "decimal", "currency", "percent", "time"].includes(field.type)) {
          inputEl = document.createElement("input");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          inputEl.value = initialValue || "";
          if (field.type === "password") inputEl.type = "password";
          if (field.type === "email") inputEl.type = "email";
          if (field.type === "url") inputEl.type = "url";
          if (field.type === "phone") inputEl.type = "tel";
          if (["integer", "decimal", "currency", "percent"].includes(field.type)) inputEl.inputMode = field.type === "integer" ? "numeric" : "decimal";
          if (field.type === "time") inputEl.type = "time";

          inputEl.addEventListener("input", (event) => {
            if (["integer", "decimal", "currency", "percent"].includes(field.type)) {
              const raw = event.target.value;
              setFieldValue(field.key, normalizeNumberInput(raw), field, raw);
            } else {
              setFieldValue(field.key, event.target.value, field);
            }
          });

          inputEl.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            let value = event.target.value;
            if (field.type === "time") {
              value = normalizeTimeInput(value);
              event.target.value = value;
            }
            if (field.type === "email" && value) {
              value = value.toLowerCase();
              event.target.value = value;
            }
            if (field.type === "phone" && value && field.ui?.autoTrPrefix) {
              const digits = value.replace(/\D/g, "");
              if (digits.startsWith("0")) {
                value = `+90${digits.slice(1)}`;
                event.target.value = value;
              }
            }
            if (["integer", "decimal", "currency", "percent"].includes(field.type)) {
              const normalized = normalizeNumberInput(value);
              const formatted = field.type === "integer" ? formatNumberDisplay(normalized, { maximumFractionDigits: 0 }) : formatNumberDisplay(normalized, { maximumFractionDigits: 2 });
              event.target.value = formatted || value;
              setFieldValue(field.key, normalized, field, formatted);
            } else {
              setFieldValue(field.key, value, field);
            }
            updateError(control, field);
          });

          if (field.type === "time" && field.ui?.quickActions) {
            const actions = document.createElement("div");
            actions.className = "field-actions";
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûu an";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const timeValue = getTimeFromIso(now);
              inputEl.value = timeValue;
              setFieldValue(field.key, timeValue, field);
              updateError(control, field);
            });
            actions.append(nowBtn);
            inlineActions = actions;
          }
        } else if (field.type === "textarea" || field.type === "json") {
          inputEl = document.createElement("textarea");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          inputEl.value = initialValue || "";

          inputEl.addEventListener("input", (event) => {
            setFieldValue(field.key, event.target.value, field);
          });
          inputEl.addEventListener("blur", () => {
            updateError(control, field);
          });
        } else if (field.type === "boolean") {
          control.classList.add("toggle");
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.checked = Boolean(initialValue);
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = field.label;
          control.append(inputEl, toggleLabel);
          inputEl.addEventListener("change", () => {
            setFieldValue(field.key, inputEl.checked, field);
            updateError(control, field);
          });
        } else if (field.type === "single_select") {
          const searchInput = document.createElement("input");
          searchInput.className = "field-input";
          searchInput.placeholder = "Ara...";
          const select = document.createElement("select");
          select.className = "field-input";
          select.id = `field-${field.key}`;
          select.setAttribute("aria-describedby", `error-${field.key}`);

          const buildOptions = (filter = "") => {
            select.innerHTML = "";
            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "Se√ßiniz";
            select.append(emptyOption);
            const groups = {};
            (field.options || []).forEach((opt) => {
              if (filter && !opt.label.toLowerCase().includes(filter.toLowerCase())) return;
              if (opt.group) {
                if (!groups[opt.group]) groups[opt.group] = [];
                groups[opt.group].push(opt);
              } else {
                groups.__default = groups.__default || [];
                groups.__default.push(opt);
              }
            });

            Object.entries(groups).forEach(([groupName, opts]) => {
              if (groupName === "__default") {
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  select.append(option);
                });
              } else {
                const group = document.createElement("optgroup");
                group.label = groupName;
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  group.append(option);
                });
                select.append(group);
              }
            });
          };

          buildOptions();
          select.value = initialValue || "";

          searchInput.addEventListener("input", (event) => {
            buildOptions(event.target.value);
          });
          select.addEventListener("change", () => {
            setFieldValue(field.key, select.value, field);
            updateError(control, field);
          });

          extraControls = document.createElement("div");
          extraControls.className = "field-actions";
          extraControls.append(searchInput);
          control.append(select);
        } else if (field.type === "multi_select") {
          const searchInput = document.createElement("input");
          searchInput.className = "field-input";
          searchInput.placeholder = "Ara...";

          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "grid";

          const chips = document.createElement("div");
          chips.className = "chip-row";

          let selectedValues = Array.isArray(initialValue) ? initialValue : [];

          const renderOptions = (filter = "") => {
            optionsWrapper.innerHTML = "";
            (field.options || []).forEach((opt) => {
              if (filter && !opt.label.toLowerCase().includes(filter.toLowerCase())) return;
              const optionRow = document.createElement("label");
              optionRow.className = "inline-row";
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.checked = selectedValues.includes(opt.value);
              checkbox.disabled = opt.disabled || false;
              const text = document.createElement("span");
              text.textContent = opt.label;
              optionRow.append(checkbox, text);
              checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                  selectedValues = [...new Set([...selectedValues, opt.value])];
                } else {
                  selectedValues = selectedValues.filter((val) => val !== opt.value);
                }
                renderChips();
                setFieldValue(field.key, selectedValues, field);
                updateError(control, field);
              });
              optionsWrapper.append(optionRow);
            });
          };

          const renderChips = () => {
            chips.innerHTML = "";
            selectedValues.forEach((val) => {
              const opt = (field.options || []).find((o) => o.value === val);
              const chip = document.createElement("span");
              chip.className = "chip";
              chip.textContent = opt ? opt.label : val;
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.textContent = "√ó";
              removeBtn.addEventListener("click", () => {
                selectedValues = selectedValues.filter((v) => v !== val);
                renderChips();
                renderOptions(searchInput.value);
                setFieldValue(field.key, selectedValues, field);
              });
              chip.append(removeBtn);
              chips.append(chip);
            });
          };

          searchInput.addEventListener("input", (event) => {
            renderOptions(event.target.value);
          });

          renderOptions();
          renderChips();
          control.append(searchInput, chips, optionsWrapper);
          setFieldValue(field.key, selectedValues, field);
        } else if (field.type === "date") {
          const textInput = document.createElement("input");
          textInput.className = "field-input";
          textInput.id = `field-${field.key}`;
          textInput.setAttribute("aria-describedby", `error-${field.key}`);
          textInput.placeholder = field.placeholder || "gg.aa.yyyy";
          textInput.inputMode = "numeric";

          const nativeInput = document.createElement("input");
          nativeInput.type = "date";
          nativeInput.className = "field-input";
          nativeInput.style.display = "none";

          const initialDate = initialValue ? normalizeDateInput(initialValue) : "";
          if (initialDate) {
            const [y, m, d] = initialDate.split("-");
            textInput.value = `${d}.${m}.${y}`;
            nativeInput.value = initialDate;
          }

          const syncDate = (raw) => {
            const normalized = normalizeDateInput(raw);
            if (normalized && /^\\d{4}-\\d{2}-\\d{2}$/.test(normalized)) {
              const [y, m, d] = normalized.split("-");
              textInput.value = `${d}.${m}.${y}`;
              nativeInput.value = normalized;
              setFieldValue(field.key, normalized, field, textInput.value);
            } else {
              setFieldValue(field.key, "", field, raw);
            }
            updateError(control, field);
          };

          textInput.addEventListener("input", (event) => {
            const digits = event.target.value.replace(/\\D/g, "");
            if (digits.length === 8) {
              const formatted = `${digits.slice(0, 2)}.${digits.slice(2, 4)}.${digits.slice(4)}`;
              event.target.value = formatted;
            }
            setFieldValue(field.key, event.target.value, field);
          });
          textInput.addEventListener("blur", () => syncDate(textInput.value));
          nativeInput.addEventListener("change", (event) => syncDate(event.target.value));

          const actions = document.createElement("div");
          actions.className = "field-actions";
          if (field.ui?.showCalendar) {
            const calendarBtn = document.createElement("button");
            calendarBtn.type = "button";
            calendarBtn.className = "ghost";
            calendarBtn.setAttribute("aria-label", "Takvim a√ß");
            calendarBtn.textContent = "üìÖ";
            calendarBtn.addEventListener("click", () => {
              if (nativeInput.showPicker) {
                nativeInput.showPicker();
              } else {
                nativeInput.focus();
              }
            });
            actions.append(calendarBtn);
          }
          if (field.ui?.quickActions) {
            const todayBtn = document.createElement("button");
            todayBtn.type = "button";
            todayBtn.className = "ghost";
            todayBtn.textContent = "Bug√ºn";
            todayBtn.addEventListener("click", () => syncDate(getDateFromIso(getCurrentDateTime(config))));
            const tomorrowBtn = document.createElement("button");
            tomorrowBtn.type = "button";
            tomorrowBtn.className = "ghost";
            tomorrowBtn.textContent = "Yarƒ±n";
            tomorrowBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() + 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const yesterdayBtn = document.createElement("button");
            yesterdayBtn.type = "button";
            yesterdayBtn.className = "ghost";
            yesterdayBtn.textContent = "D√ºn";
            yesterdayBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() - 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const clearBtn = document.createElement("button");
            clearBtn.type = "button";
            clearBtn.className = "ghost";
            clearBtn.textContent = "Temizle";
            clearBtn.addEventListener("click", () => {
              textInput.value = "";
              nativeInput.value = "";
              setFieldValue(field.key, "", field);
              updateError(control, field);
            });
            actions.append(todayBtn, tomorrowBtn, yesterdayBtn, clearBtn);
          }

          control.append(textInput, nativeInput, actions);
        } else if (field.type === "datetime") {
          const dateInput = document.createElement("input");
          const timeInput = document.createElement("input");
          dateInput.type = "text";
          timeInput.type = "time";
          dateInput.className = "field-input";
          timeInput.className = "field-input";
          dateInput.id = `field-${field.key}`;
          dateInput.setAttribute("aria-describedby", `error-${field.key}`);
          timeInput.setAttribute("aria-describedby", `error-${field.key}`);
          const dateValue = initialValue ? getDateFromIso(initialValue) : "";
          const timeValue = initialValue ? getTimeFromIso(initialValue) : "";
          if (dateValue) {
            const [y, m, d] = dateValue.split("-");
            dateInput.value = `${d}.${m}.${y}`;
          }
          timeInput.value = timeValue;
          dateInput.placeholder = "gg.aa.yyyy";
          dateInput.inputMode = "numeric";

          const quickActions = document.createElement("div");
          quickActions.className = "field-actions";
          if (field.ui?.quickActions) {
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûimdi";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const isoDate = getDateFromIso(now);
              const isoTime = getTimeFromIso(now);
              dateInput.value = `${isoDate.slice(8, 10)}.${isoDate.slice(5, 7)}.${isoDate.slice(0, 4)}`;
              timeInput.value = isoTime;
              syncDatetime();
            });
            quickActions.append(nowBtn);
          }

          const syncDatetime = () => {
            const date = normalizeDateInput(dateInput.value);
            const time = normalizeTimeInput(timeInput.value);
            if (!date || !time) {
              setFieldValue(field.key, "", field);
            } else {
              const offset = getOffsetFromIso(getCurrentDateTime(config));
              setFieldValue(field.key, `${date}T${time}${offset}`, field);
            }
            updateError(control, field);
          };

          dateInput.addEventListener("change", syncDatetime);
          timeInput.addEventListener("change", syncDatetime);
          dateInput.addEventListener("blur", syncDatetime);
          timeInput.addEventListener("blur", syncDatetime);

          inputEl = document.createElement("div");
          inputEl.className = "grid two";
          inputEl.append(dateInput, timeInput);
          inlineActions = quickActions;
        } else if (field.type === "duration") {
          const durationInput = document.createElement("input");
          durationInput.className = "field-input";
          durationInput.setAttribute("aria-describedby", `error-${field.key}`);
          durationInput.placeholder = "hh:mm";
          durationInput.value = initialValue || "";
          durationInput.addEventListener("blur", () => {
            const normalized = normalizeTimeInput(durationInput.value);
            durationInput.value = normalized;
            const [h, m] = normalized.split(":");
            const minutes = (Number(h || 0) * 60) + Number(m || 0);
            if (field.ui?.durationFormat === "iso") {
              setFieldValue(field.key, `PT${Number(h || 0)}H${Number(m || 0)}M`, field, normalized);
            } else {
              setFieldValue(field.key, minutes, field, normalized);
            }
            updateError(control, field);
          });
          durationInput.addEventListener("input", () => {
            setFieldValue(field.key, durationInput.value, field);
          });
          inputEl = durationInput;
        } else if (field.type === "address") {
          const street = document.createElement("input");
          const district = document.createElement("input");
          const city = document.createElement("input");
          const postal = document.createElement("input");
          const country = document.createElement("input");
          [street, district, city, postal, country].forEach((input) => {
            input.className = "field-input";
          });
          street.placeholder = "Sokak / Mahalle";
          district.placeholder = "ƒ∞l√ße";
          city.placeholder = "ƒ∞l";
          postal.placeholder = "Posta Kodu";
          country.placeholder = "√úlke";
          const grid = document.createElement("div");
          grid.className = "grid two";
          grid.append(street, district, city, postal, country);
          const updateAddress = () => {
            const value = {
              street: street.value,
              district: district.value,
              city: city.value,
              postalCode: postal.value,
              country: country.value
            };
            setFieldValue(field.key, value, field);
            updateError(control, field);
          };
          [street, district, city, postal, country].forEach((input) => {
            input.addEventListener("input", updateAddress);
            input.addEventListener("blur", updateAddress);
          });
          inputEl = grid;
        } else if (["file", "multifile", "image"].includes(field.type)) {
          const drop = document.createElement("div");
          drop.className = "file-drop";
          drop.textContent = "Dosya s√ºr√ºkleyin veya se√ßin";

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "field-input";
          fileInput.id = `field-${field.key}`;
          fileInput.setAttribute("aria-describedby", `error-${field.key}`);
          const accept = field.ui?.accept || "";
          if (accept) fileInput.accept = accept;
          if (field.type !== "file" && field.type !== "image") fileInput.multiple = true;

          const list = document.createElement("div");
          list.className = "file-list";

          const renderFiles = () => {
            list.innerHTML = "";
            const files = state.fileBuffers[field.key] || [];
            files.forEach((file, idx) => {
              const row = document.createElement("div");
              row.className = "file-item";
              const left = document.createElement("div");
              left.className = "inline-row";
              const thumb = document.createElement("img");
              thumb.className = "file-thumb";
              if (file.preview) {
                thumb.src = file.preview;
              } else {
                thumb.alt = "dosya";
              }
              const meta = document.createElement("div");
              meta.className = "file-meta";
              meta.innerHTML = `<strong>${file.name}</strong><span>${Math.round(file.size / 1024)} KB</span>`;
              left.append(thumb, meta);
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "ghost";
              removeBtn.textContent = "Kaldƒ±r";
              removeBtn.addEventListener("click", () => {
                state.fileBuffers[field.key] = files.filter((_, fileIdx) => fileIdx !== idx);
                renderFiles();
                const filePayload = (state.fileBuffers[field.key] || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  lastModified: f.lastModified
                }));
                setFieldValue(field.key, filePayload, field);
                emit("onFileSelected", {
                  key: field.key,
                  files: filePayload,
                  rawFiles: (state.fileBuffers[field.key] || []).map((f) => f.raw)
                });
              });
              row.append(left, removeBtn);
              list.append(row);
            });
          };

          const handleFiles = (fileList) => {
            const files = Array.from(fileList);
            const maxFiles = field.ui?.maxFiles || (field.type === "multifile" ? 10 : 1);
            const maxSizeMB = field.ui?.maxSizeMB || 25;
            const errors = [];
            const accepted = [];

            files.forEach((file) => {
              if (accepted.length >= maxFiles) return;
              if (file.size > maxSizeMB * 1024 * 1024) {
                errors.push(`${file.name}: Dosya √ßok b√ºy√ºk.`);
                return;
              }
              if (accept && !file.type.match(accept.replace("*", ".*"))) {
                errors.push(`${file.name}: T√ºr desteklenmiyor.`);
                return;
              }
              accepted.push({
                raw: file,
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
                preview: field.ui?.showPreview && file.type.startsWith("image/") ? URL.createObjectURL(file) : ""
              });
            });

            if (errors.length) {
              setFieldValue(field.key, "", field);
              state.errors[field.key] = errors.join(" ");
            }

            state.fileBuffers[field.key] = field.type === "multifile" ? accepted : accepted.slice(0, 1);
            renderFiles();

            const filePayload = (state.fileBuffers[field.key] || []).map((file) => ({
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified
            }));
            setFieldValue(field.key, filePayload, field);
            emit("onFileSelected", {
              key: field.key,
              files: filePayload,
              rawFiles: (state.fileBuffers[field.key] || []).map((file) => file.raw)
            });
          };

          drop.addEventListener("dragover", (event) => {
            event.preventDefault();
            drop.style.borderColor = varPrimary();
          });
          drop.addEventListener("dragleave", () => {
            drop.style.borderColor = "";
          });
          drop.addEventListener("drop", (event) => {
            event.preventDefault();
            handleFiles(event.dataTransfer.files);
            drop.style.borderColor = "";
          });

          fileInput.addEventListener("change", (event) => {
            handleFiles(event.target.files);
          });

          control.append(drop, fileInput, list);
          setFieldValue(field.key, "", field);
        }

        if (inputEl) {
          control.append(inputEl);
          if (inlineActions) {
            control.append(inlineActions);
          }
        }

        wrapper.append(control);

        if (field.helpText && config.showInlineHelp) {
          const help = document.createElement("div");
          help.className = "helper-text";
          help.textContent = field.helpText;
          wrapper.append(help);
        }

        const errorText = document.createElement("div");
        errorText.className = "error-text";
        errorText.id = `error-${field.key}`;
        wrapper.append(errorText);

        formEl.append(wrapper);

        if (extraControls) {
          wrapper.append(extraControls);
        }

        if (index === 0 && config.autoFocusFirstInvalid) {
          setTimeout(() => {
            const focusTarget = wrapper.querySelector("input, textarea, select");
            if (focusTarget) focusTarget.focus();
          }, 0);
        }
      });
      updateSubmitState(config);
    }

    function varPrimary() {
      return getComputedStyle(document.documentElement).getPropertyValue("--primary");
    }

    function updateError(control, field) {
      const errorText = formEl.querySelector(`#error-${field.key}`);
      const error = state.errors[field.key] || "";
      errorText.textContent = error;
      if (error) {
        control.classList.add("invalid");
      } else {
        control.classList.remove("invalid");
      }
      updateSubmitState(state.config);
    }

    function updateSubmitState(config) {
      const isValid = Object.values(state.validMap).every(Boolean);
      if (config.requiredPolicy === "strict") {
        submitBtn.disabled = !isValid;
        submitBtn.title = isValid ? "" : "Zorunlu alanlarƒ± doldurun";
      } else {
        submitBtn.disabled = false;
        submitBtn.title = "";
      }
    }

    function focusFirstInvalid() {
      const firstInvalid = Object.keys(state.validMap).find((key) => !state.validMap[key]);
      if (!firstInvalid) return null;
      const target = document.querySelector(`#field-${firstInvalid}`) || document.querySelector(`[data-field='${firstInvalid}']`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "center" });
        if (target.focus) target.focus();
      }
      return firstInvalid;
    }

    function validateAll() {
      state.config.fields.forEach((field) => {
        let value = state.values[field.key];
        if (field.type === "date" && typeof value === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(value)) {
          value = normalizeDateInput(value);
          state.values[field.key] = value;
        }
        if (field.type === "time" && typeof value === "string") {
          value = normalizeTimeInput(value);
          state.values[field.key] = value;
        }
        state.errors[field.key] = validateField(field, value);
        state.validMap[field.key] = !state.errors[field.key];
        const control = document.querySelector(`#error-${field.key}`)?.parentElement?.querySelector(".field-control");
        if (control) updateError(control, field);
      });
    }

    formEl.addEventListener("submit", (event) => {
      event.preventDefault();
      validateAll();
      const firstInvalidKey = focusFirstInvalid();
      const invalidCount = Object.values(state.validMap).filter((val) => !val).length;
      if (invalidCount > 0) {
        summaryBox.style.display = "block";
        summaryBox.textContent = `${invalidCount} alan eksik veya hatalƒ±.`;
      } else {
        summaryBox.style.display = "none";
      }
      emit("onSubmitAttempt", {
        values: state.values,
        isFormValid: invalidCount === 0,
        firstInvalidKey
      });
    });

    formEl.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        if (event.target && event.target.blur) event.target.blur();
        return;
      }
      if (event.key !== "Enter") return;
      if (event.target?.tagName === "TEXTAREA") return;
      if (event.target?.type === "button") return;
      event.preventDefault();
      const focusables = Array.from(formEl.querySelectorAll("input, select, textarea")).filter((el) => !el.disabled && el.type !== "hidden");
      const currentIndex = focusables.indexOf(event.target);
      const next = focusables[currentIndex + 1];
      if (next) {
        next.focus();
      } else {
        submitBtn.click();
      }
    });

    clearBtn.addEventListener("click", () => {
      emit("onClear", {});
      renderForm(state.config);
    });

    document.getElementById("loadSample").addEventListener("click", () => {
      schemaInput.value = JSON.stringify(defaultSchema, null, 2);
      currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
      localeInput.value = defaultSchema.locale;
      timezoneInput.value = defaultSchema.timezone;
      modeInput.value = defaultSchema.mode;
      requiredPolicyInput.value = defaultSchema.requiredPolicy;
      showInlineHelpInput.checked = defaultSchema.showInlineHelp;
      autoFocusInvalidInput.checked = defaultSchema.autoFocusFirstInvalid;
    });

    document.getElementById("renderForm").addEventListener("click", () => {
      const parsed = safeJsonParse(schemaInput.value);
      if (!parsed || !parsed.fields) {
        setConsole("Schema parse edilemedi", "");
        return;
      }
      state.config = {
        ...parsed,
        currentDateTimeISO: currentDateTimeInput.value || parsed.currentDateTimeISO,
        locale: localeInput.value || parsed.locale || "tr-TR",
        timezone: timezoneInput.value || parsed.timezone || "Europe/Istanbul",
        mode: modeInput.value || parsed.mode || "create",
        requiredPolicy: requiredPolicyInput.value || parsed.requiredPolicy || "strict",
        showInlineHelp: showInlineHelpInput.checked,
        autoFocusFirstInvalid: autoFocusInvalidInput.checked
      };
      renderForm(state.config);
    });

    document.getElementById("clearConsole").addEventListener("click", () => {
      consoleEl.textContent = "";
    });

    currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
    schemaInput.value = JSON.stringify(defaultSchema, null, 2);
    state.config = { ...defaultSchema };
    renderForm(state.config);
  </script>
</body>
</html>
