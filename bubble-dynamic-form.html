<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Dynamic Form Element Demo</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e5e7eb;
      --danger: #ef4444;
      --success: #16a34a;
      --warning: #f59e0b;
      --focus: rgba(37, 99, 235, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      gap: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    h1, h2, h3 {
      margin: 0 0 12px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .required-star {
      color: var(--danger);
      font-weight: 700;
    }

    .required-hint {
      font-size: 0.75rem;
      color: var(--danger);
      font-weight: 600;
    }

    .field-wrapper {
      display: grid;
      gap: 6px;
      padding: 8px 0;
      border-bottom: 1px solid #eef2f7;
    }

    .field-wrapper:last-child {
      border-bottom: none;
    }

    .field-row {
      display: grid;
      grid-template-columns: minmax(180px, 35%) minmax(0, 65%);
      gap: 14px;
      align-items: start;
    }

    .field-label {
      display: grid;
      gap: 4px;
    }

    .label-top {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .label-text {
      font-weight: 700;
    }

    .label-meta {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .type-icon {
      font-size: 14px;
      line-height: 1;
    }

    .stage-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: capitalize;
    }

    .stage-optional {
      background: #f3f4f6;
      color: #6b7280;
    }

    .stage-mandatory {
      background: rgba(239, 68, 68, 0.12);
      color: var(--danger);
    }

    .stage-control {
      background: rgba(37, 99, 235, 0.12);
      color: var(--primary);
    }

    .ai-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(37, 99, 235, 0.25);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.12), rgba(99, 102, 241, 0.2));
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 0.7rem;
      cursor: pointer;
      color: var(--primary);
      white-space: nowrap;
    }

    .ai-badge img {
      width: 14px;
      height: 14px;
      display: inline-block;
      object-fit: contain;
    }

    .ai-badge.is-active {
      border-color: rgba(34, 197, 94, 0.4);
      background: rgba(34, 197, 94, 0.12);
      color: #15803d;
    }

    .control-stack {
      display: grid;
      gap: 6px;
    }

    .field-control {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2px;
      background: #fff;
      position: relative;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .field-control.ai-active {
      background: rgba(37, 99, 235, 0.06);
    }

    .field-control.ai-active .field-input {
      background: rgba(37, 99, 235, 0.04);
    }

    .ai-pill {
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 0.65rem;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.14);
      color: var(--primary);
      pointer-events: none;
    }

    .field-control:focus-within {
      border-color: rgba(37, 99, 235, 0.75);
      box-shadow: 0 0 0 3px var(--focus);
    }

    .field-control.invalid {
      border-color: rgba(239, 68, 68, 0.75);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.18);
    }

    .field-input,
    select,
    textarea {
      width: 100%;
      border: none;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 0.85rem;
      background: transparent;
      color: var(--text);
      outline: none;
      min-height: 34px;
    }

    textarea.field-input {
      resize: vertical;
      min-height: 96px;
    }

    .field-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .helper-text {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .error-text {
      font-size: 0.75rem;
      color: var(--danger);
      min-height: 16px;
    }

    .inline-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
    }

    button.secondary {
      background: #e5e7eb;
      color: var(--text);
    }

    button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .console {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.82rem;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      font-size: 0.7rem;
      font-weight: 600;
    }

    .chip button {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(37, 99, 235, 0.2);
    }

    .file-drop {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      color: var(--muted);
      background: #fafafa;
    }

    .file-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    .file-grid {
      display: grid;
      gap: 8px;
      margin-top: 10px;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    }

    .file-item {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
    }

    .file-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
      background: #fff;
    }

    .file-meta {
      display: grid;
      gap: 4px;
      font-size: 0.82rem;
    }

    .file-thumb {
      width: 52px;
      height: 52px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid var(--border);
      background: #f3f4f6;
    }

    .file-thumb.large {
      width: 100%;
      height: 90px;
    }

    .file-icon {
      font-size: 22px;
      width: 44px;
      text-align: center;
    }

    .file-remove {
      border: none;
      background: transparent;
      color: var(--danger);
      font-weight: 700;
      cursor: pointer;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .toggle input {
      width: 40px;
      height: 22px;
    }

    .summary-box {
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
    }

    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 999;
    }

    .lightbox.open {
      display: flex;
    }

    .lightbox-content {
      max-width: min(720px, 90vw);
      max-height: 80vh;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .lightbox-content img {
      width: 100%;
      height: auto;
      border-radius: 12px;
    }

    .lightbox-close {
      justify-self: end;
      background: #111827;
      color: #fff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
    }

    .debug-toolbar {
      position: sticky;
      top: 12px;
      z-index: 10;
      display: grid;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
    }

    .toolbar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .toolbar-actions button {
      padding: 8px 12px;
      font-size: 0.78rem;
    }

    .toolbar-status {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 600;
    }

    .debug-warning {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #f8fafc;
      margin-bottom: 16px;
    }

    .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

    .export-modal.open {
      display: flex;
    }

    .export-panel {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      width: min(920px, 95vw);
      max-height: 85vh;
      display: grid;
      gap: 12px;
    }

    .export-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .export-tabs button {
      padding: 6px 10px;
      font-size: 0.75rem;
    }

    .export-tabs button.active {
      background: var(--primary);
      color: #fff;
    }

    .export-panel textarea {
      width: 100%;
      min-height: 240px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
    }

    @media (max-width: 720px) {
      .field-row {
        grid-template-columns: 1fr;
        gap: 6px;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <section class="card">
      <h1>Bubble Dynamic Form Element</h1>
      <p class="helper-text">
        Bu demo tek HTML dosyasƒ±nda √ßalƒ±≈üƒ±r. Bubble elementine alan ≈üemasƒ±nƒ± JSON olarak girip ‚ÄúRender Et‚Äù diyebilirsiniz.
      </p>
      <div class="grid two">
        <div>
          <label for="schemaInput">Schema (fields + config)</label>
          <textarea id="schemaInput" class="field-input" rows="12"></textarea>
        </div>
        <div class="grid">
          <div>
            <label for="currentDateTime">currentDateTimeISO</label>
            <input id="currentDateTime" class="field-input" type="text" />
          </div>
          <div class="grid two">
            <div>
              <label for="localeInput">locale</label>
              <input id="localeInput" class="field-input" type="text" value="tr-TR" />
            </div>
            <div>
              <label for="timezoneInput">timezone</label>
              <input id="timezoneInput" class="field-input" type="text" value="Europe/Istanbul" />
            </div>
          </div>
          <div class="grid two">
            <div>
              <label for="modeInput">mode</label>
              <select id="modeInput" class="field-input">
                <option value="create">create</option>
                <option value="edit">edit</option>
              </select>
            </div>
            <div>
              <label for="requiredPolicyInput">requiredPolicy</label>
              <select id="requiredPolicyInput" class="field-input">
                <option value="strict">strict</option>
                <option value="soft">soft</option>
              </select>
            </div>
          </div>
          <div class="grid two">
            <div class="inline-row">
              <input id="showInlineHelp" type="checkbox" checked />
              <label for="showInlineHelp">showInlineHelp</label>
            </div>
            <div class="inline-row">
              <input id="autoFocusInvalid" type="checkbox" checked />
              <label for="autoFocusInvalid">autoFocusFirstInvalid</label>
            </div>
          </div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="loadSample">√ñrnek Schema Y√ºkle</button>
        <button class="secondary" id="renderForm">Render Et</button>
        <button class="ghost" id="clearConsole">Console Temizle</button>
      </div>
    </section>

    <section class="card">
      <h2>Event Console</h2>
      <div id="eventConsole" class="console"></div>
    </section>

    <section class="card">
      <h2>Dynamic Form</h2>
      <div class="debug-toolbar" id="debugToolbar">
        <div class="toolbar-actions">
          <button type="button" id="loadColumnJson">Column Y√ºkle (√ñrnek)</button>
          <button type="button" class="secondary" id="loadHumanJson">Human JSON Y√ºkle</button>
          <button type="button" class="secondary" id="loadPredictedJson">Predicted JSON Y√ºkle</button>
          <button type="button" class="ghost" id="applyAiToEmpty">AI -> Bo≈ü Human Alanlara Uygula</button>
          <button type="button" class="ghost" id="overwriteAiToAll">AI -> Hepsini Overwrite</button>
          <button type="button" class="ghost" id="resetStores">Reset</button>
          <button type="button" class="secondary" id="exportJson">Export JSON</button>
        </div>
        <div class="toolbar-status">
          <span id="aiFieldCount">AI alan sayƒ±sƒ±: 0</span>
          <span id="humanFieldCount">Human deƒüi≈ütirilen alan sayƒ±sƒ±: 0</span>
        </div>
      </div>
      <div id="columnWarning" class="debug-warning" style="display:none;">
        Column JSON y√ºklenmedi. Debug toolbar √ºzerinden √∂rnek y√ºkleyin.
      </div>
      <div id="formContainer">
        <div id="summaryBox" class="summary-box" style="display:none;"></div>
        <form id="dynamicForm" class="grid"></form>
        <div class="inline-row" style="margin-top: 12px;">
          <button id="submitBtn" type="submit">Submit</button>
          <button id="clearBtn" type="button" class="ghost">Temizle</button>
        </div>
      </div>
    </section>
  </main>
  <div id="lightbox" class="lightbox" aria-hidden="true">
    <div class="lightbox-content">
      <button type="button" class="lightbox-close">Kapat</button>
      <img id="lightboxImage" alt="√ñnizleme" />
    </div>
  </div>
  <div id="exportModal" class="export-modal" aria-hidden="true">
    <div class="export-panel">
      <div class="inline-row" style="justify-content: space-between;">
        <strong>JSON Export</strong>
        <button type="button" class="ghost" id="closeExport">Kapat</button>
      </div>
      <div class="export-tabs">
        <button type="button" class="secondary active" data-export-tab="export">Aktif JSON</button>
        <button type="button" class="secondary" data-export-tab="human">Human JSON</button>
        <button type="button" class="secondary" data-export-tab="ai">Predicted JSON</button>
        <button type="button" class="secondary" data-export-tab="column">Column JSON</button>
      </div>
      <textarea id="exportContent" readonly></textarea>
    </div>
  </div>

  <script>
    const DEBUG_MODE = true;

    let MANUAL_COLUMN_JSON = null;
    let MANUAL_DATA_JSON = null;
    let MANUAL_PREDICTED_JSON = null;

    const SAMPLE_COLUMN_JSON = {
      columns: [
        {
          fieldName: "Davacƒ± Ad Soyad",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Davacƒ± TCKN/VKN",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Kaza Tarihi",
          type: "date",
          required: true,
          stageType: "mandatory",
          default: "$TODAY"
        },
        {
          fieldName: "ƒ∞htar Tarihi",
          type: "date",
          required: false,
          stageType: "optional"
        },
        {
          fieldName: "Randevu Datetime",
          type: "datetime",
          stageType: "control"
        },
        {
          fieldName: "Uygun Saat",
          type: "time",
          stageType: "optional"
        },
        {
          fieldName: "Aracƒ±n Tipi",
          type: "single_select",
          stageType: "mandatory",
          options: [
            { value: "Hususi", label: "Hususi" },
            { value: "Ticari", label: "Ticari" },
            { value: "Kiralƒ±k", label: "Kiralƒ±k" }
          ]
        },
        {
          fieldName: "Ek √ñzellikler",
          type: "multi_select",
          stageType: "optional",
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri g√∂r√º≈ü kamera" }
          ]
        },
        {
          fieldName: "Hasar Onarƒ±m Tutarƒ±",
          type: "currency",
          stageType: "mandatory"
        },
        {
          fieldName: "Kusur Oranƒ±",
          type: "percent",
          stageType: "mandatory"
        },
        {
          fieldName: "Aracƒ±n Kilometresi",
          type: "number",
          stageType: "optional"
        },
        {
          fieldName: "Belgeleri Y√ºkle",
          type: "file",
          allowMultiple: false,
          stageType: "control"
        },
        {
          fieldName: "Hasar Fotoƒüraflarƒ±",
          type: "image",
          allowMultiple: true,
          stageType: "optional"
        },
        {
          fieldName: "Ek Dosyalar",
          type: "multifile",
          allowMultiple: true,
          stageType: "optional"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create"
    };

    const SAMPLE_DATA_JSON = {
      "Belgeleri Y√ºkle": "https://gaiasphere.io/version-live/fileupload/f1770577885537x578585456537153500/hasar_ekspertiz_raporu.pdf",
      "Davacƒ± Kimlik Tipi": "TC Kimlik",
      "Davacƒ± Ad Soyad": "ƒ∞SMAƒ∞L Dƒ∞NCER",
      "Davacƒ± TCKN/VKN": "12928963404",
      "Davacƒ± Plaka": "19BA618",
      "Davacƒ± Marka Model": "TOYOTA COROLLA 1,6 TERRA SEDAN (Y) 2006",
      "Davacƒ± ≈ûase No": "NMTBZ28E90R141719",
      "Kar≈üƒ± Ad Soyad": "YILMAZ HI≈ûIR",
      "Kar≈üƒ± TCKN/VKN": "31066362344",
      "Kar≈üƒ± Plaka": "19ABA563",
      "Kaza Tarihi": "2024-11-15",
      "Aracƒ±n Markasƒ±": "TOYOTA",
      "Aracƒ±n Tipi": "Hususi",
      "Aracƒ±n Model Yƒ±lƒ±": "2006",
      "Kaza Yeri": "√áorum / Merkez / √ñƒüretmen Lisesi 1. Cad. ‚Äì √ñƒüretmen Lisesi Cad. kav≈üaƒüƒ±",
      "Davacƒ± Ara√ß S√ºr√ºc√ºs√º": "ƒ∞SMAƒ∞L Dƒ∞NCER",
      "Kar≈üƒ± Ara√ß S√ºr√ºc√ºs√º": "YILMAZ HI≈ûIR",
      "Kar≈üƒ± Poli√ße T√ºr√º": "Zorunlu Trafik Sigortasƒ±",
      "Kar≈üƒ± Poli√ße No": "104781355",
      "Kar≈üƒ± Poli√ße Biti≈ü Tarihi": "2025-09-03",
      "Kaza tespit tutanaƒüƒ± t√ºr√º": "Anla≈ümalƒ± Kaza Tespit Tutanaƒüƒ±",
      "Eksper Rp Tarihi": "2025-02-28",
      "Hasar Onarƒ±m Tutarƒ±": "140000",
      "Kusur Oranƒ±": "75",
      "Davali Adi": "Corpus Sigorta A.≈û.",
      "Aracƒ±n Kilometresi": "231328",
      "action": "DK Hesaba Ta≈üƒ±",
      "ƒ∞htar Tarihi": "Bug√ºn√ºn tarihi",
      "predictedAction": "ƒ∞htar Dilek√ßesi Hazƒ±rla",
      "uniqueid": "1770577890579x349136294770973500",
      "Stage": "DK Hesabƒ±",
      "Hasar Fotoƒüraflarƒ±": [
        "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=800&q=60",
        "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=800&q=60"
      ],
      "Ek Dosyalar": [
        "https://example.com/docs/hasar-foto-1.pdf",
        "https://example.com/docs/hasar-foto-2.pdf"
      ],
      "Esas No": ""
    };

    const SAMPLE_PREDICTED_JSON = {
      "ƒ∞htar Tarihi": "$TODAY",
      "Hasar Onarƒ±m Tutarƒ±": "145000",
      "Kusur Oranƒ±": "80",
      "predictedAction": "ƒ∞htar Dilek√ßesi Hazƒ±rla"
    };

    let columnJson = null;
    let humanData = {};
    let aiData = {};
    let sourceByField = {};

    const schemaInput = document.getElementById("schemaInput");
    const currentDateTimeInput = document.getElementById("currentDateTime");
    const localeInput = document.getElementById("localeInput");
    const timezoneInput = document.getElementById("timezoneInput");
    const modeInput = document.getElementById("modeInput");
    const requiredPolicyInput = document.getElementById("requiredPolicyInput");
    const showInlineHelpInput = document.getElementById("showInlineHelp");
    const autoFocusInvalidInput = document.getElementById("autoFocusInvalid");
    const formEl = document.getElementById("dynamicForm");
    const submitBtn = document.getElementById("submitBtn");
    const clearBtn = document.getElementById("clearBtn");
    const summaryBox = document.getElementById("summaryBox");
    const formContainer = document.getElementById("formContainer");
    const consoleEl = document.getElementById("eventConsole");
    const lightboxEl = document.getElementById("lightbox");
    const lightboxImage = document.getElementById("lightboxImage");
    const exportModal = document.getElementById("exportModal");
    const exportContent = document.getElementById("exportContent");
    const exportTabs = document.querySelectorAll("[data-export-tab]");
    const loadHumanJsonBtn = document.getElementById("loadHumanJson");
    const loadPredictedJsonBtn = document.getElementById("loadPredictedJson");
    const loadColumnJsonBtn = document.getElementById("loadColumnJson");
    const applyAiToEmptyBtn = document.getElementById("applyAiToEmpty");
    const overwriteAiToAllBtn = document.getElementById("overwriteAiToAll");
    const resetStoresBtn = document.getElementById("resetStores");
    const exportJsonBtn = document.getElementById("exportJson");
    const closeExportBtn = document.getElementById("closeExport");
    const aiFieldCountEl = document.getElementById("aiFieldCount");
    const humanFieldCountEl = document.getElementById("humanFieldCount");
    const columnWarning = document.getElementById("columnWarning");
    const debugToolbar = document.getElementById("debugToolbar");

    const state = {
      config: null,
      values: {},
      validMap: {},
      touched: {},
      errors: {},
      autoSaveTimer: null,
      fileBuffers: {},
      fileStaging: {},
      fieldRefs: {},
      columnData: null
    };

    const defaultSchema = {
      fields: [
        {
          key: "fullName",
          label: "Ad Soyad",
          type: "text",
          required: true,
          placeholder: "√ñrn. Ay≈üe Yƒ±lmaz",
          helpText: "Kimlikteki ad-soyad",
          minLen: 3
        },
        {
          key: "email",
          label: "E-posta",
          type: "email",
          required: true,
          placeholder: "ornek@mail.com"
        },
        {
          key: "phone",
          label: "Telefon",
          type: "phone",
          required: true,
          placeholder: "05xx xxx xx xx",
          ui: { autoTrPrefix: true }
        },
        {
          key: "website",
          label: "Website",
          type: "url",
          placeholder: "https://",
          ui: { suggestHttps: true }
        },
        {
          key: "password",
          label: "≈ûifre",
          type: "password",
          required: true,
          minLen: 8
        },
        {
          key: "bio",
          label: "A√ßƒ±klama",
          type: "textarea",
          placeholder: "Kƒ±sa notlar...",
          maxLen: 240
        },
        {
          key: "age",
          label: "Ya≈ü",
          type: "integer",
          min: 18,
          max: 99
        },
        {
          key: "salary",
          label: "Maa≈ü (‚Ç∫)",
          type: "currency",
          ui: { currency: "‚Ç∫", step: 0.01, thousandSeparator: true }
        },
        {
          key: "discount",
          label: "ƒ∞ndirim (%)",
          type: "percent",
          ui: { step: 0.1 }
        },
        {
          key: "subscribe",
          label: "KVKK Onayƒ±",
          type: "boolean",
          required: true,
          helpText: "Zorunlu onay"
        },
        {
          key: "vehicleType",
          label: "Ara√ß Tipi",
          type: "single_select",
          options: [
            { value: "hususi", label: "Hususi", group: "Binek" },
            { value: "ticari", label: "Ticari", group: "Ticari" },
            { value: "kiralik", label: "Kiralƒ±k", group: "Ticari" }
          ],
          required: true
        },
        {
          key: "extras",
          label: "Ek √ñzellikler",
          type: "multi_select",
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri g√∂r√º≈ü kamera" },
            { value: "isik", label: "LED far" }
          ]
        },
        {
          key: "appointmentDate",
          label: "Randevu Tarihi",
          type: "date",
          required: true,
          default: "$TODAY",
          ui: { showCalendar: true, allowTyping: true, quickActions: true }
        },
        {
          key: "appointmentDateTime",
          label: "Randevu Datetime",
          type: "datetime",
          default: "$NOW",
          ui: { quickActions: true }
        },
        {
          key: "appointmentTime",
          label: "Uygun Saat",
          type: "time",
          default: "$CURRENT_TIME",
          ui: { quickActions: true }
        },
        {
          key: "duration",
          label: "S√ºre",
          type: "duration",
          ui: { durationFormat: "minutes" }
        },
        {
          key: "address",
          label: "Adres",
          type: "address",
          helpText: "Minimum sokak, il√ße, il ve posta kodu"
        },
        {
          key: "attachments",
          label: "Dosyalar",
          type: "multifile",
          ui: { accept: "image/*,application/pdf", maxFiles: 5, maxSizeMB: 10, showPreview: true }
        },
        {
          key: "profileImage",
          label: "Profil Fotoƒürafƒ±",
          type: "image",
          ui: { accept: "image/*", maxFiles: 1, maxSizeMB: 5, showPreview: true }
        },
        {
          key: "metadata",
          label: "JSON (advanced)",
          type: "json",
          placeholder: "{\"foo\":\"bar\"}"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create",
      initialValues: {},
      requiredPolicy: "strict",
      showInlineHelp: true,
      autoFocusFirstInvalid: true
    };

    const sampleColumnData = {
      columns: defaultSchema.fields.map((field) => ({
        key: field.key,
        label: field.label,
        type: field.type
      })),
      source: "sample-column-json"
    };

    function setConsole(message, payload) {
      const timestamp = new Date().toLocaleTimeString("tr-TR");
      consoleEl.textContent += `[${timestamp}] ${message}` + (payload ? `\n${payload}` : "") + "\n";
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function emit(eventName, detail) {
      setConsole(eventName, JSON.stringify(detail, null, 2));
    }

    function safeJsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return null;
      }
    }

    function getCurrentDateTime(config) {
      return config.currentDateTimeISO || new Date().toISOString();
    }

    function getOffsetFromIso(iso) {
      const match = String(iso).match(/([+-]\d{2}:?\d{2}|Z)$/);
      if (!match) return "Z";
      if (match[1] === "Z") return "Z";
      const offset = match[1].includes(":") ? match[1] : `${match[1].slice(0, 3)}:${match[1].slice(3)}`;
      return offset;
    }

    function getDateFromIso(iso) {
      return String(iso).slice(0, 10);
    }

    function getTimeFromIso(iso) {
      return String(iso).slice(11, 16);
    }

    function normalizeDateInput(raw) {
      if (!raw) return "";
      const trimmed = raw.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmed)) {
        const [d, m, y] = trimmed.split(".");
        return `${y}-${m}-${d}`;
      }
      if (/^\d{8}$/.test(trimmed)) {
        const d = trimmed.slice(0, 2);
        const m = trimmed.slice(2, 4);
        const y = trimmed.slice(4, 8);
        return `${y}-${m}-${d}`;
      }
      return trimmed;
    }

    function normalizeTimeInput(raw) {
      if (!raw) return "";
      const cleaned = raw.replace(/\s/g, "");
      if (/^\d{1,2}$/.test(cleaned)) return `${cleaned.padStart(2, "0")}:00`;
      if (/^\d{3}$/.test(cleaned)) return `${cleaned.slice(0, 1).padStart(2, "0")}:${cleaned.slice(1)}`;
      if (/^\d{4}$/.test(cleaned)) return `${cleaned.slice(0, 2)}:${cleaned.slice(2)}`;
      if (/^\d{2}:\d{2}$/.test(cleaned)) return cleaned;
      return cleaned;
    }

    function normalizeNumberInput(raw) {
      if (raw === null || raw === undefined || raw === "") return "";
      const normalized = String(raw).replace(/\./g, "").replace(",", ".");
      return normalized;
    }

    function formatNumberDisplay(value, options = {}) {
      if (value === "" || value === null || value === undefined || Number.isNaN(Number(value))) return "";
      const numeric = Number(value);
      const formatter = new Intl.NumberFormat("tr-TR", {
        minimumFractionDigits: options.minimumFractionDigits || 0,
        maximumFractionDigits: options.maximumFractionDigits || 2
      });
      return formatter.format(numeric);
    }

    function formatDateDisplay(value) {
      if (!value) return "";
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const [y, m, d] = value.split("-");
        return `${d}.${m}.${y}`;
      }
      return value;
    }

    function getDefaultValue(field, config) {
      if (!field.default) return "";
      const token = field.default;
      const now = getCurrentDateTime(config);
      if (token === "$NOW") return now;
      if (token === "$TODAY") return getDateFromIso(now);
      if (token === "$CURRENT_TIME") return getTimeFromIso(now);
      return token;
    }

    function getInitialValue(field, config) {
      const initialValues = config.initialValues || {};
      if (initialValues[field.key] !== undefined) return initialValues[field.key];
      if (config.mode === "create") {
        return getDefaultValue(field, config);
      }
      return "";
    }

    function isEmptyValue(value) {
      if (Array.isArray(value)) return value.length === 0;
      if (value === null || value === undefined) return true;
      if (typeof value === "string") return value.trim() === "";
      return false;
    }

    function normalizeKey(key) {
      if (key === null || key === undefined) return "";
      return String(key).trim();
    }

    function buildFieldKeyMap() {
      const map = new Map();
      (state.config?.fields || []).forEach((field) => {
        if (field.fieldName) map.set(normalizeKey(field.fieldName), field.key);
        if (field.key) map.set(normalizeKey(field.key), field.key);
        if (field.label) map.set(normalizeKey(field.label), field.key);
      });
      return map;
    }

    function getFieldKeyFromJsonKey(jsonKey, keyMap) {
      if (!jsonKey) return null;
      return keyMap.get(normalizeKey(jsonKey)) || null;
    }

    function getActiveSource(fieldKey) {
      return sourceByField[fieldKey] || "human";
    }

    function getStoreValue(fieldKey, source) {
      return source === "ai" ? aiData[fieldKey] : humanData[fieldKey];
    }

    function getEffectiveValue(fieldKey) {
      const activeSource = getActiveSource(fieldKey);
      const aiValue = aiData[fieldKey];
      if (activeSource === "ai" && !isEmptyValue(aiValue)) {
        return aiValue;
      }
      return humanData[fieldKey];
    }

    function setHumanValue(fieldKey, value, field, displayValue) {
      humanData[fieldKey] = value;
      sourceByField[fieldKey] = "human";
      updateEffectiveState(fieldKey, field, displayValue);
      updateAiVisuals(fieldKey);
      updateToolbarStatus();
    }

    function updateEffectiveState(fieldKey, field, displayValue) {
      const effectiveValue = getEffectiveValue(fieldKey);
      state.values[fieldKey] = effectiveValue;
      let validationValue = effectiveValue;
      if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(effectiveValue)) {
        const stagedFiles = state.fileBuffers[fieldKey] || [];
        if (stagedFiles.length) {
          validationValue = ["__file_selected__"];
        }
      }
      const error = validateField(field, validationValue);
      state.errors[fieldKey] = error;
      state.validMap[fieldKey] = !error;
      emit("onFieldChange", {
        key: fieldKey,
        value: effectiveValue,
        displayValue: displayValue ?? effectiveValue,
        source: getActiveSource(fieldKey),
        isValid: !error
      });
      debounceFormChange();
    }

    function updateToolbarStatus() {
      const aiCount = Object.values(aiData).filter((value) => !isEmptyValue(value)).length;
      const humanCount = Object.entries(humanData).filter(([key, value]) => {
        return sourceByField[key] === "human" && !isEmptyValue(value);
      }).length;
      aiFieldCountEl.textContent = `AI alan sayƒ±sƒ±: ${aiCount}`;
      humanFieldCountEl.textContent = `Human deƒüi≈ütirilen alan sayƒ±sƒ±: ${humanCount}`;
    }

    const typeMetaMap = {
      text: { icon: "üìù", label: "Text" },
      textarea: { icon: "üìù", label: "Textarea" },
      email: { icon: "‚úâÔ∏è", label: "Email" },
      phone: { icon: "üìû", label: "Phone" },
      url: { icon: "üîó", label: "URL" },
      integer: { icon: "üî¢", label: "Integer" },
      number: { icon: "üî¢", label: "Number" },
      decimal: { icon: "üî¢", label: "Decimal" },
      currency: { icon: "üî¢", label: "Currency" },
      percent: { icon: "üî¢", label: "Percent" },
      boolean: { icon: "‚úÖ", label: "Boolean" },
      single_select: { icon: "‚¨áÔ∏è", label: "Single select" },
      multi_select: { icon: "üß©", label: "Multi select" },
      date: { icon: "üìÖ", label: "Date" },
      time: { icon: "‚è±Ô∏è", label: "Time" },
      datetime: { icon: "üóìÔ∏è‚è±Ô∏è", label: "Datetime" },
      file: { icon: "üìé", label: "File" },
      image: { icon: "üñºÔ∏è", label: "Image" },
      multifile: { icon: "üóÇÔ∏è", label: "Multi file" }
    };

    function getTypeMeta(type) {
      return typeMetaMap[type] || { icon: "üìù", label: type || "text" };
    }

    function normalizeStageType(stageType) {
      if (!stageType) return "";
      return String(stageType).trim().toLowerCase();
    }

    function getStageBadge(stageType) {
      const normalized = normalizeStageType(stageType);
      if (!["optional", "mandatory", "control"].includes(normalized)) return null;
      const badge = document.createElement("span");
      badge.className = `stage-badge stage-${normalized}`;
      badge.textContent = normalized === "optional" ? "Optional" : normalized === "mandatory" ? "Mandatory" : "Control";
      return badge;
    }

    function isImageLike(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith("image/")) return true;
      if (file.url) {
        return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(file.url);
      }
      return false;
    }

    function parseInitialFiles(initialValue, allowMultiple) {
      if (!initialValue) return [];
      let values = Array.isArray(initialValue) ? initialValue : [initialValue];
      if (!allowMultiple && values.length > 1) {
        values = [values[0]];
      }
      return values
        .filter((val) => typeof val === "string")
        .map((url) => ({
          url,
          name: url.split("/").pop() || "dosya",
          size: 0,
          type: isImageLike({ url }) ? "image/*" : "",
          lastModified: null,
          preview: url
        }));
    }

    function resolveTokenValue(rawValue, field, config) {
      if (rawValue === "$TODAY") {
        return getDateFromIso(getCurrentDateTime(config));
      }
      if (rawValue === "$NOW") {
        return getCurrentDateTime(config);
      }
      if (rawValue === "$CURRENT_TIME") {
        return getTimeFromIso(getCurrentDateTime(config));
      }
      return rawValue;
    }

    function normalizeJsonValueForField(field, value, config) {
      if (value === null || value === undefined) return "";
      let resolved = resolveTokenValue(value, field, config);
      if (field.type === "date") {
        resolved = normalizeDateInput(String(resolved));
        return resolved;
      }
      if (field.type === "time") {
        resolved = normalizeTimeInput(String(resolved));
        return resolved;
      }
      if (field.type === "datetime") {
        const raw = String(resolved);
        if (raw === "$TODAY") {
          const date = getDateFromIso(getCurrentDateTime(config));
          const offset = getOffsetFromIso(getCurrentDateTime(config));
          return `${date}T00:00${offset}`;
        }
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
          const offset = getOffsetFromIso(getCurrentDateTime(config));
          return `${raw}T00:00${offset}`;
        }
        return raw;
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        return normalizeNumberInput(resolved);
      }
      if (field.type === "boolean") {
        if (typeof resolved === "string") {
          return resolved.toLowerCase() === "true";
        }
        return Boolean(resolved);
      }
      if (field.type === "multi_select") {
        if (Array.isArray(resolved)) return resolved;
        if (typeof resolved === "string") return resolved.split(",").map((val) => val.trim()).filter(Boolean);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(resolved)) return resolved.filter((val) => typeof val === "string");
        if (typeof resolved === "string") return resolved;
        return "";
      }
      return resolved;
    }

    function updateAiVisuals(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const aiValue = aiData[fieldKey];
      const hasAi = !isEmptyValue(aiValue);
      const activeSource = getActiveSource(fieldKey);
      ref.aiBadge.style.display = hasAi ? "inline-flex" : "none";
      ref.aiBadge.classList.toggle("is-active", activeSource === "ai");
      ref.control.classList.toggle("ai-active", activeSource === "ai" && hasAi);
      ref.aiPill.style.display = activeSource === "ai" && hasAi ? "inline-flex" : "none";
    }

    function updateFieldDisplayValue(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const value = getEffectiveValue(fieldKey);
      if (ref.setValue) {
        ref.setValue(value);
      }
      updateAiVisuals(fieldKey);
      updateEffectiveState(fieldKey, ref.field);
    }

    function refreshAllFields() {
      Object.keys(state.fieldRefs).forEach((fieldKey) => {
        updateFieldDisplayValue(fieldKey);
      });
      updateToolbarStatus();
    }

    function loadJsonSafeToForm(kind, jsonObj) {
      if (!jsonObj || !state.config) return;
      const keyMap = buildFieldKeyMap();
      Object.entries(jsonObj).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) {
          console.warn(`E≈üle≈ümeyen JSON key: ${jsonKey}`);
          setConsole("E≈üle≈ümeyen JSON key", jsonKey);
          return;
        }
        const field = state.config.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        const normalized = normalizeJsonValueForField(field, rawValue, state.config);
        if (kind === "ai") {
          aiData[fieldKey] = normalized;
        } else {
          humanData[fieldKey] = normalized;
          sourceByField[fieldKey] = "human";
        }
      });
      refreshAllFields();
    }

    function initializeSourceByFieldFromAi() {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        sourceByField[field.key] = !isEmptyValue(aiValue) ? "ai" : "human";
      });
    }

    function buildConfigFromColumnJson(columnData) {
      if (!columnData) return null;
      const columns = columnData.columns || [];
      const fields = columns.map((column, index) => {
        const fieldName = column.fieldName || column.label || column.key || `field_${index + 1}`;
        return {
          key: fieldName,
          fieldName,
          label: column.label || fieldName,
          type: column.type || "text",
          required: Boolean(column.required),
          stageType: column.stageType || "optional",
          allowMultiple: Boolean(column.allowMultiple),
          options: column.options || [],
          default: column.default,
          ui: column.ui || {}
        };
      });
      return {
        fields,
        currentDateTimeISO: columnData.currentDateTimeISO || defaultSchema.currentDateTimeISO,
        locale: columnData.locale || "tr-TR",
        timezone: columnData.timezone || "Europe/Istanbul",
        mode: columnData.mode || "create",
        requiredPolicy: defaultSchema.requiredPolicy,
        showInlineHelp: defaultSchema.showInlineHelp,
        autoFocusFirstInvalid: defaultSchema.autoFocusFirstInvalid
      };
    }

    function applyColumnJson(columnData) {
      columnJson = columnData;
      if (!columnJson) {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
        return;
      }
      columnWarning.style.display = "none";
      formContainer.style.display = "block";
      state.config = buildConfigFromColumnJson(columnJson);
      if (!state.config) return;
      renderForm(state.config);
    }

    function normalizeExportValue(field, value) {
      if (value === undefined) return "";
      if (value === null) return "";
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        if (value === "") return "";
        const numeric = Number(value);
        return Number.isNaN(numeric) ? value : numeric;
      }
      if (field.type === "date") {
        return value ? normalizeDateInput(String(value)) : "";
      }
      if (field.type === "time") {
        return value ? normalizeTimeInput(String(value)) : "";
      }
      return value;
    }

    function buildExportJson() {
      const payload = {};
      (state.config?.fields || []).forEach((field) => {
        const value = getEffectiveValue(field.key);
        const jsonKey = field.fieldName || field.label || field.key;
        payload[jsonKey] = normalizeExportValue(field, value);
      });
      return payload;
    }

    function validateField(field, value) {
      if (field.required && isEmptyValue(value)) {
        if (field.type === "boolean") {
          return "Zorunlu onay gerekir.";
        }
        return "Bu alan zorunlu.";
      }
      if (field.type === "email" && value) {
        if (!String(value).includes("@")) return "Ge√ßerli bir e-posta girin.";
      }
      if (field.type === "phone" && value) {
        if (!/\d{10,}/.test(String(value).replace(/\D/g, ""))) return "Telefon formatƒ± hatalƒ±.";
      }
      if (field.type === "url" && value) {
        if (!/^https?:\/\//.test(String(value))) return "URL http(s):// ile ba≈ülamalƒ±.";
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type) && value !== "") {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) return "Ge√ßerli bir sayƒ± girin.";
        if (field.min !== undefined && numeric < field.min) return `Minimum ${field.min}`;
        if (field.max !== undefined && numeric > field.max) return `Maksimum ${field.max}`;
        if (field.type === "percent" && (numeric < 0 || numeric > 100)) return "0-100 arasƒ± girin.";
      }
      if (["text", "textarea", "password", "email", "url"].includes(field.type) && value) {
        if (field.minLen && String(value).length < field.minLen) return `En az ${field.minLen} karakter.`;
        if (field.maxLen && String(value).length > field.maxLen) return `En fazla ${field.maxLen} karakter.`;
        if (field.pattern) {
          const regex = new RegExp(field.pattern);
          if (!regex.test(String(value))) return field.validate?.find((r) => r.name === "regex")?.message || "Format hatasƒ±.";
        }
      }
      if (["date", "datetime", "time"].includes(field.type) && value) {
        if (field.type === "date" && !/^\d{4}-\d{2}-\d{2}$/.test(String(value)) && !/^\d{2}\.\d{2}\.\d{4}$/.test(String(value))) {
          return "Tarih formatƒ± gg.aa.yyyy veya yyyy-mm-dd olmalƒ±.";
        }
        if (field.type === "time" && !/^\d{2}:\d{2}$/.test(String(value))) return "Saat formatƒ± HH:mm olmalƒ±.";
        if (field.type === "datetime" && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(String(value))) return "Tarih ve saat gerekli.";
      }
      return "";
    }

    function setFieldValue(key, value, field, displayValue) {
      setHumanValue(key, value, field, displayValue);
    }

    function debounceFormChange() {
      if (state.autoSaveTimer) {
        clearTimeout(state.autoSaveTimer);
      }
      state.autoSaveTimer = setTimeout(() => {
        emit("onFormChange", {
          values: buildExportJson(),
          validMap: state.validMap,
          isFormValid: Object.values(state.validMap).every(Boolean)
        });
      }, 500);
    }

    function renderForm(config) {
      formEl.innerHTML = "";
      state.values = {};
      state.validMap = {};
      state.errors = {};
      state.touched = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.fieldRefs = {};
      summaryBox.style.display = "none";

      config.fields.forEach((field, index) => {
        const wrapper = document.createElement("div");
        wrapper.className = "field-wrapper";

        const row = document.createElement("div");
        row.className = "field-row";

        const labelColumn = document.createElement("div");
        labelColumn.className = "field-label";

        const labelTop = document.createElement("div");
        labelTop.className = "label-top";

        const typeMeta = getTypeMeta(field.type);
        const typeIcon = document.createElement("span");
        typeIcon.className = "type-icon";
        typeIcon.textContent = typeMeta.icon;
        typeIcon.title = typeMeta.label;

        const label = document.createElement("label");
        label.className = "label-text";
        label.htmlFor = `field-${field.key}`;
        label.textContent = field.label;

        labelTop.append(typeIcon, label);

        if (field.required) {
          const star = document.createElement("span");
          star.className = "required-star";
          star.textContent = "*";
          labelTop.append(star);
        }

        const labelMeta = document.createElement("div");
        labelMeta.className = "label-meta";

        const stageBadge = getStageBadge(field.stageType);
        if (stageBadge) labelMeta.append(stageBadge);

        const aiBadge = document.createElement("button");
        aiBadge.type = "button";
        aiBadge.className = "ai-badge";
        aiBadge.title = "AI √∂nerisi var. Tƒ±kla: ƒ∞nsan moduna ge√ß / AI moduna d√∂n";
        aiBadge.innerHTML = `<img src="https://upload.wikimedia.org/wikipedia/commons/0/04/ChatGPT_logo.svg" alt="ChatGPT logo" /><span>ChatGPT</span>`;
        aiBadge.addEventListener("click", () => {
          const currentSource = getActiveSource(field.key);
          const hasAi = !isEmptyValue(aiData[field.key]);
          if (!hasAi) return;
          const nextSource = currentSource === "ai" ? "human" : "ai";
          sourceByField[field.key] = nextSource;
          updateFieldDisplayValue(field.key);
          emit("onPredictedToggle", {
            key: field.key,
            mode: nextSource
          });
        });
        labelMeta.append(aiBadge);

        labelColumn.append(labelTop);
        if (labelMeta.childElementCount) {
          labelColumn.append(labelMeta);
        }

        const control = document.createElement("div");
        control.className = "field-control";
        const aiPill = document.createElement("span");
        aiPill.className = "ai-pill";
        aiPill.textContent = "AI";
        aiPill.style.display = "none";
        control.append(aiPill);

        let inputEl = null;
        let extraControls = null;
        let inlineActions = null;
        let setValue = null;

        const initialValue = getInitialValue(field, config);
        if (humanData[field.key] === undefined) {
          humanData[field.key] = initialValue;
        }
        if (!sourceByField[field.key]) {
          sourceByField[field.key] = "human";
        }
        if (isEmptyValue(humanData[field.key]) && !isEmptyValue(aiData[field.key])) {
          sourceByField[field.key] = "ai";
        }
        const effectiveInitial = getEffectiveValue(field.key);
        state.values[field.key] = effectiveInitial;
        state.validMap[field.key] = !validateField(field, effectiveInitial);

        if (["text", "email", "phone", "url", "password", "integer", "decimal", "currency", "percent", "number", "time"].includes(field.type)) {
          inputEl = document.createElement("input");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          if (field.type === "password") inputEl.type = "password";
          if (field.type === "email") inputEl.type = "email";
          if (field.type === "url") inputEl.type = "url";
          if (field.type === "phone") inputEl.type = "tel";
          if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) inputEl.inputMode = field.type === "integer" ? "numeric" : "decimal";
          if (field.type === "time") inputEl.type = "time";

          setValue = (value) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const formatted = field.type === "integer"
                ? formatNumberDisplay(value, { maximumFractionDigits: 0 })
                : formatNumberDisplay(value, { maximumFractionDigits: 2 });
              inputEl.value = formatted || (value ?? "");
              return;
            }
            if (field.type === "time") {
              inputEl.value = value ? normalizeTimeInput(String(value)) : "";
              return;
            }
            inputEl.value = value ?? "";
          };
          setValue(effectiveInitial);

          inputEl.addEventListener("input", (event) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const raw = event.target.value;
              setFieldValue(field.key, normalizeNumberInput(raw), field, raw);
            } else {
              setFieldValue(field.key, event.target.value, field);
            }
          });

          inputEl.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            let value = event.target.value;
            if (field.type === "time") {
              value = normalizeTimeInput(value);
              event.target.value = value;
            }
            if (field.type === "email" && value) {
              value = value.toLowerCase();
              event.target.value = value;
            }
            if (field.type === "phone" && value && field.ui?.autoTrPrefix) {
              const digits = value.replace(/\D/g, "");
              if (digits.startsWith("0")) {
                value = `+90${digits.slice(1)}`;
                event.target.value = value;
              }
            }
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const normalized = normalizeNumberInput(value);
              const formatted = field.type === "integer" ? formatNumberDisplay(normalized, { maximumFractionDigits: 0 }) : formatNumberDisplay(normalized, { maximumFractionDigits: 2 });
              event.target.value = formatted || value;
              setFieldValue(field.key, normalized, field, formatted);
            } else {
              setFieldValue(field.key, value, field);
            }
            updateError(control, field);
          });

          if (field.type === "time" && field.ui?.quickActions) {
            const actions = document.createElement("div");
            actions.className = "field-actions";
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûu an";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const timeValue = getTimeFromIso(now);
              inputEl.value = timeValue;
              setFieldValue(field.key, timeValue, field);
              updateError(control, field);
            });
            actions.append(nowBtn);
            inlineActions = actions;
          }
        } else if (field.type === "textarea" || field.type === "json") {
          inputEl = document.createElement("textarea");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          inputEl.value = effectiveInitial || "";
          setValue = (value) => {
            inputEl.value = value ?? "";
          };

          inputEl.addEventListener("input", (event) => {
            setFieldValue(field.key, event.target.value, field);
          });
          inputEl.addEventListener("blur", () => {
            updateError(control, field);
          });
        } else if (field.type === "boolean") {
          control.classList.add("toggle");
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.setAttribute("aria-label", field.label);
          inputEl.checked = Boolean(effectiveInitial);
          setValue = (value) => {
            inputEl.checked = Boolean(value);
          };
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = "Evet";
          control.append(inputEl, toggleLabel);
          inputEl.addEventListener("change", () => {
            setFieldValue(field.key, inputEl.checked, field);
            updateError(control, field);
          });
        } else if (field.type === "single_select") {
          const searchInput = document.createElement("input");
          searchInput.className = "field-input";
          searchInput.placeholder = "Ara...";
          const select = document.createElement("select");
          select.className = "field-input";
          select.id = `field-${field.key}`;
          select.setAttribute("aria-describedby", `error-${field.key}`);

          const buildOptions = (filter = "") => {
            select.innerHTML = "";
            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "Se√ßiniz";
            select.append(emptyOption);
            const groups = {};
            (field.options || []).forEach((opt) => {
              if (filter && !opt.label.toLowerCase().includes(filter.toLowerCase())) return;
              if (opt.group) {
                if (!groups[opt.group]) groups[opt.group] = [];
                groups[opt.group].push(opt);
              } else {
                groups.__default = groups.__default || [];
                groups.__default.push(opt);
              }
            });

            Object.entries(groups).forEach(([groupName, opts]) => {
              if (groupName === "__default") {
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  select.append(option);
                });
              } else {
                const group = document.createElement("optgroup");
                group.label = groupName;
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  group.append(option);
                });
                select.append(group);
              }
            });
          };

          buildOptions();
          select.value = effectiveInitial || "";
          setValue = (value) => {
            select.value = value ?? "";
          };

          searchInput.addEventListener("input", (event) => {
            buildOptions(event.target.value);
          });
          select.addEventListener("change", () => {
            setFieldValue(field.key, select.value, field);
            updateError(control, field);
          });

          extraControls = document.createElement("div");
          extraControls.className = "field-actions";
          extraControls.append(searchInput);
          control.append(select);
        } else if (field.type === "multi_select") {
          const searchInput = document.createElement("input");
          searchInput.className = "field-input";
          searchInput.placeholder = "Ara...";

          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "grid";

          const chips = document.createElement("div");
          chips.className = "chip-row";

          let selectedValues = Array.isArray(effectiveInitial) ? effectiveInitial : [];

          const renderOptions = (filter = "") => {
            optionsWrapper.innerHTML = "";
            (field.options || []).forEach((opt) => {
              if (filter && !opt.label.toLowerCase().includes(filter.toLowerCase())) return;
              const optionRow = document.createElement("label");
              optionRow.className = "inline-row";
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.checked = selectedValues.includes(opt.value);
              checkbox.disabled = opt.disabled || false;
              const text = document.createElement("span");
              text.textContent = opt.label;
              optionRow.append(checkbox, text);
              checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                  selectedValues = [...new Set([...selectedValues, opt.value])];
                } else {
                  selectedValues = selectedValues.filter((val) => val !== opt.value);
                }
                renderChips();
                setFieldValue(field.key, selectedValues, field);
                updateError(control, field);
              });
              optionsWrapper.append(optionRow);
            });
          };

          const renderChips = () => {
            chips.innerHTML = "";
            selectedValues.forEach((val) => {
              const opt = (field.options || []).find((o) => o.value === val);
              const chip = document.createElement("span");
              chip.className = "chip";
              chip.textContent = opt ? opt.label : val;
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.textContent = "√ó";
              removeBtn.addEventListener("click", () => {
                selectedValues = selectedValues.filter((v) => v !== val);
                renderChips();
                renderOptions(searchInput.value);
                setFieldValue(field.key, selectedValues, field);
              });
              chip.append(removeBtn);
              chips.append(chip);
            });
          };

          searchInput.addEventListener("input", (event) => {
            renderOptions(event.target.value);
          });

          renderOptions();
          renderChips();
          setValue = (value) => {
            selectedValues = Array.isArray(value) ? value : [];
            renderOptions(searchInput.value);
            renderChips();
          };
          control.append(searchInput, chips, optionsWrapper);
          updateEffectiveState(field.key, field);
        } else if (field.type === "date") {
          const textInput = document.createElement("input");
          textInput.className = "field-input";
          textInput.id = `field-${field.key}`;
          textInput.setAttribute("aria-describedby", `error-${field.key}`);
          textInput.placeholder = field.placeholder || "gg.aa.yyyy";
          textInput.inputMode = "numeric";

          const nativeInput = document.createElement("input");
          nativeInput.type = "date";
          nativeInput.className = "field-input";
          nativeInput.style.display = "none";

          const initialDate = effectiveInitial ? normalizeDateInput(effectiveInitial) : "";
          if (initialDate) {
            const [y, m, d] = initialDate.split("-");
            textInput.value = `${d}.${m}.${y}`;
            nativeInput.value = initialDate;
          }

          setValue = (value) => {
            const normalized = value ? normalizeDateInput(String(value)) : "";
            if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
              const [y, m, d] = normalized.split("-");
              textInput.value = `${d}.${m}.${y}`;
              nativeInput.value = normalized;
            } else {
              textInput.value = value ?? "";
              nativeInput.value = "";
            }
          };

          const syncDate = (raw) => {
            const normalized = normalizeDateInput(raw);
            if (normalized && /^\\d{4}-\\d{2}-\\d{2}$/.test(normalized)) {
              const [y, m, d] = normalized.split("-");
              textInput.value = `${d}.${m}.${y}`;
              nativeInput.value = normalized;
              setFieldValue(field.key, normalized, field, textInput.value);
            } else {
              setFieldValue(field.key, "", field, raw);
            }
            updateError(control, field);
          };

          textInput.addEventListener("input", (event) => {
            const digits = event.target.value.replace(/\\D/g, "");
            if (digits.length === 8) {
              const formatted = `${digits.slice(0, 2)}.${digits.slice(2, 4)}.${digits.slice(4)}`;
              event.target.value = formatted;
            }
            setFieldValue(field.key, event.target.value, field);
          });
          textInput.addEventListener("blur", () => syncDate(textInput.value));
          nativeInput.addEventListener("change", (event) => syncDate(event.target.value));

          const actions = document.createElement("div");
          actions.className = "field-actions";
          if (field.ui?.showCalendar) {
            const calendarBtn = document.createElement("button");
            calendarBtn.type = "button";
            calendarBtn.className = "ghost";
            calendarBtn.setAttribute("aria-label", "Takvim a√ß");
            calendarBtn.textContent = "üìÖ";
            calendarBtn.addEventListener("click", () => {
              if (nativeInput.showPicker) {
                nativeInput.showPicker();
              } else {
                nativeInput.focus();
              }
            });
            actions.append(calendarBtn);
          }
          if (field.ui?.quickActions) {
            const todayBtn = document.createElement("button");
            todayBtn.type = "button";
            todayBtn.className = "ghost";
            todayBtn.textContent = "Bug√ºn";
            todayBtn.addEventListener("click", () => syncDate(getDateFromIso(getCurrentDateTime(config))));
            const tomorrowBtn = document.createElement("button");
            tomorrowBtn.type = "button";
            tomorrowBtn.className = "ghost";
            tomorrowBtn.textContent = "Yarƒ±n";
            tomorrowBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() + 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const yesterdayBtn = document.createElement("button");
            yesterdayBtn.type = "button";
            yesterdayBtn.className = "ghost";
            yesterdayBtn.textContent = "D√ºn";
            yesterdayBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() - 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const clearBtn = document.createElement("button");
            clearBtn.type = "button";
            clearBtn.className = "ghost";
            clearBtn.textContent = "Temizle";
            clearBtn.addEventListener("click", () => {
              textInput.value = "";
              nativeInput.value = "";
              setFieldValue(field.key, "", field);
              updateError(control, field);
            });
            actions.append(todayBtn, tomorrowBtn, yesterdayBtn, clearBtn);
          }

          control.append(textInput, nativeInput, actions);
        } else if (field.type === "datetime") {
          const dateInput = document.createElement("input");
          const timeInput = document.createElement("input");
          dateInput.type = "text";
          timeInput.type = "time";
          dateInput.className = "field-input";
          timeInput.className = "field-input";
          dateInput.id = `field-${field.key}`;
          dateInput.setAttribute("aria-describedby", `error-${field.key}`);
          timeInput.setAttribute("aria-describedby", `error-${field.key}`);
          const dateValue = effectiveInitial ? getDateFromIso(effectiveInitial) : "";
          const timeValue = effectiveInitial ? getTimeFromIso(effectiveInitial) : "";
          if (dateValue) {
            const [y, m, d] = dateValue.split("-");
            dateInput.value = `${d}.${m}.${y}`;
          }
          timeInput.value = timeValue;
          dateInput.placeholder = "gg.aa.yyyy";
          dateInput.inputMode = "numeric";

          setValue = (value) => {
            if (!value) {
              dateInput.value = "";
              timeInput.value = "";
              return;
            }
            const isoDate = getDateFromIso(value);
            const isoTime = getTimeFromIso(value);
            if (isoDate) {
              dateInput.value = `${isoDate.slice(8, 10)}.${isoDate.slice(5, 7)}.${isoDate.slice(0, 4)}`;
            }
            timeInput.value = isoTime || "";
          };

          const quickActions = document.createElement("div");
          quickActions.className = "field-actions";
          if (field.ui?.quickActions) {
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûimdi";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const isoDate = getDateFromIso(now);
              const isoTime = getTimeFromIso(now);
              dateInput.value = `${isoDate.slice(8, 10)}.${isoDate.slice(5, 7)}.${isoDate.slice(0, 4)}`;
              timeInput.value = isoTime;
              syncDatetime();
            });
            quickActions.append(nowBtn);
          }

          const syncDatetime = () => {
            const date = normalizeDateInput(dateInput.value);
            const time = normalizeTimeInput(timeInput.value);
            if (!date || !time) {
              setFieldValue(field.key, "", field);
            } else {
              const offset = getOffsetFromIso(getCurrentDateTime(config));
              setFieldValue(field.key, `${date}T${time}${offset}`, field);
            }
            updateError(control, field);
          };

          dateInput.addEventListener("change", syncDatetime);
          timeInput.addEventListener("change", syncDatetime);
          dateInput.addEventListener("blur", syncDatetime);
          timeInput.addEventListener("blur", syncDatetime);

          inputEl = document.createElement("div");
          inputEl.className = "grid two";
          inputEl.append(dateInput, timeInput);
          inlineActions = quickActions;
        } else if (field.type === "duration") {
          const durationInput = document.createElement("input");
          durationInput.className = "field-input";
          durationInput.setAttribute("aria-describedby", `error-${field.key}`);
          durationInput.placeholder = "hh:mm";
          durationInput.value = effectiveInitial || "";
          setValue = (value) => {
            durationInput.value = value ?? "";
          };
          durationInput.addEventListener("blur", () => {
            const normalized = normalizeTimeInput(durationInput.value);
            durationInput.value = normalized;
            const [h, m] = normalized.split(":");
            const minutes = (Number(h || 0) * 60) + Number(m || 0);
            if (field.ui?.durationFormat === "iso") {
              setFieldValue(field.key, `PT${Number(h || 0)}H${Number(m || 0)}M`, field, normalized);
            } else {
              setFieldValue(field.key, minutes, field, normalized);
            }
            updateError(control, field);
          });
          durationInput.addEventListener("input", () => {
            setFieldValue(field.key, durationInput.value, field);
          });
          inputEl = durationInput;
        } else if (field.type === "address") {
          const street = document.createElement("input");
          const district = document.createElement("input");
          const city = document.createElement("input");
          const postal = document.createElement("input");
          const country = document.createElement("input");
          [street, district, city, postal, country].forEach((input) => {
            input.className = "field-input";
          });
          street.placeholder = "Sokak / Mahalle";
          district.placeholder = "ƒ∞l√ße";
          city.placeholder = "ƒ∞l";
          postal.placeholder = "Posta Kodu";
          country.placeholder = "√úlke";
          const grid = document.createElement("div");
          grid.className = "grid two";
          grid.append(street, district, city, postal, country);
          setValue = (value) => {
            const normalized = value && typeof value === "object" ? value : {};
            street.value = normalized.street || "";
            district.value = normalized.district || "";
            city.value = normalized.city || "";
            postal.value = normalized.postalCode || "";
            country.value = normalized.country || "";
          };
          setValue(effectiveInitial);
          const updateAddress = () => {
            const value = {
              street: street.value,
              district: district.value,
              city: city.value,
              postalCode: postal.value,
              country: country.value
            };
            setFieldValue(field.key, value, field);
            updateError(control, field);
          };
          [street, district, city, postal, country].forEach((input) => {
            input.addEventListener("input", updateAddress);
            input.addEventListener("blur", updateAddress);
          });
          inputEl = grid;
        } else if (["file", "multifile", "image"].includes(field.type)) {
          const drop = document.createElement("div");
          drop.className = "file-drop";
          drop.textContent = "Dosya s√ºr√ºkleyin veya se√ßin";

          const allowMultiple = field.type === "multifile" || field.allowMultiple === true;

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "field-input";
          fileInput.id = `field-${field.key}`;
          fileInput.setAttribute("aria-describedby", `error-${field.key}`);
          const accept = field.ui?.accept || "";
          if (accept) fileInput.accept = accept;
          fileInput.multiple = allowMultiple;

          const list = document.createElement("div");
          list.className = "file-list";

          const renderFiles = () => {
            list.innerHTML = "";
            const files = state.fileBuffers[field.key] || [];
            const isImageGrid = field.type === "image" && (fileInput.multiple || files.length > 1);
            list.className = isImageGrid ? "file-grid" : "file-list";

            files.forEach((file, idx) => {
              const isImage = field.type === "image" || isImageLike(file);
              const row = document.createElement("div");
              row.className = isImageGrid ? "file-card" : "file-item";
              const meta = document.createElement("div");
              meta.className = "file-meta";
              meta.innerHTML = `<strong>${file.name}</strong><span>${Math.round(file.size / 1024)} KB</span>`;

              if (isImage) {
                const thumb = document.createElement("img");
                thumb.className = isImageGrid ? "file-thumb large" : "file-thumb";
                thumb.src = file.preview || file.url || "";
                thumb.alt = file.name || "g√∂rsel";
                thumb.addEventListener("click", () => openLightbox(file.preview || file.url || ""));
                if (isImageGrid) {
                  row.append(thumb);
                } else {
                  const left = document.createElement("div");
                  left.className = "inline-row";
                  left.append(thumb, meta);
                  row.append(left);
                }
              } else {
                const left = document.createElement("div");
                left.className = "inline-row";
                const icon = document.createElement("div");
                icon.className = "file-icon";
                icon.textContent = "üìÑ";
                left.append(icon, meta);
                row.append(left);
              }

              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "file-remove";
              removeBtn.textContent = "√ó";
              removeBtn.addEventListener("click", () => {
                state.fileBuffers[field.key] = files.filter((_, fileIdx) => fileIdx !== idx);
                renderFiles();
                if (file.url) {
                  const currentValue = getEffectiveValue(field.key);
                  const values = Array.isArray(currentValue) ? currentValue : currentValue ? [currentValue] : [];
                  const filtered = values.filter((val) => val !== file.url);
                  if (allowMultiple) {
                    humanData[field.key] = filtered;
                  } else {
                    humanData[field.key] = filtered[0] || "";
                  }
                } else {
                  humanData[field.key] = "";
                }
                const filePayload = (state.fileBuffers[field.key] || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  lastModified: f.lastModified
                }));
                state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((f) => f.raw).filter(Boolean);
                sourceByField[field.key] = "human";
                updateEffectiveState(field.key, field);
                updateAiVisuals(field.key);
                emit("onFileSelected", {
                  key: field.key,
                  files: filePayload,
                  rawFiles: (state.fileBuffers[field.key] || []).map((f) => f.raw)
                });
              });

              if (isImageGrid) {
                row.append(meta, removeBtn);
              } else {
                row.append(removeBtn);
              }

              list.append(row);
            });
          };

          const handleFiles = (fileList) => {
            const files = Array.from(fileList);
            const maxFiles = field.ui?.maxFiles || (allowMultiple ? 10 : 1);
            const maxSizeMB = field.ui?.maxSizeMB || 25;
            const errors = [];
            const accepted = [];

            files.forEach((file) => {
              if (accepted.length >= maxFiles) return;
              if (file.size > maxSizeMB * 1024 * 1024) {
                errors.push(`${file.name}: Dosya √ßok b√ºy√ºk.`);
                return;
              }
              if (accept && !file.type.match(accept.replace("*", ".*"))) {
                errors.push(`${file.name}: T√ºr desteklenmiyor.`);
                return;
              }
              accepted.push({
                raw: file,
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
                preview: field.ui?.showPreview && file.type.startsWith("image/") ? URL.createObjectURL(file) : ""
              });
            });

            if (errors.length) {
              setFieldValue(field.key, "", field);
              state.errors[field.key] = errors.join(" ");
            }

            state.fileBuffers[field.key] = field.type === "multifile" || fileInput.multiple ? accepted : accepted.slice(0, 1);
            renderFiles();

            const filePayload = (state.fileBuffers[field.key] || []).map((file) => ({
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified
            }));
            state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((file) => file.raw).filter(Boolean);
            humanData[field.key] = "";
            sourceByField[field.key] = "human";
            updateEffectiveState(field.key, field);
            updateAiVisuals(field.key);
            console.log("Pending file selected", {
              field: field.key,
              files: filePayload
            });
            emit("onFileSelected", {
              key: field.key,
              files: filePayload,
              rawFiles: (state.fileBuffers[field.key] || []).map((file) => file.raw)
            });
          };

          drop.addEventListener("dragover", (event) => {
            event.preventDefault();
            drop.style.borderColor = varPrimary();
          });
          drop.addEventListener("dragleave", () => {
            drop.style.borderColor = "";
          });
          drop.addEventListener("drop", (event) => {
            event.preventDefault();
            handleFiles(event.dataTransfer.files);
            drop.style.borderColor = "";
          });

          fileInput.addEventListener("change", (event) => {
            handleFiles(event.target.files);
          });

          control.append(drop, fileInput, list);
          setValue = (value) => {
            const initialFiles = parseInitialFiles(value, allowMultiple);
            if (initialFiles.length) {
              state.fileBuffers[field.key] = initialFiles;
            } else if (!state.fileStaging[field.key]?.length) {
              state.fileBuffers[field.key] = [];
            }
            renderFiles();
          };
          setValue(effectiveInitial);
          updateEffectiveState(field.key, field);
        }

        if (inputEl) {
          control.append(inputEl);
          if (inlineActions) {
            control.append(inlineActions);
          }
        }

        if (field.helpText && config.showInlineHelp) {
          const help = document.createElement("div");
          help.className = "helper-text";
          help.textContent = field.helpText;
          labelColumn.append(help);
        }

        const errorText = document.createElement("div");
        errorText.className = "error-text";
        errorText.id = `error-${field.key}`;

        const controlStack = document.createElement("div");
        controlStack.className = "control-stack";
        controlStack.append(control);
        if (extraControls) {
          controlStack.append(extraControls);
        }
        controlStack.append(errorText);

        state.fieldRefs[field.key] = {
          field,
          control,
          inputEl,
          setValue,
          aiBadge,
          aiPill
        };
        updateAiVisuals(field.key);

        row.append(labelColumn, controlStack);
        wrapper.append(row);
        formEl.append(wrapper);

        if (index === 0 && config.autoFocusFirstInvalid) {
          setTimeout(() => {
            const focusTarget = wrapper.querySelector("input, textarea, select");
            if (focusTarget) focusTarget.focus();
          }, 0);
        }
      });
      updateToolbarStatus();
      updateSubmitState(config);
    }

    function varPrimary() {
      return getComputedStyle(document.documentElement).getPropertyValue("--primary");
    }

    function openLightbox(src) {
      if (!src) return;
      lightboxImage.src = src;
      lightboxEl.classList.add("open");
      lightboxEl.setAttribute("aria-hidden", "false");
    }

    function closeLightbox() {
      lightboxEl.classList.remove("open");
      lightboxEl.setAttribute("aria-hidden", "true");
      lightboxImage.src = "";
    }

    function openExportModal(kind = "export") {
      exportModal.classList.add("open");
      exportModal.setAttribute("aria-hidden", "false");
      setExportTab(kind);
    }

    function closeExportModal() {
      exportModal.classList.remove("open");
      exportModal.setAttribute("aria-hidden", "true");
      exportContent.value = "";
    }

    function setExportTab(kind) {
      exportTabs.forEach((tab) => {
        tab.classList.toggle("active", tab.dataset.exportTab === kind);
      });
      if (kind === "human") {
        exportContent.value = JSON.stringify(humanData, null, 2);
        return;
      }
      if (kind === "ai") {
        exportContent.value = JSON.stringify(aiData, null, 2);
        return;
      }
      if (kind === "column") {
        exportContent.value = JSON.stringify(columnJson || {}, null, 2);
        return;
      }
      exportContent.value = JSON.stringify(buildExportJson(), null, 2);
    }

    lightboxEl.addEventListener("click", (event) => {
      if (event.target === lightboxEl) {
        closeLightbox();
      }
    });

    lightboxEl.querySelector(".lightbox-close").addEventListener("click", closeLightbox);
    closeExportBtn.addEventListener("click", closeExportModal);
    exportModal.addEventListener("click", (event) => {
      if (event.target === exportModal) {
        closeExportModal();
      }
    });
    exportTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        setExportTab(tab.dataset.exportTab);
      });
    });

    function updateError(control, field) {
      const errorText = formEl.querySelector(`#error-${field.key}`);
      const error = state.errors[field.key] || "";
      errorText.textContent = error;
      if (error) {
        control.classList.add("invalid");
      } else {
        control.classList.remove("invalid");
      }
      updateSubmitState(state.config);
    }

    function updateSubmitState(config) {
      const isValid = Object.values(state.validMap).every(Boolean);
      if (config.requiredPolicy === "strict") {
        submitBtn.disabled = !isValid;
        submitBtn.title = isValid ? "" : "Zorunlu alanlarƒ± doldurun";
      } else {
        submitBtn.disabled = false;
        submitBtn.title = "";
      }
    }

    function focusFirstInvalid() {
      const firstInvalid = Object.keys(state.validMap).find((key) => !state.validMap[key]);
      if (!firstInvalid) return null;
      const target = document.querySelector(`#field-${firstInvalid}`) || document.querySelector(`[data-field='${firstInvalid}']`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "center" });
        if (target.focus) target.focus();
      }
      return firstInvalid;
    }

    function validateAll() {
      state.config.fields.forEach((field) => {
        let value = getEffectiveValue(field.key);
        if (field.type === "date" && typeof value === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(value)) {
          value = normalizeDateInput(value);
        }
        if (field.type === "time" && typeof value === "string") {
          value = normalizeTimeInput(value);
        }
        state.values[field.key] = value;
        let validationValue = value;
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(value)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        state.errors[field.key] = validateField(field, validationValue);
        state.validMap[field.key] = !state.errors[field.key];
        const control = document.querySelector(`#error-${field.key}`)?.parentElement?.querySelector(".field-control");
        if (control) updateError(control, field);
      });
    }

    function applyAiValuesToHuman({ overwrite }) {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        if (isEmptyValue(aiValue)) return;
        if (!overwrite && !isEmptyValue(humanData[field.key])) return;
        humanData[field.key] = aiValue;
        sourceByField[field.key] = "human";
      });
      refreshAllFields();
    }

    function resetAllStores() {
      humanData = {};
      aiData = {};
      sourceByField = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.values = {};
      state.validMap = {};
      state.errors = {};
      if (columnJson) {
        applyColumnJson(columnJson);
      } else {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
      }
    }

    formEl.addEventListener("submit", (event) => {
      event.preventDefault();
      validateAll();
      const firstInvalidKey = focusFirstInvalid();
      const invalidCount = Object.values(state.validMap).filter((val) => !val).length;
      if (invalidCount > 0) {
        summaryBox.style.display = "block";
        summaryBox.textContent = `${invalidCount} alan eksik veya hatalƒ±.`;
      } else {
        summaryBox.style.display = "none";
      }
      emit("onSubmitAttempt", {
        values: buildExportJson(),
        isFormValid: invalidCount === 0,
        firstInvalidKey
      });
    });

    formEl.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        if (event.target && event.target.blur) event.target.blur();
        return;
      }
      if (event.key !== "Enter") return;
      if (event.target?.tagName === "TEXTAREA") return;
      if (event.target?.type === "button") return;
      event.preventDefault();
      const focusables = Array.from(formEl.querySelectorAll("input, select, textarea")).filter((el) => !el.disabled && el.type !== "hidden");
      const currentIndex = focusables.indexOf(event.target);
      const next = focusables[currentIndex + 1];
      if (next) {
        next.focus();
      } else {
        submitBtn.click();
      }
    });

    clearBtn.addEventListener("click", () => {
      emit("onClear", {});
      resetAllStores();
    });

    loadHumanJsonBtn.addEventListener("click", () => {
      const payload = MANUAL_DATA_JSON || SAMPLE_DATA_JSON;
      if (!payload) {
        humanData = {};
        refreshAllFields();
        return;
      }
      loadJsonSafeToForm("human", payload);
    });

    loadPredictedJsonBtn.addEventListener("click", () => {
      const payload = MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON;
      if (!payload) {
        aiData = {};
        initializeSourceByFieldFromAi();
        refreshAllFields();
        return;
      }
      loadJsonSafeToForm("ai", payload);
      initializeSourceByFieldFromAi();
      refreshAllFields();
    });

    loadColumnJsonBtn.addEventListener("click", () => {
      columnJson = MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON;
      applyColumnJson(columnJson);
      setConsole("Column data y√ºklendi", JSON.stringify(columnJson, null, 2));
    });

    applyAiToEmptyBtn.addEventListener("click", () => {
      applyAiValuesToHuman({ overwrite: false });
    });

    overwriteAiToAllBtn.addEventListener("click", () => {
      const confirmed = window.confirm("AI t√ºm alanlarƒ± overwrite edecek. Devam edilsin mi?");
      if (!confirmed) return;
      applyAiValuesToHuman({ overwrite: true });
    });

    resetStoresBtn.addEventListener("click", () => {
      resetAllStores();
    });

    exportJsonBtn.addEventListener("click", () => {
      openExportModal("export");
    });

    document.getElementById("loadSample").addEventListener("click", () => {
      schemaInput.value = JSON.stringify(defaultSchema, null, 2);
      currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
      localeInput.value = defaultSchema.locale;
      timezoneInput.value = defaultSchema.timezone;
      modeInput.value = defaultSchema.mode;
      requiredPolicyInput.value = defaultSchema.requiredPolicy;
      showInlineHelpInput.checked = defaultSchema.showInlineHelp;
      autoFocusInvalidInput.checked = defaultSchema.autoFocusFirstInvalid;
    });

    document.getElementById("renderForm").addEventListener("click", () => {
      const parsed = safeJsonParse(schemaInput.value);
      if (!parsed || !parsed.fields) {
        setConsole("Schema parse edilemedi", "");
        return;
      }
      state.config = {
        ...parsed,
        currentDateTimeISO: currentDateTimeInput.value || parsed.currentDateTimeISO,
        locale: localeInput.value || parsed.locale || "tr-TR",
        timezone: timezoneInput.value || parsed.timezone || "Europe/Istanbul",
        mode: modeInput.value || parsed.mode || "create",
        requiredPolicy: requiredPolicyInput.value || parsed.requiredPolicy || "strict",
        showInlineHelp: showInlineHelpInput.checked,
        autoFocusFirstInvalid: autoFocusInvalidInput.checked
      };
      columnJson = {
        columns: (state.config.fields || []).map((field) => ({
          fieldName: field.label || field.key,
          label: field.label,
          type: field.type,
          required: field.required,
          stageType: field.stageType || "optional",
          options: field.options || [],
          default: field.default,
          allowMultiple: field.allowMultiple || field.ui?.allowMultiple || false,
          ui: field.ui || {}
        })),
        currentDateTimeISO: state.config.currentDateTimeISO,
        locale: state.config.locale,
        timezone: state.config.timezone,
        mode: state.config.mode
      };
      columnWarning.style.display = "none";
      formContainer.style.display = "block";
      renderForm(state.config);
    });

    document.getElementById("clearConsole").addEventListener("click", () => {
      consoleEl.textContent = "";
    });

    currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
    schemaInput.value = JSON.stringify(defaultSchema, null, 2);
    debugToolbar.style.display = DEBUG_MODE ? "grid" : "none";
    if (!DEBUG_MODE) {
      columnWarning.style.display = "none";
    } else {
      columnWarning.style.display = columnJson ? "none" : "block";
    }
    if (columnJson) {
      applyColumnJson(columnJson);
    } else {
      formEl.innerHTML = "";
      formContainer.style.display = "none";
    }
  </script>
</body>
</html>
