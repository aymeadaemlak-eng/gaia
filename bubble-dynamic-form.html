<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Dynamic Form Element Demo</title>
  <!--
  ❗️BU BLOK ARTIK DEĞİŞTİRİLMEYECEK. ALTINDAN GÜNCELLEME YAPILACAK.
  Veriyi tam buraya gireceksin (örnek değerlerle gösterim):
  -->
  <script>
    window.BUBBLE_INPUTS = {
      COLUMN_JSON: {
        columns: [
          { fieldName: "Ad Soyad", type: "text", required: true }
        ],
        currentDateTimeISO: "2026-02-09T12:34:56+03:00",
        locale: "tr-TR",
        timezone: "Europe/Istanbul",
        mode: "create"
      },
      BUBBLE_DATA_JSON: {
        "Ad Soyad": "Ayşe Yılmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      PREDICTED_JSON: {
        "Ad Soyad": "Ayşe Yılmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      actionoptions: {
        options: [
          { id: "1770577890579x349136294770973500", name: "DK Hesaba Taşı" },
          { id: "1770577890579x349136294770973501", name: "İhtar Dilekçesi Hazırla" }
        ]
      },
      start: false,
      editing: true,
      EDITING_STAGE_GROUPS_JSON: [],
      EDITING_ALL_FIELDS_JSON: [],
      VERSION: true
    };
  </script>
  <script>
    (function (){
      const hostId = "form";
      const iframeId = "bdf-iframe";
      const defaultHeight = 650;

      function getFrame(){
        const host = document.getElementById(hostId);
        if (!host) return null;
        const frame = host.querySelector("iframe");
        if (!frame) return null;
        return { host, frame };
      }

      function applyFrameBaseStyles(host, frame){
        frame.id = iframeId;
        frame.style.width = "100%";
        frame.style.display = "block";
        frame.style.border = "0";
        frame.style.overflow = "hidden";
        host.style.width = "100%";
      }

      function applyHeight(nextHeight){
        const obj = getFrame();
        if (!obj) return;
        const height = Math.max(80, Number(nextHeight) || 0);
        applyFrameBaseStyles(obj.host, obj.frame);
        obj.frame.style.height = height + "px";
        obj.frame.style.minHeight = height + "px";
        obj.host.style.height = height + "px";
        obj.host.style.minHeight = height + "px";
      }

      function readIncomingHeight(payload){
        if (!payload) return null;
        if (payload.type === "BDF_HEIGHT") {
          return Number(payload.height);
        }
        if (payload.bdf === "resize") {
          return Number(payload.height);
        }
        return null;
      }

      window.addEventListener("message", function(e){
        const incomingHeight = readIncomingHeight(e.data);
        if (!Number.isFinite(incomingHeight) || incomingHeight < 80) return;
        applyHeight(incomingHeight);
      });

      let tries = 0;
      const tryInit = setInterval(() => {
        tries += 1;
        const obj = getFrame();
        if (obj) {
          applyHeight(defaultHeight);
          clearInterval(tryInit);
        }
        if (tries > 40) {
          clearInterval(tryInit);
        }
      }, 250);
    })();
  </script>
  <style data-bdf-style>
    #bdf-root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e6eaf0;
      --danger: #e05a5a;
      --success: #16a34a;
      --warning: #f59e0b;
      --focus: rgba(37, 99, 235, 0.12);
      --form-row-gap: 12px;
      --form-field-gap: clamp(6px, 0.8vw, 8px);
      --form-vertical-padding: 0px;
      --form-control-pad-y: clamp(5px, 0.7vw, 7px);
      --form-control-pad-x: clamp(7px, 0.9vw, 10px);
      --form-input-pad-y: clamp(6px, 0.8vw, 8px);
      --form-input-pad-x: clamp(4px, 0.6vw, 6px);
      --form-input-min-height: 32px;
      --field-gap-internal: 3px;
      --field-gap-between: 4px;
      --field-group-gap: clamp(12px, 1.6vw, 16px);
      --amount-input-max-width: 268px;
      --field-control-height: 32px;
      --form-container-max-width: 464px;
      --row-height: 30px;
      --row-gap: 12px;
      --row-pad-x: 6px;
      --row-extended-gap: 4px;
      --row-extended-pad-y: 1.5px;
      --bdf-vh: 100dvh;
      --bdf-keyboard-inset: 0px;
      font-size: 16px;
      color: var(--text);
      min-height: var(--bdf-vh);
      max-height: var(--bdf-vh);
      overflow: hidden;
    }

    #bdf-root,
    #bdf-root * {
      box-sizing: border-box;
    }


    /* Firefox */
    #bdf-root * {
      scrollbar-width: thin;
      scrollbar-color: rgba(100,116,139,.55) transparent;
    }

    /* Chrome / Edge / Safari */
    #bdf-root *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #bdf-root *::-webkit-scrollbar-track {
      background: transparent;
    }
    #bdf-root *::-webkit-scrollbar-thumb {
      background-color: rgba(100,116,139,.45);
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: content-box;
    }
    #bdf-root *::-webkit-scrollbar-thumb:hover {
      background-color: rgba(100,116,139,.70);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }


#bdf-root.editing-mode {
      --form-container-max-width: 100%;
    }


    #bdf-root button,
    #bdf-root input,
    #bdf-root select,
    #bdf-root textarea {
      font: inherit;
      color: inherit;
    }
    #bdf-root .page {
      margin: 0;
      padding: 0;
      display: grid;
      gap: 20px;
    }

    #bdf-root .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }


    #bdf-root h1,
    #bdf-root h2,
    #bdf-root h3 {
      margin: 0 0 12px;
    }

    #bdf-root .grid {
      display: grid;
      gap: 16px;
    }

    #bdf-root .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    #bdf-root .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    #bdf-root label {
      font-size: 0.88rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #667085;
    }

    #bdf-root .required-hint {
      display: none !important;
    }

    #bdf-root .required-mark {
      font-size: 1.1rem;
      line-height: 1;
      color: #dc2626;
      font-weight: 800;
      margin-left: 2px;
      transform: translateY(1px);
    }

    #bdf-root .field-wrapper {
      display: grid;
      gap: 0;
      padding: 0;
      margin-bottom: 0;
    }

    #bdf-root .field-wrapper + .field-wrapper {
      margin-top: 0;
    }

    #bdf-root .field-wrapper.group-break-date {
      margin-top: 16px;
    }

    #bdf-root .field-row {
      display: flex;
      align-items: center;
      gap: var(--row-gap);
      height: var(--row-height);
      min-height: var(--row-height);
      padding: 0 var(--row-pad-x);
      border-bottom: none;
    }

    #bdf-root .field-row.is-file-field {
      flex-direction: column;
      gap: var(--row-extended-gap);
      align-items: stretch;
      height: auto;
      min-height: 0;
      padding: var(--row-extended-pad-y) 0;
    }

    #bdf-root .field-row.is-file-field .field-label {
      padding: 6px 8px;
      border: 1px solid #edf1f6;
      border-radius: 8px;
      background: #fff;
      flex: 1 1 auto;
      max-width: none;
    }

    #bdf-root .field-row.is-file-field .control-stack {
      justify-items: stretch;
    }

#bdf-root.editing-mode #formContainer {
      width: 100%;
      max-width: unset;
      height: auto;
      max-height: none;
      overflow: visible;
      padding-right: 0;
      margin-inline: 0;
    }

#bdf-root #formContainer {
      width: 100%;
      max-width: var(--form-container-max-width, 464px);
      height: min(680px, calc(var(--bdf-vh) - 24px));
      max-height: calc(var(--bdf-vh) - 24px);
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 0;
      margin-inline: auto;
    }

#bdf-root .field-control.file-field-control {
      min-height: 110px;
      display: grid;
      align-content: start;
      gap: 8px;
      cursor: pointer;
    }

#bdf-root .field-control.file-field-control .file-drop {
      min-height: 64px;
      display: grid;
      place-items: center;
      width: 100%;
    }

#bdf-root .field-control.file-field-control .field-input[type="file"] {
      display: none;
    }

    #bdf-root .field-label {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0;
      min-height: var(--field-control-height);
      margin: 0;
      padding: 0;
      flex: 0 0 clamp(170px, 28vw, 220px);
      max-width: clamp(170px, 28vw, 220px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 16px;
    }

    #bdf-root .label-top {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 8px;
      min-height: var(--field-control-height);
      margin: 0;
      padding: 0;
    }

    #bdf-root .label-text {
      font-weight: 600;
      font-size: 14px;
      color: #6b7280;
      line-height: 16px;
      letter-spacing: 0.1px;
      margin: 0;
      padding: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #bdf-root .label-meta {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 3px;
      min-height: 0;
    }

    #bdf-root .type-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      line-height: 1;
      border-radius: 0;
      background: transparent;
      border: none;
      color: #8a8a84;
      flex-shrink: 0;
      margin: 0;
      padding: 0;
    }

    #bdf-root .type-icon svg {
      width: 14px;
      height: 14px;
      display: block;
    }

#bdf-root .ai-badge {
      position: relative;
      top: 0;
      right: 0;
      width: 22px;
      height: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(255, 255, 255, 0.94);
      border-radius: 999px;
      padding: 0;
      cursor: pointer;
      color: #475569;
      z-index: 3;
    }

#bdf-root .ai-badge img {
      width: 12px;
      height: 12px;
      display: inline-block;
      object-fit: contain;
    }

#bdf-root .ai-badge.is-active {
      border-color: rgba(37, 99, 235, 0.35);
      background: rgba(239, 246, 255, 0.96);
      color: #1d4ed8;
    }

#bdf-root .ai-badge.is-passive {
      opacity: 0.95;
      filter: none;
    }

#bdf-root .ai-badge::after {
      content: none;
    }

#bdf-root .field-status-group {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      z-index: 4;
    }

#bdf-root .field-status-group .conflict-chip {
      margin: 0;
    }

#bdf-root .field-status-group .conflict-chip.is-spacer {
      visibility: hidden;
      pointer-events: none;
      opacity: 0;
    }

#bdf-root .field-status-group .conflict-popover {
      top: calc(100% + 6px);
      right: 0;
    }


#bdf-root .field-control.with-status-group .field-input:not(textarea),
#bdf-root .field-control.with-status-group select,
#bdf-root .field-control.with-status-group textarea.field-input {
      padding-right: 76px;
    }

#bdf-root .field-control.with-status-group.has-icon .field-input,
#bdf-root .field-control.with-status-group.has-icon .field-input.is-date-input {
      padding-right: 98px;
    }

#bdf-root .field-control.with-status-group select.field-input,
#bdf-root .field-control.with-status-group select {
      padding-right: 98px;
    }

#bdf-root .field-control.toggle.with-status-group .inline-row {
      padding-right: 78px;
    }

#bdf-root .field-control.toggle .field-status-group {
      right: 4px;
    }

#bdf-root .control-stack {
      display: grid;
      gap: 0;
      width: 100%;
      justify-items: start;
      align-items: center;
      min-height: var(--field-control-height);
      flex: 1 1 auto;
      min-width: 0;
    }

#bdf-root .field-row.is-amount-field .control-stack {
      max-width: min(100%, var(--amount-input-max-width));
    }

#bdf-root .field-control {
      border: 1px solid transparent;
      border-radius: 6px;
      padding: 0;
      background: transparent;
      position: relative;
      min-height: var(--field-control-height);
      display: flex;
      align-items: center;
      transition: border-color 0.14s ease, background-color 0.14s ease;
      box-shadow: none;
      box-sizing: border-box;
    }

#bdf-root .field-control::before {
      content: none;
    }

#bdf-root .field-control.ai-active {
      background: rgba(37, 99, 235, 0.03);
    }

#bdf-root .field-control.ai-active .field-input {
      background: transparent;
      padding-right: 36px;
    }

#bdf-root .ai-pill {
      position: absolute;
      top: 5px;
      right: 30px;
      font-size: 0.62rem;
      font-weight: 700;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.14);
      color: var(--primary);
      pointer-events: none;
    }

#bdf-root .field-control:hover {
      border-color: #e7e9ee;
      background: #fcfcfd;
    }

#bdf-root .field-control:focus-within {
      border-color: #cfd6e3;
      background: #ffffff;
      box-shadow: none;
    }

#bdf-root .field-control.invalid {
      border-color: rgba(224, 90, 90, 0.55);
      box-shadow: none;
    }
#bdf-root .field-control.toggle {
      border: none;
      background: transparent;
      min-height: auto;
      padding: 0;
      box-shadow: none;
    }

#bdf-root .field-control.toggle:hover,
#bdf-root .field-control.toggle:focus-within {
      border-color: transparent;
      background: transparent;
      box-shadow: none;
    }


#bdf-root .field-input:not(textarea),
#bdf-root select {
      width: 100%;
      border: none;
      height: var(--field-control-height);
      min-height: var(--field-control-height);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      background: transparent;
      color: #334155;
      outline: none;
      line-height: 20px;
      margin: 0;
      box-sizing: border-box;
    }

#bdf-root .field-input::placeholder,
#bdf-root textarea::placeholder {
      color: #9ca3af;
      opacity: 0.9;
    }

#bdf-root .field-input.is-date-input::placeholder {
      color: #b4bbc8;
    }

#bdf-root .field-control.has-icon .field-input {
      padding-right: 34px;
    }

#bdf-root .field-control.has-icon .field-input.is-date-input {
      padding-right: 36px;
    }

#bdf-root textarea.field-input {
      width: 100%;
      border: none;
      height: auto;
      resize: vertical;
      min-height: 72px;
      padding: 8px 10px;
      line-height: 1.45;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      background: transparent;
      color: #334155;
      outline: none;
      margin: 0;
      box-sizing: border-box;
    }

#bdf-root .field-row.is-multiline-field {
      align-items: flex-start;
      height: auto;
      min-height: 0;
      padding-top: var(--row-extended-pad-y);
      padding-bottom: var(--row-extended-pad-y);
    }

#bdf-root .field-row.is-multiline-field .field-label {
      justify-content: flex-start;
      padding-top: 7px;
      white-space: normal;
    }

#bdf-root .field-row.is-multiline-field .label-top {
      min-height: 0;
      align-items: flex-start;
    }

#bdf-root .field-row.is-multiline-field .control-stack {
      align-items: stretch;
      min-height: 64px;
    }

#bdf-root .field-icon-button {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      border: 1px solid #e5e7eb;
      background: #f8fafc;
      width: 30px;
      height: 30px;
      border-radius: 8px;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #475569;
    }

#bdf-root .field-icon-button:hover {
      border-color: #d1d5db;
      background: #f3f4f6;
    }

#bdf-root .picker-popover {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      width: 270px;
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
      padding: 12px;
      display: none;
      pointer-events: none;
      z-index: 30;
    }

#bdf-root .picker-popover.open {
      display: grid;
      pointer-events: auto;
      gap: 10px;
    }

#bdf-root .picker-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      color: #334155;
    }

#bdf-root .picker-nav {
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      border-radius: 8px;
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: 600;
      color: #475569;
    }

#bdf-root .picker-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      text-align: center;
      font-size: 0.72rem;
    }

#bdf-root .picker-weekday {
      color: #94a3b8;
      font-weight: 600;
      padding: 4px 0;
    }

#bdf-root .picker-day {
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 6px 0;
      cursor: pointer;
      color: #334155;
      background: transparent;
    }

#bdf-root .picker-day.is-today {
      border-color: rgba(37, 99, 235, 0.4);
      color: #1d4ed8;
    }

#bdf-root .picker-day.is-selected {
      background: rgba(37, 99, 235, 0.12);
      border-color: rgba(37, 99, 235, 0.3);
      color: #1d4ed8;
      font-weight: 700;
    }

#bdf-root .picker-time {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

#bdf-root .picker-actions {
      display: flex;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
    }

#bdf-root .picker-actions button {
      padding: 6px 10px;
      font-size: 0.72rem;
    }

#bdf-root .field-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

#bdf-root .helper-text {
      font-size: 0.75rem;
      color: var(--muted);
    }

#bdf-root .error-text {
      font-size: 0.75rem;
      color: var(--danger);
      min-height: 0;
    }

#bdf-root .inline-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      min-width: 0;
    }
#bdf-root .inline-row > span {
      min-width: 0;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: inline-block;
    }

#bdf-root .inline-row input[type="checkbox"] {
      width: 15px;
      height: 15px;
      margin: 0;
      accent-color: #2563eb;
      flex: 0 0 auto;
    }


#bdf-root button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
    }

#bdf-root button.secondary {
      background: #e5e7eb;
      color: var(--text);
    }

#bdf-root button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

#bdf-root button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

#bdf-root .console {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.82rem;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
    }

#bdf-root .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
    }

#bdf-root .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

#bdf-root .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      font-size: 0.88rem;
      font-weight: 600;
    }

#bdf-root .chip button {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.82rem;
      background: rgba(37, 99, 235, 0.2);
    }

#bdf-root .field-control.multiselect-control {
      display: grid;
      align-items: start;
      gap: 8px;
      padding: 8px 10px;
    }

#bdf-root .multiselect-options {
      display: grid;
      gap: 6px;
      width: 100%;
    }

#bdf-root .multiselect-option {
      display: inline-flex;
      align-items: flex-start;
      gap: 8px;
      width: 100%;
      color: #4b5563;
      font-size: 14px;
      line-height: 1.25;
    }

#bdf-root .multiselect-option > span {
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      max-width: none;
    }

#bdf-root .file-drop {
      border: 1px dashed #cfd8e3;
      border-radius: 12px;
      padding: 14px;
      text-align: center;
      color: #566173;
      background: linear-gradient(180deg, #fbfdff 0%, #f7fafe 100%);
    }

#bdf-root .file-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

#bdf-root .file-grid {
      display: grid;
      gap: 8px;
      margin-top: 10px;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    }

#bdf-root .file-item {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
    }

#bdf-root .file-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
      background: #fff;
      position: relative;
      overflow: hidden;
    }

#bdf-root .file-meta {
      display: grid;
      gap: 4px;
      font-size: 0.82rem;
    }

#bdf-root .file-thumb {
      width: 52px;
      height: 52px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid var(--border);
      background: #f3f4f6;
    }

#bdf-root .file-thumb.large {
      width: 100%;
      height: 90px;
    }

#bdf-root .file-thumb-wrap {
      position: relative;
      display: inline-block;
    }

#bdf-root .file-thumb-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.2s ease;
      border-radius: 8px;
    }

#bdf-root .file-thumb-wrap:hover .file-thumb-overlay {
      opacity: 1;
    }

#bdf-root .preview-btn {
      border: none;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.7rem;
      cursor: pointer;
    }

#bdf-root .conflict-inline-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: flex-end;
      width: 100%;
      margin-top: 2px;
    }

#bdf-root .conflict-chip {
      background: #FEF2F2;
      color: #DC2626;
      border-radius: 999px;
      padding: 2px 6px;
      width: 24px;
      height: 24px;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      opacity: 0.8;
      cursor: pointer;
      line-height: 1.2;
    }

#bdf-root .conflict-chip:hover {
      opacity: 1;
    }

#bdf-root .conflict-popover {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      margin-top: 0;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-width: 220px;
      max-width: 320px;
      width: max-content;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.16);
      display: none;
      z-index: 40;
    }

#bdf-root .conflict-popover.open {
      display: grid;
      gap: 6px;
    }

#bdf-root .conflict-popover pre {
      margin: 0;
      padding: 6px 8px;
      background: #f8fafc;
      border-radius: 8px;
      font-size: 0.72rem;
      max-height: 120px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

#bdf-root .conflict-popover small {
      color: var(--muted);
      font-weight: 600;
    }

#bdf-root .conflict-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

#bdf-root .conflict-actions button {
      padding: 6px 10px;
      font-size: 0.72rem;
    }

#bdf-root .date-wrapper {
      position: relative;
      display: grid;
      gap: 6px;
    }

#bdf-root .date-overlay-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

#bdf-root .file-icon {
      font-size: 22px;
      width: 44px;
      text-align: center;
    }

#bdf-root .file-remove {
      border: none;
      background: transparent;
      color: var(--danger);
      font-weight: 700;
      cursor: pointer;
    }

#bdf-root .toggle {
      display: inline-flex;
      align-items: center;
      gap: 0;
      cursor: pointer;
    }

#bdf-root .toggle input {
      width: 15px;
      height: 15px;
      margin: 0;
      accent-color: #2563eb;
    }


#bdf-root .action-bar {
      position: sticky;
      top: 0;
      z-index: 25;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      min-height: 58px;
      height: 58px;
      padding: 8px 10px;
      border: 1px solid #e4e8ee;
      border-radius: 12px;
      background: #f8fafc;
      box-shadow: 0 4px 14px rgba(15, 23, 42, 0.06);
      margin-bottom: 12px;
    }

#bdf-root #formContainer {
      position: relative;
      padding-bottom: var(--bdf-keyboard-inset);
    }

#bdf-root .form-refresh-loading {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(2px);
      z-index: 999;
      padding: 16px;
      text-align: center;
    }

#bdf-root .form-refresh-loading.open {
      display: flex;
    }

#bdf-root .form-refresh-loading p {
      margin: 0;
      color: #334155;
      font-size: 13px;
      font-weight: 600;
    }

#bdf-root .action-main {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
      flex: 1;
      min-width: 0;
      flex-wrap: nowrap;
      overflow-x: hidden;
    }

#bdf-root .more-actions {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

#bdf-root .more-actions > .ghost {
      min-width: 40px;
      padding: 10px 12px;
      font-size: 20px;
      line-height: 1;
    }

#bdf-root .more-actions .action-menu {
      right: 0;
      left: auto;
      min-width: 170px;
    }

#bdf-root .action-main > #actionSplit {
      order: 1;
    }

#bdf-root .action-main > #toggleInlineEdit {
      order: 2;
      margin-left: auto;
    }

#bdf-root .action-main > #moreActions {
      order: 3;
    }

#bdf-root .action-split {
      position: relative;
      display: inline-flex;
      align-items: stretch;
      border-radius: 10px;
      overflow: visible;
      border: 1px solid #cbd5e1;
      background: #fff;
      box-shadow: 0 1px 1px rgba(15,23,42,0.04);
    }

#bdf-root .action-split button {
      border-radius: 0;
      border: none;
    }

#bdf-root .action-trigger-btn {
      background: #ffffff;
      color: #0f172a;
      min-width: 0;
      width: clamp(120px, 34vw, 220px);
      max-width: 100%;
      text-align: left;
      font-weight: 600;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

#bdf-root .action-chevron-btn {
      background: #eff6ff;
      color: #1e3a8a;
      min-width: 40px;
      padding: 8px 10px;
      border-left: 1px solid #cbd5e1;
    }

#bdf-root .action-split button:hover {
      background: #f1f5f9;
    }

#bdf-root .action-split button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(59,130,246,0.2);
      position: relative;
      z-index: 1;
    }

#bdf-root .action-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      min-width: 180px;
      max-width: min(92vw, 360px);
      max-height: 240px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.14);
      display: none;
      padding: 4px;
      pointer-events: none;
      z-index: 260;
    }

#bdf-root .action-menu.open {
      display: grid;
      pointer-events: auto;
      gap: 2px;
    }

#bdf-root .action-menu-item {
      width: 100%;
      text-align: left;
      background: transparent;
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 0.82rem;
    }

#bdf-root .action-menu-item:hover {
      background: #f1f5f9;
    }

#bdf-root .predicted-action-btn {
      background: rgba(37, 99, 235, 0.08);
      color: #1d4ed8;
      border: 1px dashed rgba(37, 99, 235, 0.25);
      font-size: 0.78rem;
      padding: 7px 10px;
    }

#bdf-root .predicted-action-btn:disabled {
      opacity: 0.55;
    }

#bdf-root .action-empty-msg {
      color: var(--warning);
      font-size: 0.78rem;
      font-weight: 600;
}

#bdf-root .edit-mode-root {
  display: none;
  gap: 12px;
  width: 100%;
  max-width: unset;
  flex: 1 1 auto;
}

#bdf-root .edit-mode-toolbar {
  display: grid;
  gap: 8px;
  position: sticky;
  top: 0;
  z-index: 6;
  background: #fff;
  padding-bottom: 6px;
}

#bdf-root .edit-stage-select-wrap {
  display: none;
}

#bdf-root .edit-stage-select {
  width: 100%;
  min-height: 38px;
  border: 1px solid #d7deeb;
  border-radius: 10px;
  background: #fff;
  color: #0f172a;
  font-weight: 600;
  padding: 8px 10px;
}

#bdf-root .edit-search-input-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0;
}

#bdf-root .field-search-icon {
  width: 14px;
  height: 14px;
  color: #64748B;
  flex: 0 0 auto;
}

#bdf-root .field-search-icon svg {
  display: block;
  width: 14px;
  height: 14px;
}

#bdf-root .edit-search-input-shell {
  position: relative;
  width: clamp(200px, 24vw, 280px);
  min-width: 180px;
}

#bdf-root .field-search-input {
  width: 100%;
  height: 36px;
  min-height: 36px;
  background: #FFFFFF;
  border: 1px solid #CBD5E1;
  border-radius: 12px;
  padding-left: 10px;
  padding-right: 34px;
  font-size: 13px;
  font-weight: 500;
  color: #0B1220;
  box-shadow: none;
}

#bdf-root .field-search-input::placeholder {
  color: #94A3B8;
  opacity: 1;
}

#bdf-root .edit-search-input-wrap:hover .field-search-input:not(:focus) {
  border-color: #94A3B8;
  background: #FFFFFF;
}

#bdf-root .field-search-input:focus {
  outline: none;
  border-color: #93C5FD;
  box-shadow: 0 0 0 3px #DBEAFE;
  background: #FFFFFF;
}

#bdf-root .edit-search-clear {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  border: 0;
  background: transparent;
  color: #64748b;
  font-size: 16px;
  line-height: 1;
  padding: 4px;
  border-radius: 6px;
  display: none;
}

#bdf-root .edit-search-clear:hover {
  background: #eef2ff;
  color: #1d4ed8;
}

#bdf-root .edit-search-empty {
  display: none;
  padding: 8px 10px;
  border: 1px dashed #f1b5b5;
  background: #fff7f7;
  color: #b42318;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
}

#bdf-root .edit-stage-layout {
  display: grid;
  grid-template-columns: minmax(150px, 200px) minmax(0, 1fr);
  gap: 10px;
  align-items: start;
}

#bdf-root .edit-stage-tabs {
  display: grid;
  gap: 6px;
}

#bdf-root .edit-stage-tab {
  text-align: left;
  border: 1px solid #d7deeb;
  background: #fff;
  border-radius: 10px;
  padding: 9px 10px;
  color: #334155;
  font-size: 14px;
  line-height: 1.35;
  font-weight: 600;
  min-height: 40px;
}

#bdf-root .edit-stage-tab.active {
  background: rgba(37, 99, 235, 0.1);
  border-color: rgba(37, 99, 235, 0.35);
  color: #1d4ed8;
  font-weight: 600;
}

#bdf-root .edit-stage-tab.completed {
  border-color: #93c5fd;
  color: #1e40af;
}

#bdf-root .edit-stage-tab.upcoming {
  opacity: 0.9;
  color: #475569;
}

#bdf-root .edit-stage-panel {
  border: 1px solid #e6ebf5;
  border-radius: 12px;
  padding: 10px;
  min-height: 320px;
  background: #fff;
}

#bdf-root .edit-stage-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#bdf-root .edit-stage-chip {
  font-size: 11px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid #dbe3f2;
  color: #64748b;
  background: #f8fafc;
}

#bdf-root .edit-stage-chip.completed {
  color: #1e40af;
  border-color: #93c5fd;
  background: #eff6ff;
}

#bdf-root .edit-stage-chip.active {
  color: #1d4ed8;
  border-color: rgba(37, 99, 235, 0.35);
  background: rgba(37, 99, 235, 0.08);
}

#bdf-root .edit-stage-chip.upcoming {
  opacity: 0.7;
}

#bdf-root .edit-stage-status {
  font-size: 12px;
  color: #64748b;
  margin-bottom: 6px;
  min-height: 18px;
}

#bdf-root .field-wrapper.search-result {
  border-left: 2px solid #93c5fd;
  padding-left: 10px;
}

#bdf-root mark.edit-search-highlight {
  background: rgba(250, 204, 21, 0.28);
  border-radius: 4px;
  padding: 0 2px;
}

#bdf-root .edit-stage-fields.search-transition {
  animation: bdf-search-shift 160ms ease;
}

#bdf-root #dynamicForm.search-transition {
  animation: bdf-search-shift 160ms ease;
}

#bdf-root .edit-mode-root.search-only .edit-stage-select-wrap,
#bdf-root .edit-mode-root.search-only #editModeLoading,
#bdf-root .edit-mode-root.search-only #editStageLayout {
  display: none !important;
}

#bdf-root .edit-mode-root.search-only {
  margin-bottom: 8px;
}

@keyframes bdf-search-shift {
  from { opacity: 0.0; transform: translateY(3px); }
  to { opacity: 1; transform: translateY(0); }
}
#bdf-root .edit-stage-fields-skeleton {
  display: grid;
  gap: 8px;
  margin-top: 4px;
}

#bdf-root .edit-stage-fields-skeleton .line {
  height: 34px;
  border-radius: 9px;
  background: linear-gradient(90deg, #eef3fb 0%, #e5edf9 50%, #eef3fb 100%);
  background-size: 220% 100%;
  animation: bdf-loading 1.2s ease-in-out infinite;
}

#bdf-root .edit-mode-loading {
  display: none;
  width: 100%;
  min-height: 220px;
  border: 1px solid #e2e8f3;
  border-radius: 12px;
  background: #fafcff;
  padding: 14px;
  gap: 12px;
  align-content: start;
}

#bdf-root .edit-mode-spinner {
  width: 18px;
  height: 18px;
  border: 2px solid #d9e2f0;
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: bdf-spin 0.8s linear infinite;
}

#bdf-root .edit-skeleton-row {
  height: 14px;
  border-radius: 999px;
  background: linear-gradient(90deg, #eef3fb 0%, #e5edf9 50%, #eef3fb 100%);
  background-size: 220% 100%;
  animation: bdf-loading 1.2s ease-in-out infinite;
}

#bdf-root .edit-skeleton-row.head { width: 40%; height: 18px; }
#bdf-root .edit-skeleton-row.wide { width: 100%; }
#bdf-root .edit-skeleton-row.mid { width: 72%; }

@keyframes bdf-loading {
  0% { background-position: 200% 0; }
  100% { background-position: -20% 0; }
}

@keyframes bdf-spin {
  to { transform: rotate(360deg); }
}
#bdf-root .summary-box {
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
    }

#bdf-root .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 999;
    }

#bdf-root .lightbox.open {
      display: flex;
    }

#bdf-root .lightbox-content {
      max-width: min(720px, 90vw);
      max-height: 80vh;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

#bdf-root .lightbox-content img {
      width: 100%;
      height: auto;
      border-radius: 12px;
    }

#bdf-root .lightbox-close {
      justify-self: end;
      background: #111827;
      color: #fff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
    }

#bdf-root .debug-toolbar {
      position: sticky;
      top: 12px;
      z-index: 10;
      display: grid;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
    }

#bdf-root .toolbar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

#bdf-root .toolbar-actions button {
      padding: 8px 12px;
      font-size: 0.78rem;
    }

#bdf-root .toolbar-status {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 600;
    }

#bdf-root .debug-warning {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #f8fafc;
      margin-bottom: 16px;
    }

#bdf-root .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

#bdf-root .export-modal.open {
      display: flex;
    }

#bdf-root .export-panel {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      width: min(920px, 95vw);
      max-height: 85vh;
      display: grid;
      gap: 12px;
    }

#bdf-root .export-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

#bdf-root .export-tabs button {
      padding: 6px 10px;
      font-size: 0.75rem;
    }

#bdf-root .export-tabs button.active {
      background: var(--primary);
      color: #fff;
    }

#bdf-root .export-panel textarea {
      width: 100%;
      min-height: 240px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
    }

#bdf-root .input-error {
      color: var(--danger);
      font-size: 0.75rem;
      font-weight: 600;
      min-height: 16px;
    }

    @media (max-width: 900px) {
#bdf-root {
        --form-row-gap: 10px;
        --form-field-gap: 6px;
        --form-vertical-padding: 0px;
        --field-gap-between: 4px;
      }

#bdf-root .field-row {
        gap: 12px;
      }

#bdf-root .field-input,
#bdf-root select,
#bdf-root textarea {
        font-size: 16px;
      }

#bdf-root .field-label {
        flex-basis: clamp(150px, 34vw, 190px);
        max-width: clamp(150px, 34vw, 190px);
      }

#bdf-root .field-row.is-file-field .field-label {
        padding: 7px 9px;
      }

#bdf-root #formContainer {
        height: calc(var(--bdf-vh) - 12px);
        max-height: calc(var(--bdf-vh) - 12px);
        overflow-y: auto;
        overflow-x: hidden;
        padding-right: 0;
        -webkit-overflow-scrolling: touch;
      }

#bdf-root .action-bar {
        align-items: center;
        height: 54px;
        min-height: 54px;
        padding: 6px 8px;
      }

#bdf-root .action-main {
        flex-wrap: nowrap;
        justify-content: flex-start;
        gap: 4px;
        overflow-x: hidden;
      }

#bdf-root .action-trigger-btn {
        min-width: 0;
        width: clamp(108px, 42vw, 180px);
        max-width: 100%;
      }

#bdf-root .field-row.is-amount-field .control-stack {
        max-width: min(100%, 248px);
      }

#bdf-root .edit-stage-layout {
        grid-template-columns: 1fr;
      }

#bdf-root .edit-stage-select-wrap {
        display: block;
      }

#bdf-root .edit-stage-tabs {
        display: none;
      }

    }

    @media (max-width: 450px) {
#bdf-root {
        font-size: 13px;
      }

#bdf-root .page {
        gap: 0;
      }

#bdf-root .card {
        border-radius: 0;
        padding: 0;
        border: 0;
        box-shadow: none;
      }

#bdf-root #formContainer {
        max-width: none;
        margin-inline: auto;
        padding: 0;
        height: calc(var(--bdf-vh) - 10px);
        max-height: calc(var(--bdf-vh) - 10px);
        overflow-y: auto;
        overflow-x: hidden;
      }

#bdf-root .edit-mode-root,
#bdf-root .edit-stage-panel,
#bdf-root .field-row {
        font-size: 12px;
      }

#bdf-root .field-row {
        padding-left: 0;
        padding-right: 0;
        min-height: 26px;
      }

#bdf-root .label-text {
        font-size: 12.5px;
        line-height: 15px;
        letter-spacing: 0.08px;
      }

#bdf-root .field-input:not(textarea),
#bdf-root textarea.field-input,
#bdf-root select,
#bdf-root .multiselect-option,
#bdf-root .chip {
        font-size: 12.5px;
      }

#bdf-root .field-label {
        flex-basis: clamp(116px, 36vw, 144px);
        max-width: clamp(116px, 36vw, 144px);
      }

#bdf-root .edit-stage-panel {
        border: 0;
        border-radius: 0;
        padding: 0;
      }

#bdf-root .action-bar {
        border: 0;
        border-radius: 0;
        padding: 0;
        margin-bottom: 8px;
        box-shadow: none;
      }
    }

    @media (max-width: 360px) {
#bdf-root .edit-stage-layout {
        grid-template-columns: 1fr;
      }

#bdf-root .edit-stage-tabs {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

#bdf-root .field-row {
        flex-direction: column;
        align-items: stretch;
        gap: 4px;
      }

#bdf-root .field-label {
        max-width: none;
      }
    }
  </style>
  <script>
    (() => {
      const styleEl = document.currentScript?.previousElementSibling;
      const init = () => {
        const root = document.getElementById("bdf-root");
        if (!root) return;
        const hasMultipleRoots = document.querySelectorAll("#bdf-root").length > 1;
        if (!hasMultipleRoots) return;
        const uniqueId = `bdf-root-${Math.random().toString(36).slice(2, 9)}`;
        root.id = uniqueId;
        if (styleEl && styleEl.tagName === "STYLE") {
          styleEl.textContent = styleEl.textContent.replace(/#bdf-root/g, `#${uniqueId}`);
        }
      };
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</head>
<body>
  <div id="bdf-root" data-bdf-root>
    <main class="page">
    <div id="debugPanels">
      <section class="card" id="jsonInputsSection">
      <h2>Bubble JSON Girişleri</h2>
      <p class="helper-text">
        Bubble’dan gelen JSON verilerini buraya yapıştırın. Hatalı JSON girildiğinde ilgili alan kırmızı uyarı verir.
      </p>
      <div class="grid three">
        <div>
          <label for="columnJsonInput">Column JSON</label>
          <textarea id="columnJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="columnJsonError"></div>
        </div>
        <div>
          <label for="humanJsonInput">Bubble Data JSON</label>
          <textarea id="humanJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="humanJsonError"></div>
        </div>
        <div>
          <label for="predictedJsonInput">Predicted JSON</label>
          <textarea id="predictedJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="predictedJsonError"></div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <input id="versionInput" type="checkbox" />
        <label for="versionInput">version (true ise sadece form görünsün)</label>
      </div>
      </section>

      <section class="card">
      <h1>Bubble Dynamic Form Element</h1>
      <p class="helper-text">
        Bu demo tek HTML dosyasında çalışır. Bubble elementine alan şemasını JSON olarak girip “Render Et” diyebilirsiniz.
      </p>
      <div class="grid two">
        <div>
          <label for="schemaInput">Schema (fields + config)</label>
          <textarea id="schemaInput" class="field-input" rows="12"></textarea>
        </div>
        <div class="grid">
          <div>
            <label for="currentDateTime">currentDateTimeISO</label>
            <input id="currentDateTime" class="field-input" type="text" />
          </div>
          <div class="grid two">
            <div>
              <label for="localeInput">locale</label>
              <input id="localeInput" class="field-input" type="text" value="tr-TR" />
            </div>
            <div>
              <label for="timezoneInput">timezone</label>
              <input id="timezoneInput" class="field-input" type="text" value="Europe/Istanbul" />
            </div>
          </div>
          <div class="grid two">
            <div>
              <label for="modeInput">mode</label>
              <select id="modeInput" class="field-input">
                <option value="create">create</option>
                <option value="edit">edit</option>
              </select>
            </div>
            <div>
              <label for="requiredPolicyInput">requiredPolicy</label>
              <select id="requiredPolicyInput" class="field-input">
                <option value="strict">strict</option>
                <option value="soft">soft</option>
              </select>
            </div>
          </div>
          <div class="grid two">
            <div class="inline-row">
              <input id="showInlineHelp" type="checkbox" checked />
              <label for="showInlineHelp">showInlineHelp</label>
            </div>
            <div class="inline-row">
              <input id="autoFocusInvalid" type="checkbox" checked />
              <label for="autoFocusInvalid">autoFocusFirstInvalid</label>
            </div>
          </div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="loadSample">Schema Yükle</button>
        <button class="secondary" id="renderForm">Render Et</button>
        <button class="ghost" id="clearConsole">Console Temizle</button>
      </div>
      </section>

      <section class="card" id="eventConsoleSection">
        <h2>Event Console</h2>
        <div id="eventConsole" class="console"></div>
      </section>

      <section class="card" id="submitOutputsSection">
        <h2>Submit Outputs</h2>
        <div id="submitOutputs" class="console"></div>
      </section>

      <section class="card">
        <h2>Dynamic Form</h2>
        <div class="debug-toolbar" id="debugToolbar">
        <div class="toolbar-actions">
          <button type="button" id="loadColumnJson">Column Yükle</button>
          <button type="button" class="secondary" id="loadHumanJson">Human JSON Yükle</button>
          <button type="button" class="secondary" id="loadPredictedJson">Predicted JSON Yükle</button>
          <button type="button" class="ghost" id="applyAiToEmpty">AI -> Boş Human Alanlara Uygula</button>
          <button type="button" class="ghost" id="overwriteAiToAll">AI -> Hepsini Overwrite</button>
          <button type="button" class="ghost" id="resetStores">Reset</button>
          <button type="button" class="secondary" id="exportJson">Export JSON</button>
          <button type="button" class="ghost" id="scenarioColumnOnly">Scenario: Column</button>
          <button type="button" class="ghost" id="scenarioColumnHuman">Scenario: Column+Human</button>
          <button type="button" class="ghost" id="scenarioColumnAi">Scenario: Column+AI</button>
          <button type="button" class="ghost" id="scenarioColumnAiHuman">Scenario: Column+AI+Human</button>
          <button type="button" class="ghost" id="scenarioConflict">Scenario: Conflict</button>
        </div>
        <div class="toolbar-status">
          <span id="aiFieldCount">AI alan sayısı: 0</span>
          <span id="humanFieldCount">Human değiştirilen alan sayısı: 0</span>
        </div>
        </div>
        <div id="columnWarning" class="debug-warning" style="display:none;">
          Column JSON yüklenmedi. Debug toolbar üzerinden yükleyin.
        </div>
      </section>
    </div>

    <section class="card">
      <div id="formContainer">
        <div id="formRefreshLoading" class="form-refresh-loading" aria-live="polite" aria-hidden="true">
          <span class="edit-mode-spinner" aria-hidden="true"></span>
          <p>İşlem kaydediliyor, güncel veriler bekleniyor…</p>
        </div>
        <div id="actionBar" class="action-bar">
          <div class="action-main">
            <div class="action-split" id="actionSplit">
              <button id="actionTriggerBtn" type="button" class="action-trigger-btn">Aksiyon seç</button>
              <button id="actionChevronBtn" type="button" class="action-chevron-btn" aria-label="Aksiyon menüsü">▾</button>
              <div id="actionMenu" class="action-menu"></div>
            </div>
            <button id="toggleInlineEdit" type="button" class="ghost" style="display:none;">Show more</button>
            <div class="more-actions" id="moreActions" style="display:none;">
              <button id="moreActionsBtn" type="button" class="ghost" aria-label="Diğer işlemler">⋯</button>
              <div id="moreActionsMenu" class="action-menu">
                <button id="addFieldBtn" type="button" class="action-menu-item">Add field</button>
                <button id="manageFieldsBtn" type="button" class="action-menu-item">Manage fields</button>
              </div>
            </div>
            <button id="predictedActionBtn" type="button" class="predicted-action-btn" style="display:none;"></button>
            <span id="actionEmptyMsg" class="action-empty-msg" style="display:none;">Aksiyon yok. Kullanıcıya lütfen sürece bir buton ekleyin uyarısı verilir.</span>
          </div>
        </div>
        <div id="summaryBox" class="summary-box" style="display:none;"></div>
        <div id="editModeRoot" class="edit-mode-root">
          <div class="edit-mode-toolbar">
            <div class="edit-stage-select-wrap">
              <select id="editStageSelect" class="edit-stage-select" aria-label="Aşama seç"></select>
            </div>
            <div class="edit-search-input-wrap">
              <span class="field-search-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="7"></circle><path d="M20 20l-3.5-3.5"></path></svg></span>
              <div class="edit-search-input-shell">
                <input id="editSearchInput" class="field-input field-search-input" type="text" placeholder="Alan ara" />
                <button id="editSearchClear" class="edit-search-clear" type="button" aria-label="Aramayı temizle">×</button>
              </div>
            </div>
          </div>
          <div id="editSearchEmpty" class="edit-search-empty"></div>
          <div id="editModeLoading" class="edit-mode-loading">
            <span class="edit-mode-spinner" aria-hidden="true"></span>
            <span id="editModeLoadingText">Yükleniyor</span>
            <div class="edit-skeleton-row head"></div>
            <div class="edit-skeleton-row wide"></div>
            <div class="edit-skeleton-row mid"></div>
            <div class="edit-skeleton-row wide"></div>
          </div>
          <div id="editStageLayout" class="edit-stage-layout" style="display:none;">
            <div id="editStageTabs" class="edit-stage-tabs"></div>
            <div id="editStagePanel" class="edit-stage-panel">
              <h3 id="editStageHeading" style="margin:0 0 6px 0; font-size:14px;"></h3>
              <div id="editStageMeta" class="edit-stage-meta"><span></span><span id="editStageChip" class="edit-stage-chip"></span></div>
              <div id="editStageStatus" class="edit-stage-status"></div>
              <div id="editStageFields" class="grid" style="gap:8px;"></div>
            </div>
          </div>
        </div>
        <form id="dynamicForm" class="grid"></form>
        <div class="inline-row" id="formActions" style="margin-top: 12px;">
          <button id="submitBtn" type="submit">Submit</button>
          <button id="clearBtn" type="button" class="ghost">Temizle</button>
        </div>
      </div>
    </section>
    </main>
  <div id="lightbox" class="lightbox" aria-hidden="true">
    <div class="lightbox-content">
      <button type="button" class="lightbox-close">Kapat</button>
      <img id="lightboxImage" alt="Önizleme" />
    </div>
  </div>
  <div id="exportModal" class="export-modal" aria-hidden="true">
    <div class="export-panel">
      <div class="inline-row" style="justify-content: space-between;">
        <strong>JSON Export</strong>
        <button type="button" class="ghost" id="closeExport">Kapat</button>
      </div>
      <div class="export-tabs">
        <button type="button" class="secondary active" data-export-tab="export">Aktif JSON</button>
        <button type="button" class="secondary" data-export-tab="human">Human JSON</button>
        <button type="button" class="secondary" data-export-tab="ai">Predicted JSON</button>
        <button type="button" class="secondary" data-export-tab="column">Column JSON</button>
      </div>
      <textarea id="exportContent" readonly></textarea>
    </div>
  </div>
  </div>

  <script>
    (function () {
      const BDF = (window.__BDF__ = window.__BDF__ || {});
      const IS_VERSION_MODE = Boolean(window.BUBBLE_INPUTS?.VERSION);
      const IS_DEBUG_MODE = Boolean(window.BUBBLE_INPUTS?.DEBUG_MODE);
      BDF.DEBUG_MODE = IS_DEBUG_MODE && !IS_VERSION_MODE;

      const INITIAL_INPUTS = window.BUBBLE_INPUTS || {};
      const IS_EDITING_MODE = INITIAL_INPUTS?.editing === true || INITIAL_INPUTS?.editing === 1 || String(INITIAL_INPUTS?.editing || "").trim().toLowerCase() === "true";

    let MANUAL_COLUMN_JSON = INITIAL_INPUTS.COLUMN_JSON || null;
    let MANUAL_DATA_JSON = INITIAL_INPUTS.BUBBLE_DATA_JSON || null;
    let MANUAL_PREDICTED_JSON = INITIAL_INPUTS.PREDICTED_JSON || null;

    const SAMPLE_COLUMN_JSON = {
      columns: [
        {
          fieldName: "Davacı Ad Soyad",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Davacı TCKN/VKN",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Kaza Tarihi",
          type: "date",
          required: true,
          stageType: "mandatory",
          default: "$TODAY"
        },
        {
          fieldName: "İhtar Tarihi",
          type: "date",
          required: false,
          stageType: "optional"
        },
        {
          fieldName: "Randevu Datetime",
          type: "datetime",
          stageType: "control"
        },
        {
          fieldName: "Uygun Saat",
          type: "time",
          stageType: "optional"
        },
        {
          fieldName: "Aracın Tipi",
          type: "dropdown",
          stageType: "mandatory",
          options: [
            { value: "Hususi", label: "Hususi" },
            { value: "Ticari", label: "Ticari" },
            { value: "Kiralık", label: "Kiralık" }
          ]
        },
        {
          fieldName: "Ek Özellikler",
          type: "dropdown",
          stageType: "optional",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri görüş kamera" }
          ]
        },
        {
          fieldName: "Hasar Onarım Tutarı",
          type: "currency",
          stageType: "mandatory"
        },
        {
          fieldName: "Kusur Oranı",
          type: "percent",
          stageType: "mandatory"
        },
        {
          fieldName: "Aracın Kilometresi",
          type: "number",
          stageType: "optional"
        },
        {
          fieldName: "Belgeleri Yükle",
          type: "file",
          allowMultiple: false,
          stageType: "control"
        },
        {
          fieldName: "Hasar Fotoğrafları",
          type: "image",
          allowMultiple: true,
          stageType: "optional"
        },
        {
          fieldName: "Ek Dosyalar",
          type: "multifile",
          allowMultiple: true,
          stageType: "optional"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create"
    };

    const SAMPLE_DATA_JSON = {
      "Belgeleri Yükle": "https://gaiasphere.io/version-live/fileupload/f1770577885537x578585456537153500/hasar_ekspertiz_raporu.pdf",
      "Davacı Kimlik Tipi": "TC Kimlik",
      "Davacı Ad Soyad": "İSMAİL DİNCER",
      "Davacı TCKN/VKN": "12928963404",
      "Davacı Plaka": "19BA618",
      "Davacı Marka Model": "TOYOTA COROLLA 1,6 TERRA SEDAN (Y) 2006",
      "Davacı Şase No": "NMTBZ28E90R141719",
      "Karşı Ad Soyad": "YILMAZ HIŞIR",
      "Karşı TCKN/VKN": "31066362344",
      "Karşı Plaka": "19ABA563",
      "Kaza Tarihi": "2024-11-15",
      "Aracın Markası": "TOYOTA",
      "Aracın Tipi": "Hususi",
      "Aracın Model Yılı": "2006",
      "Kaza Yeri": "Çorum / Merkez / Öğretmen Lisesi 1. Cad. – Öğretmen Lisesi Cad. kavşağı",
      "Davacı Araç Sürücüsü": "İSMAİL DİNCER",
      "Karşı Araç Sürücüsü": "YILMAZ HIŞIR",
      "Karşı Poliçe Türü": "Zorunlu Trafik Sigortası",
      "Karşı Poliçe No": "104781355",
      "Karşı Poliçe Bitiş Tarihi": "2025-09-03",
      "Kaza tespit tutanağı türü": "Anlaşmalı Kaza Tespit Tutanağı",
      "Eksper Rp Tarihi": "2025-02-28",
      "Hasar Onarım Tutarı": "140000",
      "Kusur Oranı": "75",
      "Davali Adi": "Corpus Sigorta A.Ş.",
      "Aracın Kilometresi": "231328",
      "action": "DK Hesaba Taşı",
      "İhtar Tarihi": "Bugünün tarihi",
      "predictedAction": "İhtar Dilekçesi Hazırla",
      "uniqueid": "1770577890579x349136294770973500",
      "Stage": "DK Hesabı",
      "Hasar Fotoğrafları": [
        "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=800&q=60",
        "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=800&q=60"
      ],
      "Ek Dosyalar": [
        "https://example.com/docs/hasar-foto-1.pdf",
        "https://example.com/docs/hasar-foto-2.pdf"
      ],
      "Esas No": ""
    };

    const SAMPLE_PREDICTED_JSON = {
      "İhtar Tarihi": "$TODAY",
      "Hasar Onarım Tutarı": "145000",
      "Kusur Oranı": "80",
      "predictedAction": "İhtar Dilekçesi Hazırla"
    };

    let columnJson = null;
    let restoreColumnJson = null;
    let humanData = {};
    let aiData = {};
    let aiExplicitFieldKeys = new Set();
    let sourceByField = {};
    let taskStartTimestamp = null;
    let initialSnapshot = null;
    const ACTION_OUTPUT_SPLITTER = "_-@SPLİTTER@-_";
    let selectedActionId = "";
    let selectedActionName = "Create";
    let triggeredActionUniqueId = "";
    let actionOptions = [];
    let isFormDirty = false;
    let isFormSaving = false;
    let lastAutosaveAt = 0;
    const AUTOSAVE_DEBOUNCE_MS = 2000;
    let lastObservedUniqueId = "";
    let hasPendingUniqueIdSubmit = false;
    let isWaitingForServerRefresh = false;
    let submitRefreshSignature = "";
    let pendingIncomingBubbleData = null;
    let pendingIncomingUniqueId = "";
    let changedFieldKeys = new Set();
    let humanTouchedFieldKeys = new Set();
    let dirtyFields = {};
    let changedFieldValuesByKey = new Map();
    let lastChangedMode = "";
    let hadEditModeDirtyChange = false;
    let hasEnteredEditSession = IS_EDITING_MODE;
    let isEditPanelOpen = false;
    let hasEnteredInlineEditPanel = false;
    let hadInlineEditDirtyChange = false;
    let lastObservedDataSignature = "";
    let pendingIncomingDataSignature = "";
    let lastStartParamWasTrue = false;
    let hasSeenStartSignal = false;
    let lastStartLoggedState = "";
    let hasChangesSinceStartOpen = false;
    let hasAiHydratedData = false;
    let startOpenSequence = 0;
    let pendingSubmitUntilConfigReady = null;
    let pendingStartCloseAutosave = null;
    let hasSeenEditingSignal = false;
    let lastEditingParamWasTrue = false;
    let activeSubmitAttemptId = 0;
    let submitLockTimeoutHandle = null;
    const SUBMIT_LOCK_TIMEOUT_MS = 15000;
    const START_FLOW_STORAGE_KEY = "bdf:start-flow-state";
    const START_CHANGED_TRACKING_STORAGE_KEY = "bdf:start-changed-tracking";
    const UNIQUE_ID_STORAGE_KEY = "bdf:last-observed-uniqueid";
    const ENABLE_RUNTIME_LOGS = false;

    const DEFAULT_CREATE_ACTION_LABEL = "Create";
    const DEFAULT_ACTION_PLACEHOLDER_LABEL = "Aksiyon seç";

    function hasExistingBubbleData() {
      const inputs = window.BUBBLE_INPUTS || {};
      const hasExplicitBubbleData = Object.prototype.hasOwnProperty.call(inputs, "BUBBLE_DATA_JSON");
      const candidate = hasExplicitBubbleData ? inputs.BUBBLE_DATA_JSON : MANUAL_DATA_JSON;
      if (candidate === null || candidate === undefined) return false;
      if (typeof candidate === "string") {
        const trimmed = candidate.trim();
        if (!trimmed) return false;
        if (["null", "undefined", "{}", "[]"].includes(trimmed.toLowerCase())) return false;
        try {
          const parsed = JSON.parse(trimmed);
          if (parsed === null || parsed === undefined) return false;
          if (Array.isArray(parsed)) return parsed.length > 0;
          if (typeof parsed === "object") return Object.keys(parsed).length > 0;
          return Boolean(parsed);
        } catch (error) {
          return false;
        }
      }
      if (Array.isArray(candidate)) return candidate.length > 0;
      if (typeof candidate === "object") return Object.keys(candidate).length > 0;
      return Boolean(candidate);
    }

    function getDefaultActionLabel() {
      return hasExistingBubbleData() ? DEFAULT_ACTION_PLACEHOLDER_LABEL : DEFAULT_CREATE_ACTION_LABEL;
    }

    function syncDefaultActionLabelFromData() {
      if (selectedActionId) return;
      const knownDefaults = ["", DEFAULT_CREATE_ACTION_LABEL, DEFAULT_ACTION_PLACEHOLDER_LABEL];
      if (!knownDefaults.includes(String(selectedActionName || ""))) return;
      selectedActionName = getDefaultActionLabel();
    }


    function parseActionOptionsFromInput(rawValue) {
      if (!rawValue) return [];
      let candidate = rawValue;
      if (typeof candidate === "string") {
        const trimmed = candidate.trim();
        if (!trimmed) return [];
        try {
          candidate = JSON.parse(trimmed);
        } catch (error) {
          return [];
        }
      }
      const list = Array.isArray(candidate?.options) ? candidate.options : [];
      return list
        .map((opt) => ({
          id: String(opt?.id || "").trim(),
          name: String(opt?.name || "").trim()
        }))
        .filter((opt) => opt.id && opt.name);
    }

    function getRawActionOptionsSource() {
      return (
        INITIAL_INPUTS?.actionoptions
        || INITIAL_INPUTS?.ACTIONOPTIONS
        || INITIAL_INPUTS?.COLUMN_JSON?.actionoptions
        || INITIAL_INPUTS?.column_json?.actionoptions
        || null
      );
    }

    function syncActionOptions() {
      const nextOptions = parseActionOptionsFromInput(getRawActionOptionsSource());
      actionOptions = nextOptions;
      if (!actionOptions.some((opt) => opt.id === selectedActionId)) {
        selectedActionId = "";
        selectedActionName = getDefaultActionLabel();
      }
      renderActionOptions();
      updateActionBarUi();
    }

    const rootElement = document.getElementById("bdf-root");
    const styleElement = document.querySelector("style[data-bdf-style]");
    let rootScope = rootElement;

    if (window.BDF_USE_SHADOW === true && rootElement && !rootElement.shadowRoot) {
      const shadow = rootElement.attachShadow({ mode: "open" });
      if (styleElement) {
        const shadowStyle = document.createElement("style");
        shadowStyle.textContent = styleElement.textContent.replace(/#bdf-root/g, ":host");
        shadow.append(shadowStyle);
      }
      while (rootElement.firstChild) {
        shadow.append(rootElement.firstChild);
      }
      rootScope = shadow;
    }

    const qs = (selector) => (rootScope && rootScope.querySelector ? rootScope.querySelector(selector) : null);
    const qsa = (selector) => (rootScope && rootScope.querySelectorAll ? rootScope.querySelectorAll(selector) : []);
    const byId = (id) => qs(`#${id}`);

    function updateViewportMetrics() {
      const vv = window.visualViewport;
      const viewportHeight = vv && Number.isFinite(vv.height) ? vv.height : window.innerHeight;
      const keyboardInset = vv && Number.isFinite(vv.height)
        ? Math.max(0, Math.round(window.innerHeight - (vv.height + (vv.offsetTop || 0))))
        : 0;
      if (rootElement) {
        rootElement.style.setProperty("--bdf-vh", `${Math.max(0, viewportHeight)}px`);
        rootElement.style.setProperty("--bdf-keyboard-inset", `${keyboardInset}px`);
      }
    }

    function focusFieldIntoView(target) {
      if (!target || typeof target.scrollIntoView !== "function") return;
      target.scrollIntoView({ behavior: "smooth", block: "center" });
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          notifyParentHeight();
        });
      });
    }

    function notifyParentHeight() {
      if (window.parent === window) return;
      requestAnimationFrame(() => {
        const first = Math.max(
          document.documentElement ? document.documentElement.scrollHeight : 0,
          document.body ? document.body.scrollHeight : 0
        );
        requestAnimationFrame(() => {
          const second = Math.max(
            document.documentElement ? document.documentElement.scrollHeight : 0,
            document.body ? document.body.scrollHeight : 0
          );
          const height = Math.max(first, second, 200);
          window.parent.postMessage({ type: "BDF_HEIGHT", height }, "*");
        });
      });
    }

    function initParentHeightSync() {
      updateViewportMetrics();
      notifyParentHeight();
      window.addEventListener("resize", () => {
        updateViewportMetrics();
        notifyParentHeight();
      });
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", () => {
          updateViewportMetrics();
          notifyParentHeight();
        });
        window.visualViewport.addEventListener("scroll", updateViewportMetrics);
      }
      if (rootElement && "MutationObserver" in window) {
        const mo = new MutationObserver(() => notifyParentHeight());
        mo.observe(rootElement, { childList: true, subtree: true, attributes: true, characterData: true });
      }
      setTimeout(notifyParentHeight, 60);
      setTimeout(notifyParentHeight, 320);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initParentHeightSync);
    } else {
      initParentHeightSync();
    }

    function retryEvery(selector, cb, timeoutMs = 3000, intervalMs = 50) {
      if (!rootScope || !rootScope.querySelector) return;
      const startedAt = Date.now();
      const tryRun = () => {
        const el = rootScope.querySelector(selector);
        if (el) {
          cb(el);
          return true;
        }
        return false;
      };
      if (tryRun()) return;
      const timer = setInterval(() => {
        if (tryRun() || Date.now() - startedAt >= timeoutMs) {
          clearInterval(timer);
        }
      }, intervalMs);
    }

    const safeOn = (target, eventName, handler, options = {}) => {
      const { timeoutMs = 3000, intervalMs = 50 } = options;
      if (typeof target === "string") {
        retryEvery(target, (el) => {
          el.addEventListener(eventName, handler);
        }, timeoutMs, intervalMs);
        return;
      }
      if (!target) return;
      target.addEventListener(eventName, handler);
    };

    function loadSampleSchema() {
      if (!schemaInput) return;
      schemaInput.value = JSON.stringify(defaultSchema, null, 2);
      if (currentDateTimeInput) currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
      if (localeInput) localeInput.value = defaultSchema.locale;
      if (timezoneInput) timezoneInput.value = defaultSchema.timezone;
      if (modeInput) modeInput.value = defaultSchema.mode;
      if (requiredPolicyInput) requiredPolicyInput.value = defaultSchema.requiredPolicy;
      if (showInlineHelpInput) showInlineHelpInput.checked = defaultSchema.showInlineHelp;
      if (autoFocusInvalidInput) autoFocusInvalidInput.checked = defaultSchema.autoFocusFirstInvalid;
    }

    function initLateIncomingDataSync() {
      let lastDataFlag = hasExistingBubbleData() ? "1" : "0";
      let lastOptionsJson = JSON.stringify(parseActionOptionsFromInput(getRawActionOptionsSource()));
      setInterval(() => {
        const nextDataFlag = hasExistingBubbleData() ? "1" : "0";
        const nextOptionsJson = JSON.stringify(parseActionOptionsFromInput(getRawActionOptionsSource()));
        if (nextDataFlag !== lastDataFlag) {
          lastDataFlag = nextDataFlag;
          syncDefaultActionLabelFromData();
          updateActionBarUi();
        }
        if (nextOptionsJson !== lastOptionsJson) {
          lastOptionsJson = nextOptionsJson;
          syncActionOptions();
        }
      }, 700);
    }

    function renderFormFromInputs() {
      const parsed = safeJsonParse(schemaInput?.value || "");
      if (!parsed || !parsed.fields) {
        setConsole("Schema parse edilemedi", "");
        return;
      }
      state.config = {
        ...parsed,
        currentDateTimeISO: currentDateTimeInput?.value || parsed.currentDateTimeISO,
        locale: localeInput?.value || parsed.locale || "tr-TR",
        timezone: timezoneInput?.value || parsed.timezone || "Europe/Istanbul",
        mode: modeInput?.value || parsed.mode || "create",
        requiredPolicy: requiredPolicyInput?.value || parsed.requiredPolicy || "strict",
        showInlineHelp: Boolean(showInlineHelpInput?.checked),
        autoFocusFirstInvalid: Boolean(autoFocusInvalidInput?.checked)
      };
      columnJson = {
        columns: (state.config.fields || []).map((field) => ({
          fieldName: field.label || field.key,
          label: field.label,
          type: field.type,
          required: field.required || normalizeStageType(field.stageType) === "mandatory",
          stageType: field.stageType || "optional",
          options: field.options || [],
          default: field.default,
          allowMultiple: field.allowMultiple || field.ui?.allowMultiple || false,
          ui: field.ui || {}
        })),
        currentDateTimeISO: state.config.currentDateTimeISO,
        locale: state.config.locale,
        timezone: state.config.timezone,
        mode: state.config.mode
      };
      if (columnWarning) columnWarning.style.display = "none";
      if (formContainer) formContainer.style.display = "block";
      renderForm(state.config);
      applyVersionVisibility();
      flushPendingSubmitAfterConfigReady();
    }

    const schemaInput = byId("schemaInput");
    const columnJsonInput = byId("columnJsonInput");
    const humanJsonInput = byId("humanJsonInput");
    const predictedJsonInput = byId("predictedJsonInput");
    const columnJsonError = byId("columnJsonError");
    const humanJsonError = byId("humanJsonError");
    const predictedJsonError = byId("predictedJsonError");
    const versionInput = byId("versionInput");
    const jsonInputsSection = byId("jsonInputsSection");
    const debugPanels = byId("debugPanels");
    const currentDateTimeInput = byId("currentDateTime");
    const localeInput = byId("localeInput");
    const timezoneInput = byId("timezoneInput");
    const modeInput = byId("modeInput");
    const requiredPolicyInput = byId("requiredPolicyInput");
    const showInlineHelpInput = byId("showInlineHelp");
    const autoFocusInvalidInput = byId("autoFocusInvalid");
    const formEl = byId("dynamicForm");
    const editModeRoot = byId("editModeRoot");
    const editSearchInput = byId("editSearchInput");
    const editSearchClear = byId("editSearchClear");
    const editSearchEmpty = byId("editSearchEmpty");
    const editModeLoading = byId("editModeLoading");
    const editModeLoadingText = byId("editModeLoadingText");
    const editStageLayout = byId("editStageLayout");
    const editStageTabs = byId("editStageTabs");
    const editStageSelect = byId("editStageSelect");
    const editStageHeading = byId("editStageHeading");
    const editStageChip = byId("editStageChip");
    const editStageStatus = byId("editStageStatus");
    const editStageFields = byId("editStageFields");
    const submitBtn = byId("submitBtn");
    const clearBtn = byId("clearBtn");
    const formRefreshLoading = byId("formRefreshLoading");
    const summaryBox = byId("summaryBox");
    const formContainer = byId("formContainer");
    const formActions = byId("formActions");
    const actionBar = byId("actionBar");
    const actionSplit = byId("actionSplit");
    const actionTriggerBtn = byId("actionTriggerBtn");
    const actionChevronBtn = byId("actionChevronBtn");
    const actionMenu = byId("actionMenu");
    const predictedActionBtn = byId("predictedActionBtn");
    const toggleInlineEditBtn = byId("toggleInlineEdit");
    const moreActions = byId("moreActions");
    const moreActionsBtn = byId("moreActionsBtn");
    const moreActionsMenu = byId("moreActionsMenu");
    const addFieldBtn = byId("addFieldBtn");
    const manageFieldsBtn = byId("manageFieldsBtn");
    const actionEmptyMsg = byId("actionEmptyMsg");
    const consoleEl = byId("eventConsole");
    const submitOutputsEl = byId("submitOutputs");
    const eventConsoleSection = byId("eventConsoleSection");
    const submitOutputsSection = byId("submitOutputsSection");
    const lightboxEl = byId("lightbox");
    const lightboxImage = byId("lightboxImage");
    const exportModal = byId("exportModal");
    const exportContent = byId("exportContent");
    const exportTabs = qsa("[data-export-tab]");
    const loadHumanJsonBtn = byId("loadHumanJson");
    const loadPredictedJsonBtn = byId("loadPredictedJson");
    const loadColumnJsonBtn = byId("loadColumnJson");
    const applyAiToEmptyBtn = byId("applyAiToEmpty");
    const overwriteAiToAllBtn = byId("overwriteAiToAll");
    const resetStoresBtn = byId("resetStores");
    const scenarioColumnOnlyBtn = byId("scenarioColumnOnly");
    const scenarioColumnHumanBtn = byId("scenarioColumnHuman");
    const scenarioColumnAiBtn = byId("scenarioColumnAi");
    const scenarioColumnAiHumanBtn = byId("scenarioColumnAiHuman");
    const scenarioConflictBtn = byId("scenarioConflict");
    const exportJsonBtn = byId("exportJson");
    const closeExportBtn = byId("closeExport");
    const aiFieldCountEl = byId("aiFieldCount");
    const humanFieldCountEl = byId("humanFieldCount");
    const columnWarning = byId("columnWarning");
    const debugToolbar = byId("debugToolbar");

    const initBdf = (root) => {
      if (!root || root.__bdfInited) return;
      root.__bdfInited = true;

      safeOn("#loadSample", "click", () => {
        loadSampleSchema();
      });

      safeOn("#renderForm", "click", () => {
        renderFormFromInputs();
      });

      safeOn("#clearConsole", "click", () => {
        if (consoleEl) consoleEl.textContent = "";
      });
    };

    initBdf(rootElement);

    if (columnJsonInput && MANUAL_COLUMN_JSON) {
      columnJsonInput.value = JSON.stringify(MANUAL_COLUMN_JSON, null, 2);
    }
    if (humanJsonInput && MANUAL_DATA_JSON) {
      humanJsonInput.value = JSON.stringify(MANUAL_DATA_JSON, null, 2);
    }
    if (predictedJsonInput && MANUAL_PREDICTED_JSON) {
      predictedJsonInput.value = JSON.stringify(MANUAL_PREDICTED_JSON, null, 2);
    }
    if (versionInput) {
      versionInput.checked = IS_VERSION_MODE;
    }

    const state = {
      config: null,
      values: {},
      validMap: {},
      touched: {},
      errors: {},
      autoSaveTimer: null,
      fileBuffers: {},
      fileStaging: {},
      fieldRefs: {},
      columnData: null
    };

    let editModeSearchTerm = "";
    let editModeDebounceTimer = null;
    let editModeStageOrder = [];
    let editModeStageMeta = [];
    let editSelectedStage = "";
    let editProcessActiveStageKey = "";
    let editModePayloadLoaded = false;
    let lastEditModePayloadSignature = "";
    let editModePayloadPollTimer = null;
    let editModeSlowPollTimer = null;
    let editModeStablePollCount = 0;
    let editCachedPayloadRawSignature = "";
    let editCachedPayloadParsed = { stageGroups: null, allFields: null };
    let editStageRenderSeq = 0;

    const defaultSchema = {
      fields: [
        {
          key: "fullName",
          label: "Ad Soyad",
          type: "text",
          required: true,
          placeholder: "Örn. Ayşe Yılmaz",
          helpText: "Kimlikteki ad-soyad",
          minLen: 3
        },
        {
          key: "email",
          label: "E-posta",
          type: "email",
          required: true,
          placeholder: "mail@example.com"
        },
        {
          key: "phone",
          label: "Telefon",
          type: "phone",
          required: true,
          placeholder: "05xx xxx xx xx",
          ui: { autoTrPrefix: true }
        },
        {
          key: "website",
          label: "Website",
          type: "url",
          placeholder: "https://",
          ui: { suggestHttps: true }
        },
        {
          key: "password",
          label: "Şifre",
          type: "password",
          required: true,
          minLen: 8
        },
        {
          key: "bio",
          label: "Açıklama",
          type: "textarea",
          placeholder: "Kısa notlar...",
          maxLen: 240
        },
        {
          key: "age",
          label: "Yaş",
          type: "integer",
          min: 18,
          max: 99
        },
        {
          key: "salary",
          label: "Maaş (₺)",
          type: "currency",
          ui: { currency: "₺", step: 0.01, thousandSeparator: true }
        },
        {
          key: "discount",
          label: "İndirim (%)",
          type: "percent",
          ui: { step: 0.1 }
        },
        {
          key: "subscribe",
          label: "KVKK Onayı",
          type: "boolean",
          required: true,
          helpText: "Zorunlu onay"
        },
        {
          key: "vehicleType",
          label: "Araç Tipi",
          type: "dropdown",
          options: [
            { value: "hususi", label: "Hususi", group: "Binek" },
            { value: "ticari", label: "Ticari", group: "Ticari" },
            { value: "kiralik", label: "Kiralık", group: "Ticari" }
          ],
          required: true
        },
        {
          key: "extras",
          label: "Ek Özellikler",
          type: "dropdown",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri görüş kamera" },
            { value: "isik", label: "LED far" }
          ]
        },
        {
          key: "appointmentDate",
          label: "Randevu Tarihi",
          type: "date",
          required: true,
          default: "$TODAY",
          ui: { showCalendar: true, allowTyping: true, quickActions: true }
        },
        {
          key: "appointmentDateTime",
          label: "Randevu Datetime",
          type: "datetime",
          default: "$NOW",
          ui: { quickActions: true }
        },
        {
          key: "appointmentTime",
          label: "Uygun Saat",
          type: "time",
          default: "$CURRENT_TIME",
          ui: { quickActions: true }
        },
        {
          key: "duration",
          label: "Süre",
          type: "duration",
          ui: { durationFormat: "minutes" }
        },
        {
          key: "address",
          label: "Adres",
          type: "address",
          helpText: "Minimum sokak, ilçe, il ve posta kodu"
        },
        {
          key: "attachments",
          label: "Dosyalar",
          type: "multifile",
          ui: { accept: "image/*,application/pdf", maxFiles: 5, maxSizeMB: 10, showPreview: true }
        },
        {
          key: "profileImage",
          label: "Profil Fotoğrafı",
          type: "image",
          ui: { accept: "image/*", maxFiles: 1, maxSizeMB: 5, showPreview: true }
        },
        {
          key: "metadata",
          label: "JSON (advanced)",
          type: "json",
          placeholder: "{\"foo\":\"bar\"}"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create",
      initialValues: {},
      requiredPolicy: "strict",
      showInlineHelp: true,
      autoFocusFirstInvalid: true
    };

    function parseJsonInput(value, errorEl) {
      const trimmed = value.trim();
      if (!trimmed) {
        if (errorEl) errorEl.textContent = "";
        return null;
      }
      try {
        const parsed = JSON.parse(trimmed);
        if (errorEl) errorEl.textContent = "";
        return parsed;
      } catch (error) {
        if (errorEl) errorEl.textContent = "JSON formatı hatalı.";
        return null;
      }
    }

    function syncManualJsonInputs() {
      MANUAL_COLUMN_JSON = parseJsonInput(columnJsonInput?.value || "", columnJsonError);
      MANUAL_DATA_JSON = parseJsonInput(humanJsonInput?.value || "", humanJsonError);
      MANUAL_PREDICTED_JSON = parseJsonInput(predictedJsonInput?.value || "", predictedJsonError);
      syncActionOptions();
    }

    function applyVersionVisibility() {
      const formOnly = IS_VERSION_MODE;
      const debugVisible = !formOnly && BDF.DEBUG_MODE;
      if (debugPanels) {
        debugPanels.style.display = debugVisible ? "block" : "none";
      }
      if (jsonInputsSection) {
        jsonInputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (eventConsoleSection) {
        eventConsoleSection.style.display = debugVisible ? "block" : "none";
      }
      if (submitOutputsSection) {
        submitOutputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (debugToolbar) {
        debugToolbar.style.display = debugVisible ? "flex" : "none";
      }
      if (columnWarning) {
        columnWarning.style.display = debugVisible && !columnJson ? "block" : "none";
      }
      if (formActions) {
        formActions.style.display = "none";
      }
      const isEditUiActive = IS_EDITING_MODE || isEditPanelOpen;
      if (rootElement) {
        rootElement.classList.toggle("editing-mode", isEditUiActive);
      }
      if (editModeRoot) {
        editModeRoot.style.display = state.config ? "grid" : "none";
        editModeRoot.classList.toggle("search-only", !isEditUiActive);
      }
      if (isEditUiActive && editSearchInput) {
        requestAnimationFrame(() => {
          try {
            editSearchInput.focus({ preventScroll: true });
          } catch (error) {
            editSearchInput.focus();
          }
        });
      }
      if (isEditUiActive && !editModePayloadLoaded) {
        setEditModeLoading(true, "Edit verileri yükleniyor…");
      }
      if (actionBar) {
        actionBar.style.display = IS_EDITING_MODE ? "none" : "";
      }
      if (formEl) {
        formEl.style.display = isEditUiActive ? "none" : "grid";
      }
      if (!isEditUiActive) {
        if (editStageLayout) editStageLayout.style.display = "none";
      }
      if (formContainer) {
        formContainer.style.display = "block";
        const formSection = formContainer.closest("section");
        if (formSection) {
          Array.from(formSection.children).forEach((child) => {
            if (child === formContainer) return;
            child.style.display = formOnly ? "none" : "";
          });
        }
      }
      if (formOnly) {
        closeLightbox();
        closeExportModal();
      }
    }

    const sampleColumnData = {
      columns: defaultSchema.fields.map((field) => ({
        key: field.key,
        label: field.label,
        type: field.type
      })),
      source: "sample-column-json"
    };

    function setConsole(message, payload) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      if (!consoleEl) return;
      const timestamp = new Date().toLocaleTimeString("tr-TR");
      consoleEl.textContent += `[${timestamp}] ${message}` + (payload ? `\n${payload}` : "") + "\n";
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }


    function logPredictDebug(label, payload = {}) {
      const snapshot = {
        label,
        time: new Date().toISOString(),
        currentUniqueId: readCurrentUniqueId(),
        startSignal: readStartSignalValue(),
        mode: String(state.config?.mode || ""),
        ...payload
      };
      console.info(`[BDF_PREDICT_DEBUG] ${JSON.stringify(snapshot)}`);
      if (!IS_VERSION_MODE && BDF.DEBUG_MODE) {
        setConsole(`predict:${label}`, JSON.stringify(snapshot, null, 2));
      }
    }


    function getPredictedActionName() {
      const candidate =
        MANUAL_PREDICTED_JSON?.predictedAction
        || MANUAL_DATA_JSON?.predictedAction
        || INITIAL_INPUTS?.PREDICTED_JSON?.predictedAction
        || "";
      return typeof candidate === "string" ? candidate.trim() : "";
    }

    function closeActionMenu() {
      if (actionMenu) actionMenu.classList.remove("open");
    }

    function openActionMenu() {
      if (!actionMenu || !Array.isArray(actionOptions) || !actionOptions.length) return;
      actionMenu.classList.add("open");
      const splitRect = actionSplit ? actionSplit.getBoundingClientRect() : null;
      const menuRect = actionMenu.getBoundingClientRect();
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
      if (!splitRect || !viewportWidth) return;
      const menuWidth = menuRect.width || 240;
      const leftPreferred = splitRect.right - menuWidth;
      const left = Math.max(8, Math.min(leftPreferred, viewportWidth - menuWidth - 8));
      actionMenu.style.left = `${left - splitRect.left}px`;
      actionMenu.style.right = "auto";
    }

    function requiresExplicitActionSelection() {
      return hasExistingBubbleData() && Array.isArray(actionOptions) && actionOptions.length > 0;
    }

    function isActionSelectionValid() {
      if (!requiresExplicitActionSelection()) return true;
      return Boolean(String(selectedActionId || "").trim());
    }

    function setFormRefreshLoading(active, message = "") {
      const nextActive = Boolean(active);
      isWaitingForServerRefresh = nextActive;
      if (formRefreshLoading) {
        formRefreshLoading.classList.toggle("open", nextActive);
        formRefreshLoading.setAttribute("aria-hidden", nextActive ? "false" : "true");
        const textNode = formRefreshLoading.querySelector("p");
        if (textNode && message) textNode.textContent = message;
      }
      if (submitBtn) submitBtn.disabled = nextActive;
      if (clearBtn) clearBtn.disabled = nextActive;
      if (actionTriggerBtn) actionTriggerBtn.disabled = nextActive;
      if (actionChevronBtn) actionChevronBtn.disabled = nextActive || !(Array.isArray(actionOptions) && actionOptions.length > 0);
    }

    function canRefreshLoadingStop() {
      if (!isWaitingForServerRefresh) return true;
      const currentSignature = readCurrentBubbleDataSignature();
      if (!currentSignature) return true;
      if (!submitRefreshSignature) return true;
      return currentSignature !== submitRefreshSignature;
    }

    function canOpenInlineEditPanel() {
      const startSignal = readStartSignalValue();
      if (!startSignal) return false;
      const uniqueId = readCurrentUniqueId();
      if (!uniqueId) return false;
      const payload = readEditModePayloadSources();
      const hasStage = Array.isArray(payload?.stageGroups) && payload.stageGroups.length > 0;
      const hasAll = Array.isArray(payload?.allFields) && payload.allFields.length > 0;
      return hasStage || hasAll;
    }

    function collectInlineEditDiagnostics(extra = {}) {
      const payload = readEditModePayloadSources();
      const startSignal = readStartSignalValue();
      const editingRaw = window.BUBBLE_INPUTS?.editing;
      let editingSignal = null;
      if (editingRaw === true || editingRaw === 1) editingSignal = true;
      else if (editingRaw === false || editingRaw === 0) editingSignal = false;
      else {
        const text = String(editingRaw ?? "").trim().toLowerCase();
        if (text === "true" || text === "1") editingSignal = true;
        else if (text === "false" || text === "0") editingSignal = false;
      }
      const uniqueId = readCurrentUniqueId();
      const hasStage = Array.isArray(payload?.stageGroups) && payload.stageGroups.length > 0;
      const hasAll = Array.isArray(payload?.allFields) && payload.allFields.length > 0;
      const mode = String(state.config?.mode || "").trim().toLowerCase();
      const hasConfigFields = Array.isArray(state.config?.fields) ? state.config.fields.length : 0;
      return {
        startSignal,
        editingSignal,
        rawEditingInput: window.BUBBLE_INPUTS?.editing,
        isEditPanelOpen,
        canOpenInlineEditPanel: Boolean(startSignal && uniqueId && (hasStage || hasAll)),
        uniqueId,
        hasStagePayload: hasStage,
        hasAllPayload: hasAll,
        stagePayloadCount: hasStage ? payload.stageGroups.length : 0,
        allPayloadCount: hasAll ? payload.allFields.length : 0,
        configMode: mode,
        configFieldCount: hasConfigFields,
        editModePayloadLoaded,
        ...extra
      };
    }

    function updateInlineEditToggleUi() {
      if (!toggleInlineEditBtn) return;
      const canOpen = canOpenInlineEditPanel();
      const shouldShow = canOpen || isEditPanelOpen || hasEnteredInlineEditPanel;
      toggleInlineEditBtn.style.display = shouldShow ? "inline-flex" : "none";
      toggleInlineEditBtn.disabled = !canOpen && !isEditPanelOpen;
      toggleInlineEditBtn.textContent = isEditPanelOpen ? "Show less" : "Show more";
      if (moreActions) {
        moreActions.style.display = shouldShow ? "inline-flex" : "none";
      }
    }

    function setInlineEditPanelOpen(nextOpen) {
      const desired = Boolean(nextOpen);
      traceAutosave("inline-toggle-click", collectInlineEditDiagnostics({ desired }));
      const inputs = window.BUBBLE_INPUTS || (window.BUBBLE_INPUTS = {});
      inputs.editing = desired ? true : null;
      isEditPanelOpen = desired;
      traceAutosave("inline-toggle-applied-editing", collectInlineEditDiagnostics({ desired }));
      if (isEditPanelOpen) {
        hasEnteredInlineEditPanel = true;
        hasEnteredEditSession = true;
      }
      updateInlineEditToggleUi();
      applyVersionVisibility();
      if (isEditPanelOpen) {
        const payloadAppliedNow = applyEditModePayloadIfReady(true);
        ensureEditModePayloadPolling(true);
        if (state.config && (String(state.config.mode || "").trim().toLowerCase() === "edit")) {
          runEditModeFilterRender();
        }
        traceAutosave("inline-toggle-open-result", collectInlineEditDiagnostics({ payloadAppliedNow }));
      } else {
        stopEditModePayloadPolling();
        const restoreJson = restoreColumnJson || columnJson;
        if (restoreJson) {
          applyColumnJson(restoreJson, { persistRestore: true });
        } else if (state.config) {
          renderForm(state.config);
        }
        if (editSearchInput && String(editSearchInput.value || "").trim()) {
          runColumnSearchRender(editSearchInput.value);
        }
        const dirtyNow = reconcileDirtyTracking("inline-toggle-close");
        const shouldAutosaveOnInlineClose = (dirtyNow || hasChangesSinceStartOpen || changedFieldKeys.size > 0) && !isFormSaving;
        if (shouldAutosaveOnInlineClose) {
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "inline-toggle-close", modeHint: getSubmitModeHint() });
        }
        traceAutosave("inline-toggle-close-result", collectInlineEditDiagnostics({ shouldAutosaveOnInlineClose, dirtyNow }));
      }
      evaluateEditingSignalTransition();
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          notifyParentHeight();
        });
      });
    }

    function updateActionBarUi() {
      const hasOptions = Array.isArray(actionOptions) && actionOptions.length > 0;
      syncDefaultActionLabelFromData();
      const safeSelectedName = String(selectedActionName || getDefaultActionLabel()).trim() || getDefaultActionLabel();
      if (actionTriggerBtn) {
        actionTriggerBtn.disabled = isWaitingForServerRefresh;
        actionTriggerBtn.textContent = safeSelectedName;
      }
      if (actionChevronBtn) {
        actionChevronBtn.disabled = isWaitingForServerRefresh || !hasOptions;
        actionChevronBtn.style.display = hasOptions ? "inline-flex" : "none";
      }
      if (actionEmptyMsg) {
        actionEmptyMsg.style.display = "none";
      }
      updateInlineEditToggleUi();

      const predictedActionName = getPredictedActionName();
      const matched = hasOptions
        ? actionOptions.find((opt) => String(opt?.name || "").trim() === predictedActionName)
        : null;
      if (predictedActionBtn) {
        if (!predictedActionName || !hasOptions) {
          predictedActionBtn.style.display = "none";
        } else {
          predictedActionBtn.style.display = "inline-flex";
          predictedActionBtn.textContent = matched
            ? `✨ Önerilen: ${predictedActionName}`
            : `✨ Önerilen: ${predictedActionName} (eşleşme yok)`;
          predictedActionBtn.disabled = !matched;
          predictedActionBtn.dataset.actionId = matched?.id || "";
          predictedActionBtn.dataset.actionName = matched?.name || predictedActionName;
        }
      }
    }

    function triggerSelectedAction() {
      if (requiresExplicitActionSelection() && !isActionSelectionValid()) {
        selectedActionName = DEFAULT_ACTION_PLACEHOLDER_LABEL;
        updateActionBarUi();
        openActionMenu();
        return;
      }
      triggeredActionUniqueId = selectedActionId || "";
      emit("onActionTrigger", {
        selectedActionId,
        selectedActionName,
        triggeredActionUniqueId
      });
      if (formEl) {
        formEl.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
      }
    }

    function selectActionAndTrigger(option) {
      if (!option) return;
      selectedActionId = String(option.id || "").trim();
      selectedActionName = String(option.name || getDefaultActionLabel()).trim() || getDefaultActionLabel();
      updateActionBarUi();
      closeActionMenu();
      triggerSelectedAction();
    }

    function renderActionOptions() {
      if (!actionMenu) return;
      actionMenu.innerHTML = "";
      const hasOptions = Array.isArray(actionOptions) && actionOptions.length > 0;
      const shouldShowCreateOption = !hasExistingBubbleData();
      const optionsToRender = hasOptions
        ? (shouldShowCreateOption
          ? [{ id: "", name: DEFAULT_CREATE_ACTION_LABEL, description: "Aksiyonsuz oluşturma" }, ...actionOptions]
          : [...actionOptions])
        : [];

      if (!hasOptions) {
        closeActionMenu();
        selectedActionId = "";
        selectedActionName = getDefaultActionLabel();
        updateActionBarUi();
        return;
      }

      optionsToRender.forEach((option) => {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "action-menu-item";
        if (!option.id) {
          item.textContent = `${option.name} (Aksiyonsuz oluşturma)`;
        } else {
          item.textContent = String(option.name || option.id || "Aksiyon");
        }
        item.addEventListener("click", () => {
          selectActionAndTrigger(option);
        });
        actionMenu.appendChild(item);
      });
      updateActionBarUi();
    }
function renderSubmitOutputs(payload) {
      if (IS_VERSION_MODE) return;
      if (!submitOutputsEl) {
        console.warn("submitOutputs panel not found");
        return;
      }
      const safePayload = payload || {};
      const listToText = (list) => (Array.isArray(list) ? list.join("\n") : String(list ?? ""));
      submitOutputsEl.textContent = [
        `output1: ${safePayload.output1 ?? ""}`,
        `output2: ${safePayload.output2 ?? ""}`,
        `output3: ${safePayload.output3 ?? ""}`,
        `output4: ${safePayload.output4 ?? ""}`,
        "outputlist1:",
        listToText(safePayload.outputlist1),
        "outputlist2:",
        listToText(safePayload.outputlist2),
        "outputlist3:",
        listToText(safePayload.outputlist3),
        "outputlist4:",
        listToText(safePayload.outputlist4)
      ].join("\n");

    }

    function buildSubmitOutputsPayload({ autosave = false, modeHint = "" } = {}) {
      const endTimestamp = new Date().toISOString();
      const startTimestamp = taskStartTimestamp || endTimestamp;
      const photoPayload = buildOutput4String();
      const baseOutput4 = photoPayload === null ? "null" : String(photoPayload || "");
      const hasBubbleData = hasExistingBubbleData();
      const effectiveMode = String(modeHint || "").trim().toLowerCase();
      const configMode = String(state.config?.mode || "").trim().toLowerCase();
      const editContextActive = hadEditModeDirtyChange || hasEnteredEditSession || isEditingModeNow() || configMode === "edit";
      const isEditAutosave = autosave && (effectiveMode === "edit" || editContextActive);
      const actionType = isEditAutosave ? "Edit" : (hasBubbleData ? "Process" : "Create");
      traceAutosave("build-submit-outputs-decision", collectEditContextSnapshot({ autosave, modeHint: effectiveMode, editContextActive, isEditAutosave, actionType, hasBubbleData }));
      const output4 = `${baseOutput4}${ACTION_OUTPUT_SPLITTER}${triggeredActionUniqueId || ""}${ACTION_OUTPUT_SPLITTER}${actionType}`;
      const fullSnapshot = buildExportJson();
      return {
        output1: startTimestamp,
        output2: endTimestamp,
        output3: readCurrentUniqueId(),
        output4: output4,
        outputlist1: buildKeyValueListFromSources(),
        outputlist2: buildAddedCustomFields(),
        outputlist3: buildDeletedFields(),
        outputlist4: buildModifiedFields(),
        output_full_obj: fullSnapshot,
        output_full_json: JSON.stringify(fullSnapshot)
      };
    }

    function emit(eventName, detail) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      setConsole(eventName, JSON.stringify(detail, null, 2));
    }

    function safeJsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return null;
      }
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function truncateLabelText(value, maxChars = 36) {
      const text = String(value ?? "").trim();
      if (!text) return "";
      if (text.length <= maxChars) return text;
      return `${text.slice(0, maxChars - 1)}…`;
    }

    function getCurrentDateTime(config) {
      return config.currentDateTimeISO || new Date().toISOString();
    }

    function getOffsetFromIso(iso) {
      const match = String(iso).match(/([+-]\d{2}:?\d{2}|Z)$/);
      if (!match) return "Z";
      if (match[1] === "Z") return "Z";
      const offset = match[1].includes(":") ? match[1] : `${match[1].slice(0, 3)}:${match[1].slice(3)}`;
      return offset;
    }

    function getDateFromIso(iso) {
      return String(iso).slice(0, 10);
    }

    function getTimeFromIso(iso) {
      return String(iso).slice(11, 16);
    }

    function normalizeDateInput(raw, config = state.config || {}) {
      if (!raw) return "";
      const trimmed = String(raw).trim();
      const now = getCurrentDateTime(config);
      if (trimmed === "$TODAY" || trimmed === "$NOW") {
        return getDateFromIso(now);
      }
      if (trimmed.includes("T")) {
        return trimmed.slice(0, 10);
      }
      if (trimmed.includes(" ")) {
        return trimmed.split(" ")[0];
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmed)) {
        const [d, m, y] = trimmed.split(".");
        return `${y}-${m}-${d}`;
      }
      if (/^\d{8}$/.test(trimmed)) {
        const d = trimmed.slice(0, 2);
        const m = trimmed.slice(2, 4);
        const y = trimmed.slice(4, 8);
        return `${y}-${m}-${d}`;
      }
      return trimmed;
    }

    function isValidDateString(value) {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return false;
      const [year, month, day] = value.split("-").map((part) => Number(part));
      if (year < 1000 || year > 9999) return false;
      const date = new Date(year, month - 1, day);
      return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
    }

    function isValidTimeString(value) {
      if (!/^\d{2}:\d{2}$/.test(value)) return false;
      const [hour, minute] = value.split(":").map((part) => Number(part));
      return hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59;
    }

    function areValuesDifferent(a, b) {
      if (isEmptyValue(a) && isEmptyValue(b)) return false;
      if (Array.isArray(a) || Array.isArray(b) || typeof a === "object" || typeof b === "object") {
        return JSON.stringify(a ?? null) !== JSON.stringify(b ?? null);
      }
      return String(a ?? "") !== String(b ?? "");
    }

    function formatValueForDisplay(value) {
      if (Array.isArray(value) || typeof value === "object") {
        return JSON.stringify(value, null, 2);
      }
      return String(value ?? "");
    }

    function normalizeTimeInput(raw) {
      if (!raw) return "";
      const cleaned = raw.replace(/\s/g, "");
      if (/^\d{1,2}$/.test(cleaned)) return `${cleaned.padStart(2, "0")}:00`;
      if (/^\d{3}$/.test(cleaned)) return `${cleaned.slice(0, 1).padStart(2, "0")}:${cleaned.slice(1)}`;
      if (/^\d{4}$/.test(cleaned)) return `${cleaned.slice(0, 2)}:${cleaned.slice(2)}`;
      if (/^\d{2}:\d{2}$/.test(cleaned)) return cleaned;
      return cleaned;
    }

    function normalizeDateTimeInput(raw, config) {
      if (!raw) return "";
      const trimmedRaw = String(raw).trim();
      const offset = getOffsetFromIso(getCurrentDateTime(config));
      if (trimmedRaw === "$NOW") {
        return normalizeDateTimeInput(getCurrentDateTime(config), config);
      }
      if (trimmedRaw === "$TODAY") {
        return `${getDateFromIso(getCurrentDateTime(config))}T00:00:00${offset}`;
      }
      const trimmed = trimmedRaw.replace(" ", "T");
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmedRaw)) {
        const [d, m, y] = trimmedRaw.split(".");
        return `${y}-${m}-${d}T00:00:00${offset}`;
      }
      if (/^\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}$/.test(trimmedRaw)) {
        const [datePart, timePart] = trimmedRaw.split(" ");
        const [d, m, y] = datePart.split(".");
        return `${y}-${m}-${d}T${timePart}:00${offset}`;
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
        return `${trimmed}T00:00:00${offset}`;
      }
      const match = trimmed.match(/^(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2})(:\d{2})?(Z|[+-]\d{2}:?\d{2})?$/);
      if (match) {
        const [, datePart, timePart, secondsPart, tzPart] = match;
        const seconds = secondsPart || ":00";
        const tz = tzPart ? (tzPart.includes(":") || tzPart === "Z" ? tzPart : `${tzPart.slice(0, 3)}:${tzPart.slice(3)}`) : offset;
        return `${datePart}T${timePart}${seconds}${tz}`;
      }
      return trimmed;
    }

    function formatDateDisplay(value) {
      if (!value) return "";
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const [y, m, d] = value.split("-");
        return `${d}.${m}.${y}`;
      }
      return value;
    }

    function formatDateTimeDisplay(value) {
      if (!value) return "";
      const normalized = value.includes("T") ? value : normalizeDateTimeInput(value, state.config || {});
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
        const datePart = normalized.slice(0, 10);
        const timePart = normalized.slice(11, 16);
        return `${formatDateDisplay(datePart)} ${timePart}`;
      }
      return value;
    }

    function createMandatoryBadge() {
      const badge = document.createElement("span");
      badge.className = "required-mark";
      badge.textContent = "*";
      badge.setAttribute("aria-hidden", "true");
      return badge;
    }

    function buildCalendarPopover(config, { initialDate = "", onSelect, onClose, quickActionLabel = "Bugün", onQuickAction }) {
      const popover = document.createElement("div");
      popover.className = "picker-popover";
      const header = document.createElement("div");
      header.className = "picker-header";
      const prevBtn = document.createElement("button");
      prevBtn.type = "button";
      prevBtn.tabIndex = -1;
      prevBtn.className = "picker-nav";
      prevBtn.textContent = "‹";
      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.tabIndex = -1;
      nextBtn.className = "picker-nav";
      nextBtn.textContent = "›";
      const title = document.createElement("span");
      header.append(prevBtn, title, nextBtn);

      const grid = document.createElement("div");
      grid.className = "picker-grid";

      const actions = document.createElement("div");
      actions.className = "picker-actions";
      const todayBtn = document.createElement("button");
      todayBtn.type = "button";
      todayBtn.tabIndex = -1;
      todayBtn.className = "ghost";
      todayBtn.textContent = quickActionLabel;
      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.tabIndex = -1;
      closeBtn.className = "ghost";
      closeBtn.textContent = "Kapat";
      actions.append(todayBtn, closeBtn);

      popover.append(header, grid, actions);

      const weekdayLabels = ["Pzt", "Sal", "Çar", "Per", "Cum", "Cmt", "Paz"];
      let selectedDate = initialDate;
      let viewDate = initialDate ? new Date(`${initialDate}T00:00:00`) : new Date(getCurrentDateTime(config));

      const selectDate = (dateValue, emitChange = true) => {
        selectedDate = dateValue;
        if (dateValue) {
          viewDate = new Date(`${dateValue}T00:00:00`);
        }
        render();
        if (emitChange) onSelect(dateValue);
      };

      const render = () => {
        grid.innerHTML = "";
        weekdayLabels.forEach((label) => {
          const weekday = document.createElement("div");
          weekday.className = "picker-weekday";
          weekday.textContent = label;
          grid.append(weekday);
        });
        const year = viewDate.getFullYear();
        const month = viewDate.getMonth();
        title.textContent = viewDate.toLocaleString("tr-TR", { month: "long", year: "numeric" });
        const firstDay = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const startDay = (firstDay.getDay() + 6) % 7;
        for (let i = 0; i < startDay; i += 1) {
          const empty = document.createElement("div");
          grid.append(empty);
        }
        const todayValue = getDateFromIso(getCurrentDateTime(config));
        for (let day = 1; day <= daysInMonth; day += 1) {
          const dateValue = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
          const button = document.createElement("button");
          button.type = "button";
          button.className = "picker-day";
          button.tabIndex = -1;
          button.textContent = String(day);
          if (dateValue === todayValue) button.classList.add("is-today");
          if (dateValue === selectedDate) button.classList.add("is-selected");
          button.addEventListener("click", () => {
            selectDate(dateValue);
          });
          grid.append(button);
        }
      };

      const updateView = (direction) => {
        viewDate = new Date(viewDate.getFullYear(), viewDate.getMonth() + direction, 1);
        render();
      };

      prevBtn.addEventListener("click", () => updateView(-1));
      nextBtn.addEventListener("click", () => updateView(1));
      todayBtn.addEventListener("click", () => {
        if (onQuickAction) {
          onQuickAction({ selectDate });
          return;
        }
        const todayValue = getDateFromIso(getCurrentDateTime(config));
        selectDate(todayValue);
      });
      closeBtn.addEventListener("click", () => {
        popover.classList.remove("open");
        if (onClose) onClose();
      });

      render();

      return {
        element: popover,
        setSelectedDate(dateValue) {
          selectDate(dateValue, false);
        }
      };
    }

    function formatDateMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 8);
      if (digits.length <= 2) return digits;
      if (digits.length <= 4) return `${digits.slice(0, 2)}.${digits.slice(2)}`;
      return `${digits.slice(0, 2)}.${digits.slice(2, 4)}.${digits.slice(4)}`;
    }

    function formatTimeMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length <= 2) return digits;
      return `${digits.slice(0, 2)}:${digits.slice(2)}`;
    }

    function formatDateTimeMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 12);
      if (digits.length <= 8) {
        return formatDateMask(digits);
      }
      const dateDigits = digits.slice(0, 8);
      const timeDigits = digits.slice(8);
      const datePart = formatDateMask(dateDigits);
      const timePart = formatTimeMask(timeDigits);
      return `${datePart} ${timePart}`.trim();
    }

    function parseDateDisplay(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 8);
      if (digits.length !== 8) return "";
      const day = digits.slice(0, 2);
      const month = digits.slice(2, 4);
      const year = digits.slice(4, 8);
      return `${year}-${month}-${day}`;
    }

    function parseTimeDisplay(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length !== 4) return "";
      const hour = digits.slice(0, 2);
      const minute = digits.slice(2, 4);
      return `${hour}:${minute}`;
    }

    function parseDateTimeDisplay(value, config) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 12);
      if (digits.length !== 12) return "";
      const day = digits.slice(0, 2);
      const month = digits.slice(2, 4);
      const year = digits.slice(4, 8);
      const hour = digits.slice(8, 10);
      const minute = digits.slice(10, 12);
      const dateValue = `${year}-${month}-${day}`;
      const timeValue = `${hour}:${minute}`;
      if (!isValidDateString(dateValue) || !isValidTimeString(timeValue)) return "";
      const offset = getOffsetFromIso(getCurrentDateTime(config));
      return `${dateValue}T${timeValue}:00${offset}`;
    }

    function normalizeNumberInput(raw) {
      if (raw === null || raw === undefined || raw === "") return "";
      const normalized = String(raw).trim().replace(/\./g, "").replace(",", ".");
      return normalized;
    }

    function normalizeBooleanInput(raw) {
      if (typeof raw === "boolean") return raw;
      if (typeof raw === "number") return raw !== 0;
      const normalized = String(raw ?? "").trim().toLowerCase();
      if (["true", "1", "evet", "yes", "on"].includes(normalized)) return true;
      if (["false", "0", "hayır", "hayir", "no", "off"].includes(normalized)) return false;
      return Boolean(normalized);
    }

    function sanitizeNumberTyping(raw, { integer = false } = {}) {
      if (raw === null || raw === undefined) return "";
      let value = String(raw).replace(/[^0-9,.-]/g, "");
      value = value.replace(/(?!^)-/g, "");
      const sepRegex = integer ? /[.,]/g : /[.,]/g;
      let seenSep = false;
      value = value.replace(sepRegex, (match) => {
        if (integer) return "";
        if (seenSep) return "";
        seenSep = true;
        return match;
      });
      return value;
    }

    function formatNumberDisplay(value, options = {}) {
      if (value === "" || value === null || value === undefined || Number.isNaN(Number(value))) return "";
      const numeric = Number(value);
      const formatter = new Intl.NumberFormat("tr-TR", {
        minimumFractionDigits: options.minimumFractionDigits || 0,
        maximumFractionDigits: options.maximumFractionDigits || 2
      });
      return formatter.format(numeric);
    }


    function getDefaultValue(field, config) {
      if (!field.default) return "";
      const token = field.default;
      const now = getCurrentDateTime(config);
      if (token === "$NOW") return now;
      if (token === "$TODAY") return getDateFromIso(now);
      if (token === "$CURRENT_TIME") return getTimeFromIso(now);
      return token;
    }

    function getInitialValue(field, config) {
      const initialValues = config.initialValues || {};
      if (initialValues[field.key] !== undefined) return initialValues[field.key];
      if (config.mode === "create") {
        return getDefaultValue(field, config);
      }
      return "";
    }

    function isEmptyValue(value) {
      if (Array.isArray(value)) return value.length === 0;
      if (value === null || value === undefined) return true;
      if (typeof value === "string") return value.trim() === "";
      return false;
    }

    function normalizeKey(key) {
      if (key === null || key === undefined) return "";
      return String(key).trim();
    }

    function buildFieldKeyMap() {
      const map = new Map();
      (state.config?.fields || []).forEach((field) => {
        const aliases = [
          field.key,
          field.fieldName,
          field.label
        ];
        aliases.forEach((alias) => {
          const normalizedAlias = normalizeKey(alias);
          if (!normalizedAlias) return;
          if (!map.has(normalizedAlias)) {
            map.set(normalizedAlias, field.key);
          }
        });
      });
      return map;
    }

    function getFieldKeyFromJsonKey(jsonKey, keyMap) {
      if (!jsonKey) return null;
      const direct = keyMap.get(normalizeKey(jsonKey));
      if (direct) return direct;
      const normalizedTarget = normalizeKey(jsonKey).toLocaleLowerCase("tr-TR");
      for (const [candidate, fieldKey] of keyMap.entries()) {
        if (candidate.toLocaleLowerCase("tr-TR") === normalizedTarget) {
          return fieldKey;
        }
      }
      return null;
    }


    function isEditingModeNow() {
      if (isEditPanelOpen) {
        hasEnteredEditSession = true;
        return true;
      }
      const editingSignal = readEditingSignalValue();
      if (editingSignal === true) {
        hasEnteredEditSession = true;
        return true;
      }
      if (IS_EDITING_MODE) {
        hasEnteredEditSession = true;
        return true;
      }
      return false;
    }

    function markFieldAsChanged(fieldKey, options = {}) {
      if (!fieldKey) return;
      changedFieldKeys.add(fieldKey);
      dirtyFields[fieldKey] = true;
      const editingNow = isEditingModeNow();
      lastChangedMode = editingNow ? "edit" : "normal";
      if (editingNow || IS_EDITING_MODE) hadEditModeDirtyChange = true;
      if (isEditPanelOpen) hadInlineEditDirtyChange = true;
      traceAutosave("mark-field-changed", collectEditContextSnapshot({ fieldKey, editingNow }));
      persistStartChangedTracking();
      if (hasSeenStartSignal && lastStartParamWasTrue) {
        if (!hasChangesSinceStartOpen) {
          logStartState("edit-detected", { fieldKey, changedKeyCount: changedFieldKeys.size, startOpenSequence });
        }
        hasChangesSinceStartOpen = true;
        persistStartFlowState();
      }
    }

    function clearChangedFieldKeys() {
      changedFieldKeys = new Set();
      humanTouchedFieldKeys = new Set();
      dirtyFields = {};
    }


    function rememberChangedFieldValue(fieldKey, value) {
      if (!fieldKey) return;
      changedFieldValuesByKey.set(fieldKey, value);
      persistStartChangedTracking();
    }

    function clearChangedFieldValues() {
      changedFieldValuesByKey = new Map();
    }

    function clearChangedTracking() {
      clearChangedFieldKeys();
      clearChangedFieldValues();
      lastChangedMode = "";
      hadEditModeDirtyChange = false;
      hadInlineEditDirtyChange = false;
      clearPersistedStartChangedTracking();
      persistStartFlowState();
    }

    function getRememberedChangedValue(fieldKey) {
      return changedFieldValuesByKey.get(fieldKey);
    }

    function getActiveSource(fieldKey) {
      const preferredSource = sourceByField[fieldKey];
      if (preferredSource === "human" || preferredSource === "ai") {
        return preferredSource;
      }
      if (!isEmptyValue(humanData[fieldKey])) return "human";
      if (!isEmptyValue(aiData[fieldKey])) return "ai";
      return "human";
    }

    function getStoreValue(fieldKey, source) {
      return source === "ai" ? aiData[fieldKey] : humanData[fieldKey];
    }

    function getEffectiveValue(fieldKey) {
      const preferredSource = sourceByField[fieldKey];
      const humanValue = humanData[fieldKey];
      const aiValue = aiData[fieldKey];
      if (preferredSource === "human") {
        if (!isEmptyValue(humanValue)) return humanValue;
        if (!isEmptyValue(aiValue)) return aiValue;
        return humanValue ?? "";
      }
      if (preferredSource === "ai") {
        if (!isEmptyValue(aiValue)) return aiValue;
        if (!isEmptyValue(humanValue)) return humanValue;
        return aiValue ?? "";
      }
      if (!isEmptyValue(humanValue)) return humanValue;
      if (!isEmptyValue(aiValue)) return aiValue;
      return "";
    }

    function ensureTaskStartTimestamp() {
      if (!taskStartTimestamp) {
        taskStartTimestamp = new Date().toISOString();
      }
    }


    function buildFieldSourceDebugSnapshot(fieldKey) {
      return {
        fieldKey,
        sourceByField: sourceByField[fieldKey] || "",
        activeSource: getActiveSource(fieldKey),
        humanValue: humanData[fieldKey],
        aiValue: aiData[fieldKey],
        effectiveValue: getEffectiveValue(fieldKey),
        humanTouched: humanTouchedFieldKeys.has(fieldKey),
        changedKey: changedFieldKeys.has(fieldKey),
        rememberedChanged: changedFieldValuesByKey.has(fieldKey),
        aiExplicit: aiExplicitFieldKeys.has(fieldKey)
      };
    }

    function setHumanValue(fieldKey, value, field, displayValue, options = {}) {
      ensureTaskStartTimestamp();
      humanData[fieldKey] = value;
      if (String(options?.reason || "").toLowerCase() === "user-edit") {
        humanTouchedFieldKeys.add(fieldKey);
      }
      sourceByField[fieldKey] = "human";
      updateEffectiveState(fieldKey, field, displayValue);
      updateAiVisuals(fieldKey);
      updateToolbarStatus();
    }

    function updateEffectiveState(fieldKey, field, displayValue) {
      ensureTaskStartTimestamp();
      const effectiveValue = getEffectiveValue(fieldKey);
      state.values[fieldKey] = effectiveValue;
      let validationValue = effectiveValue;
      if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(effectiveValue)) {
        const stagedFiles = state.fileBuffers[fieldKey] || [];
        if (stagedFiles.length) {
          validationValue = ["__file_selected__"];
        }
      }
      const error = validateField(field, validationValue);
      state.errors[fieldKey] = error;
      state.validMap[fieldKey] = !error;
      emit("onFieldChange", {
        key: fieldKey,
        value: effectiveValue,
        displayValue: displayValue ?? effectiveValue,
        source: getActiveSource(fieldKey),
        isValid: !error
      });
      if (state.config) {
        updateSubmitState(state.config);
      }
      debounceFormChange();
    }

    function updateToolbarStatus() {
      const aiCount = Object.values(aiData).filter((value) => !isEmptyValue(value)).length;
      const humanCount = Object.entries(humanData).filter(([key, value]) => {
        return sourceByField[key] === "human" && !isEmptyValue(value);
      }).length;
      aiFieldCountEl.textContent = `AI alan sayısı: ${aiCount}`;
      humanFieldCountEl.textContent = `Human değiştirilen alan sayısı: ${humanCount}`;
    }

    const typeMetaMap = {
      text: { iconKey: "text", label: "Text" },
      textarea: { iconKey: "text", label: "Textarea" },
      email: { iconKey: "mail", label: "Email" },
      phone: { iconKey: "phone", label: "Phone" },
      url: { iconKey: "text", label: "URL" },
      integer: { iconKey: "hash", label: "Integer" },
      number: { iconKey: "hash", label: "Number" },
      decimal: { iconKey: "hash", label: "Decimal" },
      currency: { iconKey: "hash", label: "Currency" },
      percent: { iconKey: "hash", label: "Percent" },
      boolean: { iconKey: "check", label: "Boolean" },
      dropdown: { iconKey: "chevron", label: "Dropdown" },
      date: { iconKey: "calendar", label: "Date" },
      time: { iconKey: "clock", label: "Time" },
      datetime: { iconKey: "calendar", label: "Datetime" },
      file: { iconKey: "paperclip", label: "File" },
      image: { iconKey: "image", label: "Image" },
      multifile: { iconKey: "paperclip", label: "Multi file" }
    };

    const displayTypeMetaMap = {
      "text (long)": { iconKey: "text", label: "Text (long)" },
      "multiline text": { iconKey: "text", label: "Multiline text" },
      "e-mail": { iconKey: "mail", label: "E-mail" },
      "image&pdf": { iconKey: "paperclip", label: "Image&Pdf" },
      reference: { iconKey: "text", label: "Reference" },
      embed: { iconKey: "text", label: "Embed" },
      user: { iconKey: "text", label: "User" },
      "sys.cf": { iconKey: "text", label: "Sys.cf" },
      "action.cf": { iconKey: "text", label: "Action.cf" }
    };

    function renderIcon(iconKey) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("fill", "none");
      svg.setAttribute("stroke", "currentColor");
      svg.setAttribute("stroke-width", "1.8");
      svg.setAttribute("stroke-linecap", "round");
      svg.setAttribute("stroke-linejoin", "round");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");

      const setPath = (d) => {
        path.setAttribute("d", d);
        svg.appendChild(path);
      };

      switch (iconKey) {
        case "calendar":
          setPath("M7 3v4M17 3v4M4 9h16M5 7h14a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1z");
          break;
        case "chevron":
          setPath("M6 9l6 6 6-6");
          break;
        case "hash":
          setPath("M8 3L6 21M18 3l-2 18M4 8h16M3 16h16");
          break;
        case "paperclip":
          setPath("M16 4l-7 7a4 4 0 0 0 6 6l6-6a3 3 0 1 0-4.5-4.5l-6.5 6.5");
          break;
        case "clock":
          circle.setAttribute("cx", "12");
          circle.setAttribute("cy", "12");
          circle.setAttribute("r", "9");
          svg.appendChild(circle);
          setPath("M12 7v5l3 3");
          break;
        case "phone":
          setPath("M6.5 4.5h2.6l1.2 3.2-1.7 1.1a15.2 15.2 0 0 0 6.8 6.8l1.1-1.7 3.2 1.2v2.6a1.5 1.5 0 0 1-1.7 1.5A16.5 16.5 0 0 1 4.9 6.2 1.5 1.5 0 0 1 6.5 4.5z");
          break;
        case "mail":
          setPath("M4 7h16v10H4z");
          const mailPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
          mailPath.setAttribute("d", "M4 8l8 6 8-6");
          mailPath.setAttribute("stroke", "currentColor");
          mailPath.setAttribute("stroke-width", "1.8");
          mailPath.setAttribute("stroke-linecap", "round");
          mailPath.setAttribute("stroke-linejoin", "round");
          mailPath.setAttribute("fill", "none");
          svg.appendChild(mailPath);
          break;
        case "user":
          circle.setAttribute("cx", "12");
          circle.setAttribute("cy", "8");
          circle.setAttribute("r", "3");
          svg.appendChild(circle);
          const shoulder = document.createElementNS("http://www.w3.org/2000/svg", "path");
          shoulder.setAttribute("d", "M5 19c1.8-3 4.1-4.5 7-4.5S17.2 16 19 19");
          shoulder.setAttribute("stroke", "currentColor");
          shoulder.setAttribute("stroke-width", "1.8");
          shoulder.setAttribute("stroke-linecap", "round");
          shoulder.setAttribute("stroke-linejoin", "round");
          shoulder.setAttribute("fill", "none");
          svg.appendChild(shoulder);
          break;
        case "check":
          setPath("M5 12l4 4 10-10");
          break;
        case "image":
          setPath("M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1z");
          const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          dot.setAttribute("cx", "8");
          dot.setAttribute("cy", "9");
          dot.setAttribute("r", "1.5");
          svg.appendChild(dot);
          const mountain = document.createElementNS("http://www.w3.org/2000/svg", "path");
          mountain.setAttribute("d", "M4 17l5-5 3 3 4-4 4 4");
          mountain.setAttribute("stroke", "currentColor");
          mountain.setAttribute("stroke-width", "1.8");
          mountain.setAttribute("stroke-linecap", "round");
          mountain.setAttribute("stroke-linejoin", "round");
          mountain.setAttribute("fill", "none");
          svg.appendChild(mountain);
          break;
        case "text":
        default:
          setPath("M5 6h14M12 6v12");
          break;
      }
      return svg;
    }

    function getTypeMeta(field) {
      const displayKey = String(field.displayType || "").toLowerCase();
      return displayTypeMetaMap[displayKey] || typeMetaMap[field.type] || { iconKey: "text", label: field.type || "text" };
    }

    function normalizeStageType(stageType) {
      if (!stageType) return "";
      return String(stageType).trim().toLowerCase();
    }

    function isInnerStageType(stageType) {
      return normalizeStageType(stageType) === "innerstage";
    }

    function isFieldRequired(field) {
      return Boolean(field.required) || normalizeStageType(field.stageType) === "mandatory";
    }

    function getMergedValidationValue(field) {
      return getEffectiveValue(field.key);
    }

    function isImageLike(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith("image/")) return true;
      if (file.url && String(file.url).startsWith("data:image/")) return true;
      if (file.url) {
        return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(file.url);
      }
      return false;
    }

    function isDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:");
    }

    function isPdfDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:application/pdf");
    }

    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        if (!file) {
          resolve("");
          return;
        }
        const reader = new FileReader();
        reader.onload = () => resolve(typeof reader.result === "string" ? reader.result : "");
        reader.onerror = () => reject(reader.error || new Error("file read error"));
        reader.readAsDataURL(file);
      });
    }

    function isCompressibleImageType(contentType) {
      const type = String(contentType || "").toLowerCase();
      return ["image/jpeg", "image/jpg", "image/png", "image/webp"].includes(type);
    }

    function loadImageBitmapOrElement(file) {
      return new Promise(async (resolve, reject) => {
        try {
          if (typeof createImageBitmap === "function") {
            try {
              const bmp = await createImageBitmap(file, { imageOrientation: "from-image" });
              resolve({ image: bmp, width: bmp.width, height: bmp.height, close: () => bmp.close?.() });
              return;
            } catch (_) {
              const bmp = await createImageBitmap(file);
              resolve({ image: bmp, width: bmp.width, height: bmp.height, close: () => bmp.close?.() });
              return;
            }
          }
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({ image: img, width: img.naturalWidth || img.width, height: img.naturalHeight || img.height, close: () => {} });
          };
          img.onerror = (err) => {
            URL.revokeObjectURL(url);
            reject(err || new Error("image load failed"));
          };
          img.src = url;
        } catch (error) {
          reject(error);
        }
      });
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob || null), type, quality);
      });
    }

    async function maybeCompressImageFile(file) {
      if (!file || !isCompressibleImageType(file.type)) return file;
      if (file.size < 400 * 1024) return file;

      const loaded = await loadImageBitmapOrElement(file);
      const originalWidth = loaded.width || 0;
      const originalHeight = loaded.height || 0;
      if (originalWidth <= 1200 && originalHeight <= 1200) {
        loaded.close?.();
        return file;
      }

      const maxWidth = 1800;
      const maxHeight = 1800;
      const scale = Math.min(1, maxWidth / originalWidth, maxHeight / originalHeight);
      const targetWidth = Math.max(1, Math.round(originalWidth * scale));
      const targetHeight = Math.max(1, Math.round(originalHeight * scale));

      const canvas = document.createElement("canvas");
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      const ctx = canvas.getContext("2d", { alpha: file.type === "image/png" });
      if (!ctx) {
        loaded.close?.();
        return file;
      }
      ctx.drawImage(loaded.image, 0, 0, targetWidth, targetHeight);
      loaded.close?.();

      const type = String(file.type || "").toLowerCase();
      const outputType = type === "image/jpg" ? "image/jpeg" : type;
      const quality = outputType === "image/jpeg" || outputType === "image/webp" ? 0.82 : undefined;
      const compressedBlob = await canvasToBlob(canvas, outputType, quality);
      if (!compressedBlob || !compressedBlob.size) return file;
      if (compressedBlob.size >= file.size) return file;

      return new File([compressedBlob], file.name, {
        type: outputType,
        lastModified: file.lastModified || Date.now()
      });
    }

    function isLikelyBase64(value) {
      if (typeof value !== "string") return false;
      if (value.length < 60) return false;
      if (value.includes("://")) return false;
      if (value.startsWith("data:")) return false;
      return /^[A-Za-z0-9+/=\r\n]+$/.test(value);
    }

    function normalizeFileValueForPreview(field, value) {
      if (!value || typeof value !== "string") return value;
      if (field.type === "image" && isLikelyBase64(value)) {
        return `data:image/*;base64,${value}`;
      }
      return value;
    }

    function parseInitialFiles(initialValue, allowMultiple, field) {
      if (!initialValue) return [];
      let values = Array.isArray(initialValue) ? initialValue : [initialValue];
      if (!allowMultiple && values.length > 1) {
        values = [values[0]];
      }
      values = values.map((value) => normalizeFileValueForPreview(field, value));
      return values
        .filter((val) => typeof val === "string")
        .map((url) => ({
          url,
          name: isDataUrl(url) ? (isPdfDataUrl(url) ? "dosya.pdf" : "gorsel") : url.split("/").pop() || "dosya",
          size: 0,
          type: isImageLike({ url }) ? "image/*" : isPdfDataUrl(url) ? "application/pdf" : "",
          lastModified: null,
          preview: url
        }));
    }

    function resolveTokenValue(rawValue, field, config) {
      if (rawValue === "$TODAY") {
        return getDateFromIso(getCurrentDateTime(config));
      }
      if (rawValue === "$NOW") {
        return getCurrentDateTime(config);
      }
      if (rawValue === "$CURRENT_TIME") {
        return getTimeFromIso(getCurrentDateTime(config));
      }
      return rawValue;
    }

    function decodeEscapedTextValue(value) {
      if (typeof value !== "string") return value;
      return value
        .replace(/\\r\\n/g, "\n")
        .replace(/\\n/g, "\n")
        .replace(/\\r/g, "\n")
        .replace(/\\t/g, "\t");
    }

    function normalizeMultiSelectToken(value) {
      if (value === null || value === undefined) return "";
      let token = decodeEscapedTextValue(String(value)).trim();
      if (!token) return "";
      if ((token.startsWith('"') && token.endsWith('"')) || (token.startsWith("'") && token.endsWith("'"))) {
        token = token.slice(1, -1).trim();
      }
      token = token
        .replace(/^\\+"|"\\+$/g, "")
        .replace(/^\\+'|'\\+$/g, "")
        .trim();
      token = token.replace(/^\[/, "").replace(/\]$/, "").trim();
      if ((token.startsWith('"') && token.endsWith('"')) || (token.startsWith("'") && token.endsWith("'"))) {
        token = token.slice(1, -1).trim();
      }
      token = token
        .replace(/^\\+"|"\\+$/g, "")
        .replace(/^\\+'|'\\+$/g, "")
        .trim();
      return token;
    }

    function parseJsonArrayString(value) {
      if (typeof value !== "string") return null;
      let candidate = value.trim();
      for (let attempt = 0; attempt < 4; attempt += 1) {
        if (candidate.startsWith("[") && candidate.endsWith("]")) {
          try {
            const parsed = JSON.parse(candidate);
            if (Array.isArray(parsed)) return parsed;
            if (typeof parsed === "string") {
              candidate = parsed.trim();
              continue;
            }
            return null;
          } catch (error) {
            const unescaped = candidate
              .replace(/\\"/g, '"')
              .replace(/\\'/g, "'");
            if (unescaped !== candidate) {
              candidate = unescaped.trim();
              continue;
            }
            return null;
          }
        }
        if ((candidate.startsWith('"') && candidate.endsWith('"')) || (candidate.startsWith("'") && candidate.endsWith("'"))) {
          candidate = candidate.slice(1, -1).trim();
          continue;
        }
        return null;
      }
      return null;
    }


    function parseFlexibleMultiSelect(value) {
      if (Array.isArray(value)) {
        return Array.from(new Set(value.map((entry) => normalizeMultiSelectToken(entry)).filter(Boolean)));
      }
      if (typeof value !== "string") return [];
      const trimmed = decodeEscapedTextValue(value).trim();
      if (!trimmed) return [];
      const parsedArray = parseJsonArrayString(trimmed);
      if (Array.isArray(parsedArray)) {
        return Array.from(new Set(parsedArray.map((entry) => normalizeMultiSelectToken(entry)).filter(Boolean)));
      }
      return Array.from(new Set(
        trimmed
          .split(/[;,|\n]/g)
          .map((entry) => normalizeMultiSelectToken(entry))
          .filter(Boolean)
      ));
    }
    function normalizeJsonValueForField(field, value, config) {
      if (value === null || value === undefined) return "";
      let resolved = resolveTokenValue(value, field, config);
      if (field.type === "date") {
        resolved = normalizeDateInput(String(resolved), config);
        return resolved;
      }
      if (field.type === "time") {
        resolved = normalizeTimeInput(String(resolved));
        return resolved;
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(resolved), config);
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        return normalizeNumberInput(resolved);
      }
      if (field.type === "boolean") {
        return normalizeBooleanInput(resolved);
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        return parseFlexibleMultiSelect(resolved);
      }
      if (["textarea", "json", "text"].includes(field.type) && typeof resolved === "string") {
        return decodeEscapedTextValue(resolved);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(resolved)) return resolved.filter((val) => typeof val === "string");
        if (typeof resolved === "string") return resolved;
        return "";
      }
      return resolved;
    }

    function normalizeMultiValue(value) {
      if (Array.isArray(value)) {
        return Array.from(new Set(value.map((entry) => normalizeMultiSelectToken(entry)).filter(Boolean))).sort();
      }
      if (typeof value === "string") {
        return parseFlexibleMultiSelect(value).sort();
      }
      return [];
    }

    function normalizeValueForComparison(field, value, config) {
      if (isEmptyValue(value)) return "";
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        const numeric = Number(normalizeNumberInput(value));
        return Number.isNaN(numeric) ? "" : numeric;
      }
      if (field.type === "date") {
        return normalizeDateInput(String(value), config);
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(value), config);
      }
      if (field.type === "time") {
        return normalizeTimeInput(String(value));
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        return normalizeMultiValue(value);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(value)) {
          return Array.from(new Set(value.filter((entry) => typeof entry === "string"))).sort();
        }
        return typeof value === "string" ? value : "";
      }
      if (field.type === "boolean") {
        return normalizeBooleanInput(value);
      }
      return value;
    }

    function updateAiVisuals(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const aiValue = aiData[fieldKey];
      const hasAi = !isEmptyValue(aiValue);
      const activeSource = getActiveSource(fieldKey);
      const humanValue = humanData[fieldKey];
      const hasHuman = !isEmptyValue(humanValue);
      const hasConflict = hasAi && hasHuman && areValuesDifferent(humanValue, aiValue);
      ref._hasAi = hasAi;
      ref.aiBadge.style.display = hasAi ? "inline-flex" : "none";
      ref.aiBadge.classList.toggle("is-active", activeSource === "ai");
      ref.aiBadge.classList.toggle("is-passive", activeSource !== "ai" && hasAi);
      ref.control.classList.toggle("ai-active", activeSource === "ai" && hasAi);
      ref.aiPill.style.display = "none";
      const badgeIcon = ref.aiBadge.querySelector("img, svg");
      if (badgeIcon) {
        if (activeSource === "ai") {
          badgeIcon.outerHTML = `<img src="https://upload.wikimedia.org/wikipedia/commons/0/04/ChatGPT_logo.svg" alt="ChatGPT" />`;
          ref.aiBadge.title = "İnsan moduna geç";
        } else {
          badgeIcon.outerHTML = "";
          ref.aiBadge.append(renderIcon("user"));
          ref.aiBadge.title = "AI'ye dön";
        }
      }
      if (ref.applyAiBtn) {
        ref.applyAiBtn.style.display = "none";
      }
      if (ref.revertAiBtn) {
        ref.revertAiBtn.style.display = "none";
      }
      if (ref.conflictChip) {
        ref._hasConflict = hasConflict;
      }
      if (ref.conflictPopover) {
        if (hasConflict) {
          ref.conflictPopover.querySelector("[data-conflict-human]").textContent = formatValueForDisplay(humanValue);
          ref.conflictPopover.querySelector("[data-conflict-ai]").textContent = formatValueForDisplay(aiValue);
        } else {
          ref.conflictPopover.classList.remove("open");
        }
      }
      refreshConflictSlotLayout();
    }

    function updateFieldDisplayValue(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const value = getEffectiveValue(fieldKey);
      if (ref.setValue) {
        ref.setValue(value);
      }
      updateAiVisuals(fieldKey);
      updateEffectiveState(fieldKey, ref.field);
    }

    function refreshAllFields() {
      Object.keys(state.fieldRefs).forEach((fieldKey) => {
        updateFieldDisplayValue(fieldKey);
      });
      if (IS_EDITING_MODE) {
        runEditModeFilterRender();
        if (formEl) formEl.style.display = "none";
      }
      updateToolbarStatus();
      if (state.config) {
        updateSubmitState(state.config);
      }
    }

    function loadJsonSafeToForm(kind, jsonObj, meta = {}) {
      if (!jsonObj || !state.config) return;
      const invocationStack = String(new Error().stack || "")
        .split("\n")
        .slice(1, 6)
        .map((line) => line.trim());
      logPredictDebug("load-json-invocation", {
        kind,
        meta,
        payloadKeyCount: Object.keys(jsonObj || {}).length,
        payloadKeySample: Object.keys(jsonObj || {}).slice(0, 30),
        invocationStack,
        startSignal: readStartSignalValue(),
        isFormSaving,
        hasSeenStartSignal,
        lastStartParamWasTrue,
        sourceByFieldSample: Object.entries(sourceByField || {}).slice(0, 30),
        humanTouchedKeys: Array.from(humanTouchedFieldKeys || []),
        changedKeys: Array.from(changedFieldKeys || [])
      });
      const keyMap = buildFieldKeyMap();

      const applied = [];
      const unmatched = [];
      const availableAliases = Array.from(keyMap.keys());
      Object.entries(jsonObj).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) {
          unmatched.push(jsonKey);
          console.warn(`Eşleşmeyen JSON key: ${jsonKey}`);
          return;
        }
        const field = state.config.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        const normalized = normalizeJsonValueForField(field, rawValue, state.config);
        if (kind === "ai") {
          aiData[fieldKey] = normalized;
          aiExplicitFieldKeys.add(fieldKey);
        } else {
          humanData[fieldKey] = normalized;
          sourceByField[fieldKey] = "human";
        }
        applied.push({ jsonKey, fieldKey, kind, rawValue, normalized, sourceSnapshot: buildFieldSourceDebugSnapshot(fieldKey) });
      });
      traceAutosave("loadJsonSafeToForm", {
        kind,
        incomingKeyCount: Object.keys(jsonObj || {}).length,
        appliedKeyCount: applied.length,
        unmatchedKeyCount: unmatched.length,
        unmatchedKeys: unmatched,
        applied
      });
      if (kind === "ai") {
        hasAiHydratedData = applied.some((entry) => !isEmptyValue(aiData[entry.fieldKey])) || hasAiHydratedData;
      }
      logPredictDebug("json-load-summary", {
        kind,
        meta,
        incomingKeyCount: Object.keys(jsonObj || {}).length,
        appliedKeyCount: applied.length,
        unmatchedKeyCount: unmatched.length,
        unmatchedKeys: unmatched,
        availableAliasSample: availableAliases.slice(0, 80),
        applied,
        sourceSummary: (state.config?.fields || []).map((field) => buildFieldSourceDebugSnapshot(field.key))
      });
      refreshAllFields();
      if (state.config) {
        updateSubmitState(state.config);
      }
      const dirtyNow = reconcileDirtyTracking(`loadJsonSafeToForm:${kind}`);
      if (hasSeenStartSignal && lastStartParamWasTrue && dirtyNow) {
        hasChangesSinceStartOpen = true;
        persistStartFlowState();
      }
      const startSignalNow = readStartSignalValue();
      const shouldSubmitWhileClosed = Boolean(
        hasSeenStartSignal
        && startSignalNow === false
        && !lastStartParamWasTrue
        && dirtyNow
        && !isFormSaving
      );
      if (shouldSubmitWhileClosed) {
        logStartState("load-json-trigger-submit-while-start-closed", {
          kind,
          dirtyNow,
          trigger: `json-load:${kind}:start-closed`
        });
        runSubmitFlow({
          autosave: true,
          forceSubmit: true,
          trigger: `json-load:${kind}:start-closed`,
          modeHint: getSubmitModeHint()
        });
      }

      if (kind === "ai") {
        maybeRunAutosaveOnStartClose("ai-hydrate");
      }

    }

    function applyScenario({ name, column, human, ai }) {
      emit("debug:scenario", { name, column, human, ai });
      applyColumnJson(column);
      humanData = {};
      aiData = {};
      aiExplicitFieldKeys = new Set();
      sourceByField = {};
      humanTouchedFieldKeys = new Set();
      if (human) {
        loadJsonSafeToForm("human", human, { source: "applyScenario", stage: "human" });
      }
      if (ai) {
        loadJsonSafeToForm("ai", ai, { source: "applyScenario", stage: "ai" });
      }
      initializeSourceByFieldFromAi();
      refreshAllFields();
      if (ai && human) {
        openExportModal("export");
      } else if (ai) {
        openExportModal("ai");
      } else if (human) {
        openExportModal("human");
      } else {
        openExportModal("column");
      }
    }

    function initializeSourceByFieldFromAi() {
      if (!state.config) return;
      const sourceInitDetails = [];
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        const hasExplicitAi = aiExplicitFieldKeys.has(field.key);
        const hasHumanPriority =
          humanTouchedFieldKeys.has(field.key)
          || changedFieldKeys.has(field.key)
          || changedFieldValuesByKey.has(field.key);
        if (hasHumanPriority) {
          sourceByField[field.key] = "human";
          sourceInitDetails.push({ ...buildFieldSourceDebugSnapshot(field.key), reason: "human-priority" });
          return;
        }
        sourceByField[field.key] = (hasExplicitAi || !isEmptyValue(aiValue)) ? "ai" : "human";
        sourceInitDetails.push({ ...buildFieldSourceDebugSnapshot(field.key), reason: "ai-default-or-empty" });
      });
      logPredictDebug("initialize-source-by-ai:result", {
        fieldCount: sourceInitDetails.length,
        details: sourceInitDetails
      });
    }

    function normalizeAllowMultiple(value) {
      if (typeof value === "string") {
        return ["yes", "true", "1"].includes(value.trim().toLowerCase());
      }
      return Boolean(value);
    }

    function normalizeColumnType(rawType, allowMultipleValue) {
      const raw = String(rawType || "").trim();
      const normalizedRaw = raw.toLowerCase();
      let allowMultiple = normalizeAllowMultiple(allowMultipleValue);
      if (["single_select", "multi_select", "dropdown"].includes(normalizedRaw)) {
        if (normalizedRaw === "multi_select") {
          allowMultiple = true;
        }
        return { type: "dropdown", allowMultiple, displayType: raw || "dropdown" };
      }
      if (normalizedRaw === "checkbox") {
        return { type: "boolean", allowMultiple, displayType: raw || "checkbox" };
      }
      if (normalizedRaw === "text (long)" || normalizedRaw === "multiline text") {
        return { type: "textarea", allowMultiple, displayType: raw || "text (long)" };
      }
      if (normalizedRaw === "e-mail") {
        return { type: "email", allowMultiple, displayType: raw || "e-mail" };
      }
      if (normalizedRaw === "image&pdf") {
        return { type: allowMultiple ? "multifile" : "file", allowMultiple, displayType: raw || "image&pdf" };
      }
      if (["reference", "embed", "user", "sys.cf", "action.cf"].includes(normalizedRaw)) {
        return { type: "text", allowMultiple, displayType: raw || normalizedRaw };
      }
      if (normalizedRaw === "phone") {
        return { type: "phone", allowMultiple, displayType: raw || "phone" };
      }
      if (normalizedRaw === "number") {
        return { type: "number", allowMultiple, displayType: raw || "number" };
      }
      if (normalizedRaw === "date") {
        return { type: "date", allowMultiple, displayType: raw || "date" };
      }
      if (normalizedRaw === "text") {
        return { type: "text", allowMultiple, displayType: raw || "text" };
      }
      return { type: raw || "text", allowMultiple, displayType: raw || "text" };
    }

    function buildConfigFromColumnJson(columnData) {
      if (!columnData) return null;
      const columns = columnData.columns || [];
      const fields = columns.reduce((acc, column, index) => {
        const fieldName = column.id || `field_${index + 1}`;
        const normalized = normalizeColumnType(column.type, column.multiple);
        const stageType = column.stageType || "optional";
        if (isInnerStageType(stageType)) {
          return acc;
        }
        acc.push({
          key: fieldName,
          fieldName,
          label: column.header || fieldName,
          type: normalized.type,
          displayType: normalized.displayType,
          required: normalizeStageType(stageType) === "mandatory" || Boolean(column.required),
          stageType,
          allowMultiple: Boolean(column.multiple),
          readOnly: Boolean(column.readOnly),
          options: Array.isArray(column.source) ? column.source.map((value) => ({ value, label: value })) : [],
          default: column.default,
          ui: column.ui || {}
        });
        return acc;
      }, []);
      return {
        fields,
        currentDateTimeISO: columnData.currentDateTimeISO || defaultSchema.currentDateTimeISO,
        locale: columnData.locale || "tr-TR",
        timezone: columnData.timezone || "Europe/Istanbul",
        mode: columnData.mode || "create",
        requiredPolicy: defaultSchema.requiredPolicy,
        showInlineHelp: defaultSchema.showInlineHelp,
        autoFocusFirstInvalid: defaultSchema.autoFocusFirstInvalid
      };
    }

    function getEditModeBaselinePayload() {
      const bubbleData = readCurrentBubbleDataObject() || {};
      const configInitial = state.config?.initialValues || {};
      return { ...configInitial, ...bubbleData };
    }

    function captureInitialSnapshot() {
      if (initialSnapshot || !state.config) return;
      const baselinePayload = IS_EDITING_MODE ? getEditModeBaselinePayload() : MANUAL_DATA_JSON;
      initialSnapshot = buildBaselineSnapshot(baselinePayload);
    }

    function readFieldValueFromDom(field) {
      const ref = state.fieldRefs[field.key];
      if (!ref) return getEffectiveValue(field.key);

      if (["file", "image", "multifile"].includes(field.type)) {
        return getCurrentValueForField(field);
      }

      if (field.type === "dropdown" && field.allowMultiple) {
        const checked = Array.from(ref.control.querySelectorAll('.multiselect-options input[type="checkbox"]:checked'));
        return checked.map((el) => normalizeMultiSelectToken(el.value || el.dataset.value || "")).filter(Boolean);
      }

      const input = ref.inputEl || ref.control.querySelector("input, textarea, select");
      if (!input) return getCurrentValueForField(field);

      if (field.type === "boolean") {
        return Boolean(input.checked);
      }

      if (field.type === "date") {
        return normalizeDateInput(String(input.value || ""), state.config || {});
      }

      if (field.type === "time") {
        return parseTimeDisplay(String(input.value || "")) || String(input.value || "");
      }

      return input.value;
    }

    function buildLiveFormSnapshotFromDom() {
      const payload = {};
      const fieldDebug = [];
      (state.config?.fields || []).forEach((field) => {
        const uiValue = readFieldValueFromDom(field);
        const normalizedUiValue = normalizeValueForComparison(field, uiValue, state.config);
        const effectiveValueFromState = getCurrentValueForField(field);
        const normalizedEffectiveValue = normalizeValueForComparison(field, effectiveValueFromState, state.config);
        const useEffectiveFallback = isEmptyValue(normalizedUiValue) && !isEmptyValue(normalizedEffectiveValue);
        const finalValue = useEffectiveFallback ? normalizedEffectiveValue : normalizedUiValue;
        payload[field.key] = finalValue;
        fieldDebug.push({
          fieldKey: field.key,
          uiValue,
          normalizedUiValue,
          effectiveValueFromState,
          normalizedEffectiveValue,
          useEffectiveFallback,
          finalValue,
          ...buildFieldSourceDebugSnapshot(field.key)
        });
      });
      logPredictDebug("build-live-form-snapshot", {
        fieldCount: fieldDebug.length,
        fields: fieldDebug
      });
      return payload;
    }

    function applyColumnJson(columnData, { persistRestore = true, deferPendingSubmitFlush = false } = {}) {
      traceAutosave("apply-column-json", {
        isEditingMode: IS_EDITING_MODE,
        hasColumnData: Boolean(columnData),
        columnCount: Array.isArray(columnData?.columns) ? columnData.columns.length : 0
      });
      columnJson = columnData;
      if (persistRestore && columnData) restoreColumnJson = columnData;
      if (!columnJson) {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
        return;
      }
      columnWarning.style.display = "none";
      formContainer.style.display = "block";
      state.config = buildConfigFromColumnJson(columnJson);
      if (!state.config) return;
      renderForm(state.config);
      applyVersionVisibility();
      if (!deferPendingSubmitFlush) flushPendingSubmitAfterConfigReady();
    }

    function buildExportJson() {
      return buildLiveFormSnapshotFromDom();
    }

    function buildBaselineSnapshot(baselineData) {
      const baseline = baselineData || {};
      const snapshot = {};
      const keyMap = buildFieldKeyMap();
      Object.entries(baseline || {}).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) return;
        const field = state.config?.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        snapshot[fieldKey] = normalizeValueForComparison(field, rawValue, state.config);
      });

      (state.config?.fields || []).forEach((field) => {
        if (snapshot[field.key] !== undefined) return;
        const initialValue = getInitialValue(field, state.config || {});
        snapshot[field.key] = normalizeValueForComparison(field, initialValue, state.config);
      });

      return snapshot;
    }

    function getCurrentValueForField(field) {
      return getEffectiveValue(field.key);
    }

    function getCurrentNormalizedValue(field) {
      return normalizeValueForComparison(field, getCurrentValueForField(field), state.config);
    }

    function getUniqueChangedFieldDescriptors() {
      const byKey = new Map();
      (state.config?.fields || []).forEach((field) => {
        if (!field?.key) return;
        const isUserTrackedChange = changedFieldKeys.has(field.key) || changedFieldValuesByKey.has(field.key);
        if (!isUserTrackedChange) return;
        if (byKey.has(field.key)) return;
        byKey.set(field.key, field);
      });
      return Array.from(byKey.values());
    }

    function logDeltaComputation(kind, items) {
      traceAutosave(`delta-computation:${kind}`, {
        count: Array.isArray(items) ? items.length : 0,
        first10: Array.isArray(items) ? items.slice(0, 10) : []
      });
    }

    function collectChangedFieldDebugDetails() {
      const base = initialSnapshot || {};
      const details = [];
      getUniqueChangedFieldDescriptors().forEach((field) => {
        const jsonKey = field.key;
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        const baselineValue = base[jsonKey] ?? "";
        const changed = areValuesDifferent(baselineValue, currentValue);
        details.push({
          key: jsonKey,
          label: field.label || jsonKey,
          source: getActiveSource(field.key),
          baselineValue,
          currentValue,
          remembered: rememberedValue !== undefined,
          changed,
          includedValue: changed ? (isEmptyValue(currentValue) ? "" : currentValue) : undefined
        });
      });
      return details;
    }

    function traceChangedFieldComputation(label) {
      const details = collectChangedFieldDebugDetails();
      const changedOnly = details.filter((item) => item.changed);
      traceAutosave(label, {
        evaluatedFieldCount: details.length,
        changedFieldCount: changedOnly.length,
        changedKeys: changedOnly.map((item) => item.key),
        changedDetails: changedOnly,
        evaluationDetails: details
      });
    }

    function buildSubmitChangeDiagnostics() {
      const changedDetails = collectChangedFieldDebugDetails().filter((item) => item.changed);
      const aiChangedDetails = changedDetails.filter((item) => item.source === "ai");
      const humanChangedDetails = changedDetails.filter((item) => item.source === "human");
      return {
        changedFieldCount: changedDetails.length,
        changedKeys: changedDetails.map((item) => item.key),
        aiChangedFieldCount: aiChangedDetails.length,
        aiChangedKeys: aiChangedDetails.map((item) => item.key),
        humanChangedFieldCount: humanChangedDetails.length,
        humanChangedKeys: humanChangedDetails.map((item) => item.key),
        changedDetails
      };
    }

    function buildKeyValueListFromSources() {
      traceChangedFieldComputation("changed-field-evaluation:outputlist1");
      const entriesByKey = new Map();
      const base = initialSnapshot || {};
      getUniqueChangedFieldDescriptors().forEach((field) => {
        const jsonKey = field.key;
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        const baselineValue = base[jsonKey] ?? "";
        if (!areValuesDifferent(baselineValue, currentValue)) return;
        if (isEmptyValue(currentValue)) return;
        entriesByKey.set(jsonKey, `"${jsonKey}": ${JSON.stringify(currentValue)}`);
      });
      const entries = Array.from(entriesByKey.values());
      traceAutosave("buildKeyValueListFromSources", {
        entriesCount: entries.length,
        uniqueKeyCount: entriesByKey.size,
        entries
      });
      return entries;
    }

    function buildAddedCustomFields() {
      traceChangedFieldComputation("changed-field-evaluation:outputlist2");
      const entriesByKey = new Map();
      const base = initialSnapshot || {};
      getUniqueChangedFieldDescriptors().forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        const isFileField = ["file", "image", "multifile"].includes(String(field.type || "").toLowerCase());

        if (isFileField) {
          const initialUrls = getFileFieldUrlsFromValue(initialValue);
          const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
          const currentUrls = currentFiles
            .map((file) => (file && typeof file.url === "string" ? file.url : ""))
            .filter(Boolean);
          const hasNewFiles = currentFiles.some((file) => Boolean(file && file.raw));
          const hasAnyCurrentFileAction = currentUrls.length > 0 || hasNewFiles;
          if (initialUrls.length === 0 && hasAnyCurrentFileAction) {
            entriesByKey.set(jsonKey, field.label || jsonKey);
          }
          return;
        }

        if (!isEmptyValue(currentValue) && isEmptyValue(initialValue)) {
          entriesByKey.set(jsonKey, field.label || jsonKey);
        }
      });
      return Array.from(entriesByKey.values());
    }

    function buildDeletedFields() {
      traceChangedFieldComputation("changed-field-evaluation:outputlist3");
      const entriesByKey = new Map();
      const base = initialSnapshot || {};
      getUniqueChangedFieldDescriptors().forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        if (!isEmptyValue(initialValue) && isEmptyValue(currentValue)) {
          entriesByKey.set(jsonKey, jsonKey);
        }
      });
      const deleted = Array.from(entriesByKey.values());
      logDeltaComputation("deleted", deleted);
      return deleted;
    }

    function buildModifiedFields() {
      traceChangedFieldComputation("changed-field-evaluation:outputlist4");
      const entriesByKey = new Map();
      const base = initialSnapshot || {};
      getUniqueChangedFieldDescriptors().forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        const isFileField = ["file", "image", "multifile"].includes(String(field.type || "").toLowerCase());

        if (isFileField) {
          const initialUrls = Array.from(new Set(getFileFieldUrlsFromValue(initialValue))).sort();
          const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
          const currentUrls = Array.from(new Set(
            currentFiles
              .map((file) => (file && typeof file.url === "string" ? file.url : ""))
              .filter(Boolean)
          )).sort();
          const hasNewFiles = currentFiles.some((file) => Boolean(file && file.raw));
          const hasUrlChange = JSON.stringify(initialUrls) !== JSON.stringify(currentUrls);
          if (hasUrlChange || hasNewFiles) {
            entriesByKey.set(jsonKey, jsonKey);
          }
          return;
        }

        if (isEmptyValue(initialValue) || isEmptyValue(currentValue)) return;
        if (areValuesDifferent(initialValue, currentValue)) {
          entriesByKey.set(jsonKey, jsonKey);
        }
      });
      const modified = Array.from(entriesByKey.values());
      logDeltaComputation("modified", modified);
      return modified;
    }

    function toStringArray(value) {
      if (Array.isArray(value)) return value.filter((item) => typeof item === "string");
      if (typeof value === "string" && value) return [value];
      return [];
    }

    function getFileFieldUrlsFromValue(value) {
      return toStringArray(value).filter((entry) => typeof entry === "string" && /^(https?:\/\/|\/|data:)/i.test(entry));
    }

    function stripDataUrlPrefix(value) {
      if (typeof value !== "string") return "";
      const marker = ";base64,";
      const idx = value.indexOf(marker);
      if (idx >= 0) return value.slice(idx + marker.length);
      return value;
    }

    function buildOutput4String() {
      const items = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!["file", "multifile", "image"].includes(String(field.type || "").toLowerCase())) return;
        if (!changedFieldKeys.has(field.key)) return;
        const customFieldName = String(field.label || field.fieldName || field.key || "").trim();
        if (!customFieldName) return;

        const initialUrls = getFileFieldUrlsFromValue(base[field.key]);
        const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
        const keptFromCurrent = currentFiles
          .map((file) => (file && typeof file.url === "string" ? file.url : ""))
          .filter(Boolean);
        const keptSet = new Set(keptFromCurrent);
        const removedSet = new Set(initialUrls.filter((url) => !keptSet.has(url)));
        removedSet.forEach((url) => {
          if (keptSet.has(url)) removedSet.delete(url);
        });

        const newFiles = currentFiles
          .filter((file) => file && file.raw && typeof file.base64 === "string" && file.base64)
          .map((file) => ({
            filename: String(file.name || file.raw?.name || "dosya"),
            contentType: String(file.type || file.raw?.type || "application/octet-stream"),
            base64: stripDataUrlPrefix(file.base64)
          }));

        const keptUrls = Array.from(keptSet);
        const removedUrls = Array.from(removedSet);
        const initialSorted = Array.from(new Set(initialUrls)).sort();
        const keptSorted = Array.from(new Set(keptUrls)).sort();
        const hasUrlChange = JSON.stringify(initialSorted) !== JSON.stringify(keptSorted);
        const hasFileOperation = hasUrlChange || removedUrls.length > 0 || newFiles.length > 0;
        if (!hasFileOperation) return;

        items.push({
          customFieldName,
          keptUrls,
          removedUrls,
          newFiles
        });
      });

      if (!items.length) return null;
      return JSON.stringify({
        version: 1,
        items
      });
    }

    function getActivityType() {
      const hasPredictedData = Object.values(aiData).some((value) => !isEmptyValue(value));
      const hasAiUsage = (state.config?.fields || []).some((field) => {
        return getActiveSource(field.key) === "ai" && !isEmptyValue(aiData[field.key]);
      });
      return hasPredictedData && hasAiUsage ? "Stage complated/HITL" : "Stage complated";
    }

    function validateField(field, value) {
      if (isFieldRequired(field) && isEmptyValue(value)) {
        if (field.type === "boolean") {
          return "Zorunlu onay gerekir.";
        }
        return "Bu alan zorunlu.";
      }
      if (field.type === "email" && value) {
        if (!String(value).includes("@")) return "Geçerli bir e-posta girin.";
      }
      if (field.type === "phone" && value) {
        if (!/\d{10,}/.test(String(value).replace(/\D/g, ""))) return "Telefon formatı hatalı.";
      }
      if (field.type === "url" && value) {
        if (!/^https?:\/\//.test(String(value))) return "URL http(s):// ile başlamalı.";
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type) && value !== "") {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) return "Geçerli bir sayı girin.";
        if (field.min !== undefined && numeric < field.min) return `Minimum ${field.min}`;
        if (field.max !== undefined && numeric > field.max) return `Maksimum ${field.max}`;
        if (field.type === "percent" && (numeric < 0 || numeric > 100)) return "0-100 arası girin.";
      }
      if (["text", "textarea", "password", "email", "url"].includes(field.type) && value) {
        if (field.minLen && String(value).length < field.minLen) return `En az ${field.minLen} karakter.`;
        if (field.maxLen && String(value).length > field.maxLen) return `En fazla ${field.maxLen} karakter.`;
        if (field.pattern) {
          const regex = new RegExp(field.pattern);
          if (!regex.test(String(value))) return field.validate?.find((r) => r.name === "regex")?.message || "Format hatası.";
        }
      }
      if (["date", "datetime", "time"].includes(field.type) && value) {
        if (field.type === "date") {
          const normalized = normalizeDateInput(String(value), state.config || {});
          if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
            return "Tarih formatı gg.aa.yyyy veya yyyy-mm-dd olmalı.";
          }
          if (!isValidDateString(normalized)) {
            return "Geçerli bir tarih girin.";
          }
        }
        if (field.type === "time" && !isValidTimeString(String(value))) return "Saat formatı HH:mm olmalı.";
        if (field.type === "datetime" && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(String(value))) return "Tarih ve saat gerekli.";
      }
      return "";
    }

    function setFieldValue(key, value, field, displayValue, options = {}) {
      const origin = String(options?.origin || "human").trim().toLowerCase();
      logPredictDebug("set-field-value:start", {
        key,
        origin,
        incomingValue: value,
        displayValue,
        domValueBefore: readFieldValueFromDom(field),
        stateValueBefore: getCurrentValueForField(field),
        before: buildFieldSourceDebugSnapshot(key)
      });
      if (origin === "ai-hydrate") {
        aiData[key] = value;
        aiExplicitFieldKeys.add(key);
        if (sourceByField[key] !== "human" && !changedFieldKeys.has(key) && !changedFieldValuesByKey.has(key)) {
          sourceByField[key] = "ai";
        }
        updateEffectiveState(key, field, displayValue);
        logPredictDebug("set-field-value:ai-hydrate-applied", {
          key,
          origin,
          after: buildFieldSourceDebugSnapshot(key)
        });
        return;
      }
      setHumanValue(key, value, field, displayValue, { reason: "user-edit" });
      markFieldAsChanged(key, { origin: "human" });
      rememberChangedFieldValue(key, normalizeValueForComparison(field, getEffectiveValue(key), state.config));
      isFormDirty = computeDirtyState();
      logPredictDebug("set-field-value:human-applied", {
        key,
        origin,
        domValueAfter: readFieldValueFromDom(field),
        stateValueAfter: getCurrentValueForField(field),
        after: buildFieldSourceDebugSnapshot(key)
      });
    }

    function parseDataJsonSource(rawValue) {
      if (rawValue === null || rawValue === undefined) return null;
      if (typeof rawValue === "string") {
        const trimmed = rawValue.trim();
        if (!trimmed) return null;
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          return null;
        }
      }
      if (typeof rawValue === "object") return rawValue;
      return null;
    }

    function extractUniqueIdFromObject(candidate) {
      if (!candidate || Array.isArray(candidate) || typeof candidate !== "object") return "";
      const uniqueIdRaw = candidate.uniqueid ?? candidate.uniquieid ?? candidate.uniqueId ?? candidate.UniqueId;
      if (uniqueIdRaw !== null && uniqueIdRaw !== undefined) {
        return String(uniqueIdRaw).trim();
      }
      if (candidate.data && typeof candidate.data === "object") {
        const nested = candidate.data.uniqueid ?? candidate.data.uniquieid ?? candidate.data.uniqueId ?? candidate.data.UniqueId;
        if (nested !== null && nested !== undefined) {
          return String(nested).trim();
        }
      }
      return "";
    }

    function extractUniqueIdFromString(rawValue) {
      const parsed = parseDataJsonSource(rawValue);
      const parsedUniqueId = extractUniqueIdFromObject(parsed);
      if (parsedUniqueId) return parsedUniqueId;
      const text = String(rawValue || "");
      const match = text.match(/(?:"|')(?:uniqueid|uniquieid|uniqueId|UniqueId)(?:"|')\s*:\s*(?:"|')([^"']+)(?:"|')/i);
      return match ? String(match[1] || "").trim() : "";
    }

    function extractUniqueId(rawValue) {
      if (typeof rawValue === "string") return extractUniqueIdFromString(rawValue);
      return extractUniqueIdFromObject(rawValue);
    }

    function extractBubbleDataObject(rawValue) {
      const parsed = parseDataJsonSource(rawValue);
      if (!parsed || typeof parsed !== "object") return null;
      if (Array.isArray(parsed)) return null;
      if (parsed.data && typeof parsed.data === "object" && !Array.isArray(parsed.data)) {
        return parsed.data;
      }
      return parsed;
    }

    function readCurrentBubbleDataObject() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.BUBBLE_DATA_JSON,
        inputs.bubble_data_json,
        window.BUBBLE_DATA_JSON,
        MANUAL_DATA_JSON
      ];
      for (const candidate of candidates) {
        const obj = extractBubbleDataObject(candidate);
        if (obj) return obj;
      }
      return null;
    }

    function readCurrentPredictedDataObject() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.PREDICTED_JSON,
        inputs.predicted_json,
        window.BUBBLE_PREDICTED_JSON,
        MANUAL_PREDICTED_JSON
      ];
      for (const candidate of candidates) {
        const obj = extractBubbleDataObject(candidate);
        if (obj) return obj;
      }
      return null;
    }

    function isRemountRehydrateReadyForAutosave() {
      const predictedObj = readCurrentPredictedDataObject();
      const predictedKeyCount = predictedObj && typeof predictedObj === "object" ? Object.keys(predictedObj).length : 0;
      if (predictedKeyCount === 0) return true;
      return aiExplicitFieldKeys.size > 0;
    }


    function safeStringify(value) {
      try {
        return JSON.stringify(value);
      } catch (error) {
        return "";
      }
    }

    function readCurrentBubbleDataSignature() {
      const dataObj = readCurrentBubbleDataObject();
      if (!dataObj || typeof dataObj !== "object") return "";
      return safeStringify(dataObj);
    }


    function readCurrentColumnJsonObject() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.COLUMN_JSON,
        inputs.column_json,
        window.BUBBLE_COLUMN_JSON,
        MANUAL_COLUMN_JSON
      ];
      for (const candidate of candidates) {
        const parsed = parseDataJsonSource(candidate);
        if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) continue;
        if (Array.isArray(parsed.columns)) return parsed;
      }
      return null;
    }


    function applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, uniqueId, incomingColumnJson) {
      const incomingPredictedData = readCurrentPredictedDataObject();
      const predictedToApply = incomingPredictedData || MANUAL_PREDICTED_JSON || null;
      const pendingRemountAutosaveSnapshot = pendingSubmitUntilConfigReady
        ? {
            trigger: String(pendingSubmitUntilConfigReady.trigger || ""),
            autosave: Boolean(pendingSubmitUntilConfigReady.autosave)
          }
        : null;
      const hadPendingRemountAutosave = Boolean(
        pendingRemountAutosaveSnapshot
        && pendingRemountAutosaveSnapshot.autosave
        && pendingRemountAutosaveSnapshot.trigger.includes("start-close-remount")
      );
      traceAutosave("applyIncomingBubbleDataAsCurrentItem:start", {
        uniqueId,
        hasIncomingBubbleData: Boolean(incomingBubbleData),
        incomingBubbleDataKeys: incomingBubbleData && typeof incomingBubbleData === "object" ? Object.keys(incomingBubbleData) : [],
        hasIncomingPredictedData: Boolean(incomingPredictedData),
        incomingPredictedDataKeys: incomingPredictedData && typeof incomingPredictedData === "object" ? Object.keys(incomingPredictedData) : [],
        hasPredictedFallback: Boolean(!incomingPredictedData && MANUAL_PREDICTED_JSON),
        predictedToApplyKeys: predictedToApply && typeof predictedToApply === "object" ? Object.keys(predictedToApply) : [],
        hasIncomingColumns: Boolean(incomingColumnJson && Array.isArray(incomingColumnJson.columns)),
        incomingColumnCount: Array.isArray(incomingColumnJson?.columns) ? incomingColumnJson.columns.length : 0
      });
      const hasIncomingColumns = Boolean(incomingColumnJson && Array.isArray(incomingColumnJson.columns));
      if (hasIncomingColumns) {
        MANUAL_COLUMN_JSON = incomingColumnJson;
        applyColumnJson(incomingColumnJson, { deferPendingSubmitFlush: true });
      }

      if (incomingBubbleData && state.config) {
        MANUAL_DATA_JSON = incomingBubbleData;
        MANUAL_PREDICTED_JSON = predictedToApply;
        humanData = {};
        aiData = {};
        aiExplicitFieldKeys = new Set();
        sourceByField = {};
        humanTouchedFieldKeys = new Set();
        state.fileBuffers = {};
        state.fileStaging = {};
        loadJsonSafeToForm("human", incomingBubbleData, { source: "applyIncomingBubbleDataAsCurrentItem", stage: "bubble-data" });
        if (predictedToApply) {
          loadJsonSafeToForm("ai", predictedToApply, { source: "applyIncomingBubbleDataAsCurrentItem", stage: "predicted-data" });
        }
        initializeSourceByFieldFromAi();
        refreshAllFields();
        initialSnapshot = buildBaselineSnapshot(IS_EDITING_MODE ? getEditModeBaselinePayload() : incomingBubbleData);
        logPredictDebug("incoming-item-rehydrated", {
          uniqueId,
          humanKeyCount: Object.keys(incomingBubbleData || {}).length,
          predictedKeyCount: Object.keys(predictedToApply || {}).length,
          predictedFromFallback: Boolean(!incomingPredictedData && predictedToApply),
          sourceByFieldSnapshot: sourceByField
        });
      }
      if (hadPendingRemountAutosave) {
        isFormDirty = computeDirtyState();
        hasChangesSinceStartOpen = isFormDirty;
        logPredictDebug("incoming-item-rehydrated:preserve-dirty-for-remount-autosave", {
          pendingTrigger: pendingRemountAutosaveSnapshot?.trigger || "",
          pendingAutosave: Boolean(pendingRemountAutosaveSnapshot?.autosave),
          recomputedIsFormDirty: isFormDirty,
          ...buildSubmitChangeDiagnostics()
        });
      } else {
        clearChangedTracking();
        isFormDirty = false;
      }
      flushPendingSubmitAfterConfigReady();
      taskStartTimestamp = null;
      hasPendingUniqueIdSubmit = false;
      if (uniqueId) {
        lastObservedUniqueId = uniqueId;
        persistObservedUniqueId(uniqueId);
      }
      lastObservedDataSignature = readCurrentBubbleDataSignature();
      if (canRefreshLoadingStop()) {
        submitRefreshSignature = "";
        setFormRefreshLoading(false);
      }
      traceAutosave("applyIncomingBubbleDataAsCurrentItem:done", { uniqueId, dataSignatureLen: lastObservedDataSignature.length });
    }

    function flushPendingIncomingAfterSubmit() {
      traceAutosave("flushPendingIncomingAfterSubmit:start");
      if (!pendingIncomingUniqueId) {
        traceAutosave("flushPendingIncomingAfterSubmit:skip-no-pending");
        return;
      }
      const incomingBubbleData = pendingIncomingBubbleData;
      const uniqueId = pendingIncomingUniqueId;
      const dataSignature = pendingIncomingDataSignature;
      pendingIncomingBubbleData = null;
      pendingIncomingUniqueId = "";
      pendingIncomingDataSignature = "";

      const currentUniqueId = readCurrentUniqueId();
      const isSameItemNow = Boolean(currentUniqueId) && currentUniqueId === uniqueId;
      if (isSameItemNow && isFormDirty) {
        traceAutosave("flushPendingIncomingAfterSubmit:skip-overwrite-dirty", { uniqueId });
        lastObservedUniqueId = uniqueId;
        persistObservedUniqueId(uniqueId);
        return;
      }

      traceAutosave("flushPendingIncomingAfterSubmit:apply", { uniqueId, dataSignatureLen: dataSignature.length });
      applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, uniqueId, readCurrentColumnJsonObject());
    }

    function persistObservedUniqueId(uniqueId) {
      if (!uniqueId) return;
      try {
        window.sessionStorage.setItem(UNIQUE_ID_STORAGE_KEY, uniqueId);
      } catch (error) {
        // ignore storage access issues
      }
    }

    function readPersistedObservedUniqueId() {
      try {
        return String(window.sessionStorage.getItem(UNIQUE_ID_STORAGE_KEY) || "").trim();
      } catch (error) {
        return "";
      }
    }

    function readPersistedStartFlowState() {
      try {
        const raw = window.sessionStorage.getItem(START_FLOW_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        return {
          lastStartParamWasTrue: Boolean(parsed.lastStartParamWasTrue),
          hasChangesSinceStartOpen: Boolean(parsed.hasChangesSinceStartOpen),
          startOpenSequence: Number(parsed.startOpenSequence) || 0,
          time: parsed.time || ""
        };
      } catch (error) {
        return null;
      }
    }

    function persistStartFlowState() {
      try {
        window.sessionStorage.setItem(START_FLOW_STORAGE_KEY, JSON.stringify({
          lastStartParamWasTrue,
          hasChangesSinceStartOpen,
          startOpenSequence,
          time: new Date().toISOString()
        }));
      } catch (error) {
        // ignore storage access issues
      }
    }

    function persistStartChangedTracking() {
      try {
        window.sessionStorage.setItem(START_CHANGED_TRACKING_STORAGE_KEY, JSON.stringify({
          changedKeys: Array.from(changedFieldKeys || []),
          changedValues: Array.from((changedFieldValuesByKey || new Map()).entries()),
          lastChangedMode,
          hadEditModeDirtyChange,
          hasEnteredEditSession,
          hadInlineEditDirtyChange,
          hasEnteredInlineEditPanel,
          time: new Date().toISOString()
        }));
      } catch (error) {
        // ignore storage access issues
      }
    }

    function clearPersistedStartChangedTracking() {
      try {
        window.sessionStorage.removeItem(START_CHANGED_TRACKING_STORAGE_KEY);
      } catch (error) {
        // ignore storage access issues
      }
    }

    function readPersistedStartChangedTracking() {
      try {
        const raw = window.sessionStorage.getItem(START_CHANGED_TRACKING_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const keys = Array.isArray(parsed.changedKeys) ? parsed.changedKeys.filter(Boolean) : [];
        const changedValues = new Map(Array.isArray(parsed.changedValues) ? parsed.changedValues : []);
        const persistedLastChangedMode = String(parsed.lastChangedMode || "").trim().toLowerCase();
        return {
          keys,
          changedValues,
          lastChangedMode: persistedLastChangedMode === "edit" ? "edit" : (persistedLastChangedMode === "normal" ? "normal" : ""),
          hadEditModeDirtyChange: Boolean(parsed.hadEditModeDirtyChange),
          hasEnteredEditSession: Boolean(parsed.hasEnteredEditSession),
          hadInlineEditDirtyChange: Boolean(parsed.hadInlineEditDirtyChange),
          hasEnteredInlineEditPanel: Boolean(parsed.hasEnteredInlineEditPanel),
          time: parsed.time || ""
        };
      } catch (error) {
        return null;
      }
    }

    function readCurrentUniqueId() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.BUBBLE_DATA_JSON,
        inputs.bubble_data_json,
        window.BUBBLE_DATA_JSON,
        MANUAL_DATA_JSON
      ];
      for (const candidate of candidates) {
        const uniqueId = extractUniqueId(candidate);
        if (uniqueId) return uniqueId;
      }
      return "";
    }


    function normalizeStartSignalValue(rawValue) {
      if (rawValue === undefined || rawValue === null) return null;
      if (typeof rawValue === "boolean") return rawValue;
      if (typeof rawValue === "number") return rawValue === 1;
      const normalized = String(rawValue).trim().toLowerCase();
      if (["true", "1", "yes", "open", "opened"].includes(normalized)) return true;
      if (["false", "0", "no", "close", "closed"].includes(normalized)) return false;
      return null;
    }

    function safeReadBubbleInputsFrom(target) {
      try {
        return target && target.BUBBLE_INPUTS && typeof target.BUBBLE_INPUTS === "object"
          ? target.BUBBLE_INPUTS
          : null;
      } catch (error) {
        return null;
      }
    }

    function readStartSignalSnapshot() {
      const keyCandidates = ["start", "START", "startParam", "start_flag", "startFlag", "start_mode", "startMode"];
      const inputsScopes = [
        { scope: "window", inputs: safeReadBubbleInputsFrom(window) },
        { scope: "parent", inputs: safeReadBubbleInputsFrom(window.parent) },
        { scope: "top", inputs: safeReadBubbleInputsFrom(window.top) }
      ];
      const observedRawValues = {};

      for (const { scope, inputs } of inputsScopes) {
        if (!inputs) continue;
        for (const key of keyCandidates) {
          if (!Object.prototype.hasOwnProperty.call(inputs, key)) continue;
          const rawValue = inputs[key];
          observedRawValues[`${scope}.${key}`] = rawValue;
          const parsed = normalizeStartSignalValue(rawValue);
          if (parsed !== null) {
            return { value: parsed, source: `${scope}.BUBBLE_INPUTS.${key}`, rawValue, observedRawValues };
          }
        }
      }

      const searchTargets = [
        { source: "window.location.search", query: window.location.search },
        { source: "window.location.hash", query: window.location.hash && window.location.hash.includes("?") ? window.location.hash.split("?")[1] : "" }
      ];

      for (const target of searchTargets) {
        try {
          if (!target.query) continue;
          const queryValue = new URLSearchParams(target.query).get("start");
          observedRawValues[target.source] = queryValue;
          const parsed = normalizeStartSignalValue(queryValue);
          if (parsed !== null) {
            return { value: parsed, source: `${target.source}:start`, rawValue: queryValue, observedRawValues };
          }
        } catch (error) {
          observedRawValues[`${target.source}:error`] = String(error?.message || error || "parse_error");
        }
      }

      return { value: null, source: "unresolved", rawValue: null, observedRawValues };
    }

    function readStartSignalValue() {
      return readStartSignalSnapshot().value;
    }

    function readEditingSignalValue() {
      const editingValue = window.BUBBLE_INPUTS?.editing;
      if (editingValue === true || editingValue === 1) return true;
      if (editingValue === false || editingValue === 0) return false;
      const text = String(editingValue ?? "").trim().toLowerCase();
      if (text === "true" || text === "1") return true;
      if (text === "false" || text === "0") return false;
      return null;
    }


    function traceAutosave(label, payload = {}) {
      if (!ENABLE_RUNTIME_LOGS) return;
      const snapshot = {
        label,
        time: new Date().toISOString(),
        lastObservedUniqueId,
        currentUniqueId: readCurrentUniqueId(),
        pendingIncomingUniqueId,
        pendingIncomingDataSignatureLen: pendingIncomingDataSignature.length,
        hasPendingUniqueIdSubmit,
        lastObservedDataSignatureLen: lastObservedDataSignature.length,
        isFormDirty,
        isFormSaving,
        changedKeys: Array.from(changedFieldKeys || []),
        startSignal: readStartSignalValue(),
        lastStartParamWasTrue,
        hasSeenStartSignal,
        initialEditingMode: IS_EDITING_MODE,
        liveEditingInput: window.BUBBLE_INPUTS?.editing,
        configMode: String(state.config?.mode || ""),
        lastChangedMode,
        hadEditModeDirtyChange,
        hasEnteredEditSession,
        ...payload
      };
      console.info(`[BDF_AUTOSAVE_TRACE] ${JSON.stringify(snapshot)}`);
      if (!IS_VERSION_MODE && BDF.DEBUG_MODE) {
        setConsole(`trace:${label}`, JSON.stringify(snapshot, null, 2));
      }
    }


    function logStartState(label, extra = {}) {
      if (!ENABLE_RUNTIME_LOGS) return;
      const startSnapshot = readStartSignalSnapshot();
      const snapshot = {
        label,
        startSignal: startSnapshot.value,
        startSignalSource: startSnapshot.source,
        startSignalRawValue: startSnapshot.rawValue,
        lastStartParamWasTrue,
        hasSeenStartSignal,
        isFormDirty,
        isFormSaving,
        changedKeys: Array.from(changedFieldKeys || []),
        observedStartValues: startSnapshot.observedRawValues,
        ...extra
      };
      console.info(`[BDF_START_FLOW] ${JSON.stringify(snapshot)}`);
      if (!IS_VERSION_MODE && BDF.DEBUG_MODE) {
        setConsole(`start:${label}`, JSON.stringify(snapshot, null, 2));
      }
    }

    function flushPendingSubmitAfterConfigReady() {
      if (!pendingSubmitUntilConfigReady) return;
      if (!state.config || !Array.isArray(state.config.fields)) return;
      const pending = pendingSubmitUntilConfigReady;
      pendingSubmitUntilConfigReady = null;
      if (pending.autosave && !reconcileDirtyTracking("flush-pending-submit-after-config")) {
        const skipSnapshot = {
          trigger: pending.trigger,
          autosave: pending.autosave,
          forceSubmit: pending.forceSubmit,
          requestedAt: pending.requestedAt,
          aiExplicitFieldCount: aiExplicitFieldKeys.size,
          ...buildSubmitChangeDiagnostics()
        };
        logStartState("flush-pending-submit-after-config:skip-no-change", skipSnapshot);
        logPredictDebug("flush-pending-submit-after-config:skip-no-change", skipSnapshot);
        return;
      }
      logStartState("flush-pending-submit-after-config", {
        trigger: pending.trigger,
        autosave: pending.autosave,
        forceSubmit: pending.forceSubmit,
        requestedAt: pending.requestedAt,
        remountReadyRetryCount: Number(pending.remountReadyRetryCount || 0)
      });
      setTimeout(() => {
        runSubmitFlow({
          autosave: pending.autosave,
          forceSubmit: pending.forceSubmit,
          trigger: `${pending.trigger}:after-config-ready`,
          modeHint: pending.modeHint || ""
        });
      }, 0);
    }

    function getSubmitFn() {
      return (
        (typeof window.bubble_fn_submit === "function" && window.bubble_fn_submit) ||
        (window.parent && typeof window.parent.bubble_fn_submit === "function" && window.parent.bubble_fn_submit) ||
        (window.top && typeof window.top.bubble_fn_submit === "function" && window.top.bubble_fn_submit)
      );
    }

    function getBubbleFnBySuffix(suffix) {
      if (!suffix) return null;
      const fnName = `bubble_fn_${suffix}`;
      return (
        (typeof window[fnName] === "function" && window[fnName]) ||
        (window.parent && typeof window.parent[fnName] === "function" && window.parent[fnName]) ||
        (window.top && typeof window.top[fnName] === "function" && window.top[fnName])
      );
    }

    function triggerBubbleFnBySuffix(suffix) {
      const fn = getBubbleFnBySuffix(suffix);
      if (!fn) {
        console.warn(`bubble_fn_${suffix} bulunamadı (window/parent/top)`);
        return;
      }
      try {
        fn();
      } catch (error) {
        console.error(`bubble_fn_${suffix} çalıştırılamadı`, error);
      }
    }

    function computeDirtyState() {
      if (!state.config) return false;
      return (
        buildKeyValueListFromSources().length > 0
        || buildAddedCustomFields().length > 0
        || buildDeletedFields().length > 0
        || buildModifiedFields().length > 0
      );
    }

    function reconcileDirtyTracking(reason = "") {
      if (!state.config || !Array.isArray(state.config.fields)) {
        return isFormDirty;
      }
      const recomputedDirty = computeDirtyState();
      if (!recomputedDirty && (isFormDirty || changedFieldKeys.size > 0 || hasChangesSinceStartOpen)) {
        traceAutosave("reconcile-dirty-tracking:cleared", {
          reason,
          prevIsFormDirty: isFormDirty,
          prevChangedKeyCount: changedFieldKeys.size,
          prevHasChangesSinceStartOpen: hasChangesSinceStartOpen
        });
        clearChangedTracking();
        hasChangesSinceStartOpen = false;
        persistStartFlowState();
      }
      isFormDirty = recomputedDirty;
      return recomputedDirty;
    }

    function queueStartCloseAutosave(trigger, reason = "") {
      pendingStartCloseAutosave = {
        trigger,
        reason,
        queuedAt: new Date().toISOString(),
        modeHint: getSubmitModeHint()
      };
      traceAutosave("queue-start-close-autosave", {
        trigger,
        reason,
        modeHint: pendingStartCloseAutosave.modeHint
      });
    }

    function flushQueuedStartCloseAutosave() {
      if (!pendingStartCloseAutosave) return;
      if (isFormSaving) {
        traceAutosave("flush-start-close-autosave-skipped", {
          reason: "saving-lock",
          trigger: pendingStartCloseAutosave.trigger,
          queuedAt: pendingStartCloseAutosave.queuedAt
        });
        return;
      }
      const pending = pendingStartCloseAutosave;
      pendingStartCloseAutosave = null;
      traceAutosave("flush-start-close-autosave", {
        trigger: pending.trigger,
        reason: pending.reason,
        queuedAt: pending.queuedAt,
        modeHint: pending.modeHint
      });
      runSubmitFlow({
        autosave: true,
        forceSubmit: true,
        trigger: `${pending.trigger}:deferred`,
        modeHint: pending.modeHint || getSubmitModeHint()
      });
    }


    function clearSubmitLockTimeout() {
      if (submitLockTimeoutHandle) {
        clearTimeout(submitLockTimeoutHandle);
        submitLockTimeoutHandle = null;
      }
    }

    function armSubmitLockTimeout({ submitAttemptId, trigger, autosave }) {
      clearSubmitLockTimeout();
      submitLockTimeoutHandle = setTimeout(() => {
        if (!isFormSaving || activeSubmitAttemptId !== submitAttemptId) return;
        traceAutosave("submit-lock-timeout", {
          trigger,
          autosave,
          submitAttemptId,
          timeoutMs: SUBMIT_LOCK_TIMEOUT_MS,
          hasPendingStartCloseAutosave: Boolean(pendingStartCloseAutosave)
        });
        activeSubmitAttemptId = 0;
        isFormSaving = false;
        isFormDirty = true;
        flushPendingIncomingAfterSubmit();
        flushQueuedStartCloseAutosave();
      }, SUBMIT_LOCK_TIMEOUT_MS);
    }

    function settleSubmitAttempt({ submitAttemptId, autosave, success }) {
      if (activeSubmitAttemptId !== submitAttemptId) {
        traceAutosave("submit-attempt-stale-settle", {
          submitAttemptId,
          activeSubmitAttemptId,
          autosave,
          success
        });
        return false;
      }
      clearSubmitLockTimeout();
      activeSubmitAttemptId = 0;
      isFormSaving = false;
      isFormDirty = !success;
      if (success && !autosave && hasExistingBubbleData()) {
        setFormRefreshLoading(true, "İşlem kaydedildi. Güncel veriler bekleniyor…");
      }
      if (success && shouldResetAfterSubmit({ autosave })) {
        resetFormAfterSuccessfulSubmit();
      }
      flushPendingIncomingAfterSubmit();
      flushQueuedStartCloseAutosave();
      return true;
    }
    function handleBeforeUnload(event) {
      const dirtyNow = reconcileDirtyTracking("beforeunload");
      const hasUnsavedChanges = dirtyNow || hasChangesSinceStartOpen || changedFieldKeys.size > 0;
      const shouldSubmitOnUnload = hasSeenStartSignal && lastStartParamWasTrue && hasUnsavedChanges && !isFormSaving;
      logStartState("beforeunload", {
        shouldSubmitOnUnload,
        hasUnsavedChanges,
        dirtyNow,
        hasChangesSinceStartOpen,
        changedKeyCount: changedFieldKeys.size
      });
      if (shouldSubmitOnUnload) {
        runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "beforeunload", modeHint: getSubmitModeHint() });
      }
      persistStartFlowState();
      if (!hasUnsavedChanges) return undefined;
      if (!isFormSaving && !shouldSubmitOnUnload) {
        runSubmitFlow({ autosave: false, forceSubmit: true, trigger: "beforeunload-dirty-fallback" });
      }
      const warningMessage = "Kaydedilmemiş değişiklikler olabilir.";
      event.preventDefault();
      event.returnValue = warningMessage;
      return warningMessage;
    }

    function runSubmitFlow({ autosave = false, forceSubmit = false, trigger = "unknown", modeHint = "" } = {}) {
      traceAutosave("runSubmitFlow:start", { autosave, forceSubmit, trigger });
      if (isWaitingForServerRefresh && !autosave && !forceSubmit) {
        traceAutosave("runSubmitFlow:skip-waiting-server-refresh", { trigger });
        return;
      }
      if (!autosave && !forceSubmit && requiresExplicitActionSelection() && !isActionSelectionValid()) {
        traceAutosave("runSubmitFlow:blocked-missing-action", { trigger });
        openActionMenu();
        return;
      }
      if (!state.config || !Array.isArray(state.config.fields)) {
        pendingSubmitUntilConfigReady = {
          autosave,
          forceSubmit,
          trigger,
          modeHint,
          requestedAt: new Date().toISOString(),
          remountReadyRetryCount: Number(pendingSubmitUntilConfigReady?.remountReadyRetryCount || 0)
        };
        logStartState("submit-skipped-no-config", {
          trigger,
          autosave,
          forceSubmit,
          hasConfig: Boolean(state.config),
          queuedForConfigReady: true
        });
        isFormSaving = false;
        return;
      }
      const shouldEnforceRemountReady = autosave && String(trigger || "").includes("start-close-remount");
      if (shouldEnforceRemountReady && !isRemountRehydrateReadyForAutosave()) {
        const previousRetryCount = Number(pendingSubmitUntilConfigReady?.remountReadyRetryCount || 0);
        const retryCount = previousRetryCount + 1;
        const predictedObj = readCurrentPredictedDataObject() || {};
        pendingSubmitUntilConfigReady = {
          autosave,
          forceSubmit,
          trigger,
          modeHint,
          requestedAt: new Date().toISOString(),
          remountReadyRetryCount: retryCount
        };
        const deferSnapshot = {
          trigger,
          autosave,
          forceSubmit,
          retryCount,
          aiExplicitFieldCount: aiExplicitFieldKeys.size,
          predictedKeyCount: Object.keys(predictedObj).length,
          predictedKeySample: Object.keys(predictedObj).slice(0, 40),
          recomputedDirtyNow: computeDirtyState(),
          ...buildSubmitChangeDiagnostics()
        };
        logPredictDebug("submit-deferred-remount-rehydrate-not-ready", deferSnapshot);
        if (retryCount <= 20) {
          setTimeout(() => {
            flushPendingSubmitAfterConfigReady();
          }, 60);
          isFormSaving = false;
          return;
        }
        logPredictDebug("submit-deferred-remount-rehydrate-giveup", deferSnapshot);
      }
      if (isFormSaving && !forceSubmit) {

        return;
      }

      isFormSaving = true;
      activeSubmitAttemptId += 1;
      const submitAttemptId = activeSubmitAttemptId;
      if (!autosave) {
        submitRefreshSignature = readCurrentBubbleDataSignature();
      }
      const resolvedModeHint = modeHint || (autosave ? lastChangedMode : "");
      armSubmitLockTimeout({ submitAttemptId, trigger, autosave });
      traceAutosave("runSubmitFlow:lock-armed", collectEditContextSnapshot({
        autosave,
        forceSubmit,
        trigger,
        submitAttemptId,
        resolvedModeHint,
        startSignal: readStartSignalValue(),
        pendingStartCloseAutosave: Boolean(pendingStartCloseAutosave)
      }));
      if (autosave) {
        triggeredActionUniqueId = "";
      }

      try {
        ensureTaskStartTimestamp();
        validateAll();
        const firstInvalidKey = focusFirstInvalid();
        const invalidCount = Object.values(state.validMap).filter((val) => !val).length;
      if (invalidCount > 0) {
        summaryBox.style.display = "block";
        summaryBox.textContent = `${invalidCount} alan eksik veya hatalı.`;
      } else {
        summaryBox.style.display = "none";
      }

      const exportPayload = buildExportJson();
      const submitOutputsPayload = buildSubmitOutputsPayload({ autosave, modeHint: resolvedModeHint });
      logPredictDebug("submit-export-payload-checkpoint", {
        trigger,
        autosave,
        exportPayload,
        exportPayloadJson: JSON.stringify(exportPayload),
        currentStateValues: (state.config?.fields || []).reduce((acc, field) => {
          acc[field.key] = getCurrentValueForField(field);
          return acc;
        }, {}),
        currentSourceByField: { ...sourceByField },
        humanTouchedKeys: Array.from(humanTouchedFieldKeys || []),
        changedKeys: Array.from(changedFieldKeys || [])
      });
      const isAiHydrateAutosave =
        autosave === true &&
        trigger &&
        String(trigger).toLowerCase().includes("ai");

      if (isAiHydrateAutosave) {
        const isDeltaEmpty =
          !submitOutputsPayload.outputlist1?.length &&
          !submitOutputsPayload.outputlist2?.length &&
          !submitOutputsPayload.outputlist3?.length &&
          !submitOutputsPayload.outputlist4?.length;

        if (isDeltaEmpty) {
          const fullObj = submitOutputsPayload.output_full_obj || {};
          const fallbackEntries = Object.entries(fullObj);
          const nonEmptyKeys = fallbackEntries
            .filter(([, value]) => !isEmptyValue(value))
            .map(([key]) => key);

          submitOutputsPayload.outputlist1 = fallbackEntries.map(([key, value]) => `"${key}": ${JSON.stringify(value)}`);
          submitOutputsPayload.outputlist2 = nonEmptyKeys.slice();
          submitOutputsPayload.outputlist3 = [];
          submitOutputsPayload.outputlist4 = nonEmptyKeys.slice();
        }
      }
      logPredictDebug("submit-payload-checkpoint", {
        trigger,
        autosave,
        output_full_json: submitOutputsPayload.output_full_json,
        outputlist1: submitOutputsPayload.outputlist1,
        outputlist2: submitOutputsPayload.outputlist2,
        outputlist3: submitOutputsPayload.outputlist3,
        outputlist4: submitOutputsPayload.outputlist4,
        ...buildSubmitChangeDiagnostics()
      });
      traceAutosave("runSubmitFlow:payload-built", {
        trigger,
        output1: submitOutputsPayload.output1,
        output2: submitOutputsPayload.output2,
        output3: submitOutputsPayload.output3,
        output4: submitOutputsPayload.output4,
        outputlist1Count: Array.isArray(submitOutputsPayload.outputlist1) ? submitOutputsPayload.outputlist1.length : -1,
        outputlist2Count: Array.isArray(submitOutputsPayload.outputlist2) ? submitOutputsPayload.outputlist2.length : -1,
        outputlist3Count: Array.isArray(submitOutputsPayload.outputlist3) ? submitOutputsPayload.outputlist3.length : -1,
        outputlist4Count: Array.isArray(submitOutputsPayload.outputlist4) ? submitOutputsPayload.outputlist4.length : -1,
        outputlist1: submitOutputsPayload.outputlist1,
        outputlist2: submitOutputsPayload.outputlist2,
        outputlist3: submitOutputsPayload.outputlist3,
        outputlist4: submitOutputsPayload.outputlist4,
        ...buildSubmitChangeDiagnostics()
      });


      setConsole("debug:submit-outputs", JSON.stringify(submitOutputsPayload, null, 2));
      renderSubmitOutputs(submitOutputsPayload);

      emit("onSubmitAttempt", {
        values: exportPayload,
        isFormValid: invalidCount === 0,
        firstInvalidKey,
        output1: submitOutputsPayload.output1,
        output2: submitOutputsPayload.output2,
        output3: submitOutputsPayload.output3,
        output4: submitOutputsPayload.output4,
        outputlist1: submitOutputsPayload.outputlist1,
        outputlist2: submitOutputsPayload.outputlist2,
        outputlist3: submitOutputsPayload.outputlist3,
        outputlist4: submitOutputsPayload.outputlist4,
        output_full_obj: submitOutputsPayload.output_full_obj,
        output_full_json: submitOutputsPayload.output_full_json
      });

      const fn = getSubmitFn();
      if (!fn) {
        settleSubmitAttempt({ submitAttemptId, autosave, success: false });
        console.warn("bubble_fn_submit bulunamadı (window/parent/top)");
        return;
      }

      const payload = submitOutputsPayload;
      try {
        const maybePromise = fn(payload);
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise
            .then(() => {
              settleSubmitAttempt({ submitAttemptId, autosave, success: true });
            })
            .catch((error) => {
              settleSubmitAttempt({ submitAttemptId, autosave, success: false });
              console.error("submit failed", error);
            });
          return;
        }
        settleSubmitAttempt({ submitAttemptId, autosave, success: true });
      } catch (error) {
        settleSubmitAttempt({ submitAttemptId, autosave, success: false });
        console.error("submit failed", error);
      }

      hasPendingUniqueIdSubmit = false;
      } catch (error) {
        traceAutosave("runSubmitFlow:pre-submit-failed", collectEditContextSnapshot({
          autosave,
          forceSubmit,
          trigger,
          submitAttemptId,
          resolvedModeHint,
          error: error?.message || String(error)
        }));
        settleSubmitAttempt({ submitAttemptId, autosave, success: false });
        console.error("submit preflight failed", error);
      }
    }

    function shouldResetAfterSubmit({ autosave }) {
      if (autosave) return true;
      return !hasExistingBubbleData();
    }

    function resetFormAfterSuccessfulSubmit() {
      hasChangesSinceStartOpen = false;
      pendingStartCloseAutosave = null;
      pendingSubmitUntilConfigReady = null;
      submitRefreshSignature = "";
      setFormRefreshLoading(false);
      resetAllStores();
      persistStartFlowState();
      summaryBox.style.display = "none";
    }

    function collectEditContextSnapshot(extra = {}) {
      return {
        initialEditingMode: IS_EDITING_MODE,
        liveEditingInput: window.BUBBLE_INPUTS?.editing,
        configMode: String(state.config?.mode || "").trim().toLowerCase(),
        lastChangedMode,
        hadEditModeDirtyChange,
        hasEnteredEditSession,
        isEditPanelOpen,
        hadInlineEditDirtyChange,
        hasEnteredInlineEditPanel,
        ...extra
      };
    }

    function getSubmitModeHint() {
      const configMode = String(state.config?.mode || "").trim().toLowerCase();
      const liveEditingNow = isEditingModeNow();
      const editContextActive = hadEditModeDirtyChange || hasEnteredEditSession || liveEditingNow || configMode === "edit";
      const modeHint = editContextActive ? "edit" : "normal";
      traceAutosave("submit-mode-hint", collectEditContextSnapshot({ modeHint, liveEditingNow, editContextActive }));
      return modeHint;
    }


    function isEditAutosaveContextActive() {
      const configMode = String(state.config?.mode || "").trim().toLowerCase();
      const editingSignal = readEditingSignalValue();
      return Boolean(
        IS_EDITING_MODE
        || editingSignal === true
        || configMode === "edit"
        || lastChangedMode === "edit"
        || hadEditModeDirtyChange
        || hasEnteredEditSession
        || isEditPanelOpen
      );
    }

    function maybeRunAutosaveOnStartClose(trigger = "unknown") {
      const now = Date.now();
      const startSignal = readStartSignalValue();
      const editingSignal = readEditingSignalValue();
      const editContextActive = isEditAutosaveContextActive();
      reconcileDirtyTracking(`maybeRunAutosaveOnStartClose:${trigger}`);
      const hasAutosaveCandidate = isFormDirty || hasAiHydratedData;
      if (!hasAutosaveCandidate) return;
      if (isFormSaving) return;

      const shouldDeferForSessionOpen = editContextActive
        ? editingSignal === true
        : startSignal === true;

      if (shouldDeferForSessionOpen) {
        traceAutosave("autosave-deferred-session-open", {
          trigger,
          startSignal,
          editingSignal,
          editContextActive,
          gate: editContextActive ? "editing" : "start",
          reason: editContextActive ? "editing-true" : "start-true"
        });
        return;
      }

      if (now - lastAutosaveAt < AUTOSAVE_DEBOUNCE_MS) return;
      lastAutosaveAt = now;
      traceAutosave("autosave-allowed-session-gate", {
        trigger,
        startSignal,
        editingSignal,
        editContextActive,
        gate: editContextActive ? "editing" : "start",
        reason: trigger,
        isFormDirty,
        changedFieldKeyCount: changedFieldKeys.size,
        aiExplicitFieldCount: aiExplicitFieldKeys.size,
        hasChangesSinceStartOpen,
        hasAiHydratedData
      });
      runSubmitFlow({ autosave: true, trigger, modeHint: getSubmitModeHint() });
    }

    function evaluateUniqueIdTransition() {
      const nextUniqueId = readCurrentUniqueId();
      const nextDataSignature = readCurrentBubbleDataSignature();
      const uniqueIdChanged = Boolean(nextUniqueId) && nextUniqueId !== lastObservedUniqueId;
      const dataChanged = Boolean(nextDataSignature) && nextDataSignature !== lastObservedDataSignature;

      if (!nextUniqueId && !nextDataSignature) return;

      if (!lastObservedUniqueId && nextUniqueId) {
        traceAutosave("evaluateUniqueIdTransition:init-observed", { nextUniqueId });
        lastObservedUniqueId = nextUniqueId;
        persistObservedUniqueId(nextUniqueId);
      }
      if (!lastObservedDataSignature && nextDataSignature) {
        lastObservedDataSignature = nextDataSignature;
      }

      if (!uniqueIdChanged && !dataChanged) {
        return;
      }

      const incomingBubbleData = readCurrentBubbleDataObject();
      const incomingColumnJson = readCurrentColumnJsonObject();

      if (isFormSaving) {
        pendingIncomingBubbleData = incomingBubbleData;
        pendingIncomingUniqueId = nextUniqueId || lastObservedUniqueId;
        pendingIncomingDataSignature = nextDataSignature;
        traceAutosave("evaluateUniqueIdTransition:queued-while-saving", { nextUniqueId, dataChanged, uniqueIdChanged });
        return;
      }

      if (isFormDirty) {
        pendingIncomingBubbleData = incomingBubbleData;
        pendingIncomingUniqueId = nextUniqueId || lastObservedUniqueId;
        pendingIncomingDataSignature = nextDataSignature;
        hasPendingUniqueIdSubmit = true;
        traceAutosave("evaluateUniqueIdTransition:dirty-submit-current-first", {
          nextUniqueId,
          dataChanged,
          uniqueIdChanged,
          pendingIncomingBubbleDataKeys: incomingBubbleData && typeof incomingBubbleData === "object" ? Object.keys(incomingBubbleData) : []
        });
        maybeRunAutosaveOnStartClose("uniqueid-dirty-current-first:prefetch");
        runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "uniqueid-dirty-current-first", modeHint: getSubmitModeHint() });
        if (incomingColumnJson && Array.isArray(incomingColumnJson.columns)) {
          MANUAL_COLUMN_JSON = incomingColumnJson;
        }
        return;
      }

      traceAutosave("evaluateUniqueIdTransition:apply-direct", { nextUniqueId, dataChanged, uniqueIdChanged });
      applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, nextUniqueId || lastObservedUniqueId, incomingColumnJson);
    }

    function evaluateStartSignalTransition() {
      const startSignal = readStartSignalValue();
      updateInlineEditToggleUi();
      if (startSignal === null) return;

      const signalText = String(Boolean(startSignal));
      if (lastStartLoggedState !== signalText) {
        lastStartLoggedState = signalText;
        logStartState("signal-change", { startSignal });
      }

      hasSeenStartSignal = true;
      if (!lastStartParamWasTrue && startSignal) {
        lastStartParamWasTrue = true;
        startOpenSequence += 1;
        clearChangedTracking();
        const prefilledDirty = computeDirtyState();
        isFormDirty = prefilledDirty;
        hasChangesSinceStartOpen = prefilledDirty || hasAiHydratedData;
        logStartState("open", {
          startSignal,
          startOpenSequence,
          changedKeyCount: changedFieldKeys.size,
          prefilledDirty,
          aiExplicitFieldCount: aiExplicitFieldKeys.size
        });
        persistStartFlowState();
        return;
      }

      if (lastStartParamWasTrue && !startSignal) {
        if (isEditPanelOpen) {
          isEditPanelOpen = false;
          stopEditModePayloadPolling();
          applyVersionVisibility();
        }
        reconcileDirtyTracking("evaluateStartSignalTransition:close");
        const hasDirtyIndicators = hasChangesSinceStartOpen || isFormDirty || changedFieldKeys.size > 0 || hasAiHydratedData;
        const shouldSubmit = hasDirtyIndicators && !isFormSaving;
        const closeDiagnostics = {
          hasDirtyIndicators,
          shouldSubmit,
          ...buildSubmitChangeDiagnostics()
        };
        traceAutosave("start-close-dirty-diagnostics", closeDiagnostics);
        logPredictDebug("start-close-checkpoint", closeDiagnostics);
        logStartState("close", {
          startSignal,
          shouldSubmit,
          hasDirtyIndicators,
          hasChangesSinceStartOpen,
          isFormDirty,
          changedKeyCount: changedFieldKeys.size,
          startOpenSequence
        });
        lastStartParamWasTrue = false;
        if (shouldSubmit) {
          logStartState("close-trigger-submit", {
            mode: "autosave",
            trigger: "start-close",
            startOpenSequence,
            changedKeyCount: changedFieldKeys.size
          });
          hasChangesSinceStartOpen = false;
          hasAiHydratedData = false;
          persistStartFlowState();
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "start-close", modeHint: getSubmitModeHint() });
        } else {
          const skipReason = isFormSaving ? "saving-lock" : "no-detected-change";
          logStartState("close-skip-submit", {
            reason: skipReason,
            hasChangesSinceStartOpen,
            isFormDirty,
            changedKeyCount: changedFieldKeys.size,
            startOpenSequence
          });
          if (skipReason === "saving-lock" && hasDirtyIndicators) {
            queueStartCloseAutosave("start-close", "saving-lock");
          }
        }
        persistStartFlowState();
        return;
      }

      lastStartParamWasTrue = Boolean(startSignal);
      if (!startSignal) flushQueuedStartCloseAutosave();
      persistStartFlowState();
    }

    function evaluateEditingSignalTransition() {
      if (readStartSignalValue() === true) return;
      const editingSignal = readEditingSignalValue();
      if (editingSignal === null) return;

      if (!hasSeenEditingSignal) {
        hasSeenEditingSignal = true;
        lastEditingParamWasTrue = Boolean(editingSignal);
        traceAutosave("editing-signal-seed", { editingSignal });
        return;
      }

      if (lastEditingParamWasTrue && !editingSignal) {
        reconcileDirtyTracking("evaluateEditingSignalTransition:close");
        const hasDirtyIndicators = isFormDirty || changedFieldKeys.size > 0 || hasChangesSinceStartOpen;
        const hasDirtyOrAiHydrate = hasDirtyIndicators || hasAiHydratedData;
        const shouldSubmit = hasDirtyOrAiHydrate && !isFormSaving;
        traceAutosave("editing-close", { editingSignal, hasDirtyIndicators: hasDirtyOrAiHydrate, shouldSubmit, hasAiHydratedData });
        lastEditingParamWasTrue = false;
        if (shouldSubmit) {
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "editing-close", modeHint: getSubmitModeHint() });
        } else if (hasDirtyOrAiHydrate && isFormSaving) {
          queueStartCloseAutosave("editing-close", "saving-lock");
        }
        return;
      }

      lastEditingParamWasTrue = Boolean(editingSignal);
    }

    function initAutosaveStartWatcher() {
      const persistedStartFlowState = readPersistedStartFlowState();
      const persistedChangedTracking = readPersistedStartChangedTracking();
      const currentDataSignature = readCurrentBubbleDataSignature();
      const startSignal = readStartSignalValue();
      const editingSignal = readEditingSignalValue();
      const shouldHydratePersistedChanges = Boolean(
        (persistedStartFlowState && persistedStartFlowState.lastStartParamWasTrue)
        || startSignal === true
        || editingSignal === true
      );
      if (!shouldHydratePersistedChanges && persistedChangedTracking?.keys?.length) {
        clearPersistedStartChangedTracking();
      }
      if (shouldHydratePersistedChanges && persistedChangedTracking && Array.isArray(persistedChangedTracking.keys) && persistedChangedTracking.keys.length) {
        changedFieldKeys = new Set(persistedChangedTracking.keys);
        changedFieldValuesByKey = persistedChangedTracking.changedValues instanceof Map
          ? persistedChangedTracking.changedValues
          : new Map();
        if (persistedChangedTracking.lastChangedMode) {
          lastChangedMode = persistedChangedTracking.lastChangedMode;
        }
        hadEditModeDirtyChange = hadEditModeDirtyChange || Boolean(persistedChangedTracking.hadEditModeDirtyChange);
        hasEnteredEditSession = hasEnteredEditSession || Boolean(persistedChangedTracking.hasEnteredEditSession) || lastChangedMode === "edit";
        hadInlineEditDirtyChange = hadInlineEditDirtyChange || Boolean(persistedChangedTracking.hadInlineEditDirtyChange);
        hasEnteredInlineEditPanel = hasEnteredInlineEditPanel || Boolean(persistedChangedTracking.hasEnteredInlineEditPanel);
        traceAutosave("hydrate-persisted-edit-context", collectEditContextSnapshot({
          persistedAt: persistedChangedTracking.time || "",
          persistedLastChangedMode: persistedChangedTracking.lastChangedMode || "",
          persistedHadEditModeDirtyChange: Boolean(persistedChangedTracking.hadEditModeDirtyChange),
          persistedHasEnteredEditSession: Boolean(persistedChangedTracking.hasEnteredEditSession),
          persistedHadInlineEditDirtyChange: Boolean(persistedChangedTracking.hadInlineEditDirtyChange),
          persistedHasEnteredInlineEditPanel: Boolean(persistedChangedTracking.hasEnteredInlineEditPanel),
          changedKeyCount: changedFieldKeys.size
        }));
        logStartState("hydrate-persisted-changed-tracking", {
          changedKeyCount: changedFieldKeys.size,
          persistedAt: persistedChangedTracking.time || ""
        });
      }
      if (persistedStartFlowState) {
        startOpenSequence = Math.max(startOpenSequence, persistedStartFlowState.startOpenSequence || 0);
      }
      if (editingSignal !== null) {
        hasSeenEditingSignal = true;
        lastEditingParamWasTrue = Boolean(editingSignal);
      }

      if (startSignal !== null) {
        hasSeenStartSignal = true;
        lastStartParamWasTrue = Boolean(startSignal);
        hasChangesSinceStartOpen = lastStartParamWasTrue
          ? Boolean(persistedStartFlowState?.hasChangesSinceStartOpen)
          : false;
        logStartState("seed", { startSignal, startOpenSequence });

        const wasOpenBeforeRemount = Boolean(persistedStartFlowState?.lastStartParamWasTrue);
        const hasPersistedDirtyTracking = Boolean(persistedChangedTracking?.keys?.length)
          || Boolean(persistedChangedTracking?.hadEditModeDirtyChange)
          || Boolean(persistedChangedTracking?.changedValues?.size);
        const hasLiveDirtyIndicators = reconcileDirtyTracking("initAutosaveStartWatcher:remount-close")
          || changedFieldKeys.size > 0
          || hasChangesSinceStartOpen;
        const hadChangesBeforeRemount = hasLiveDirtyIndicators
          && (Boolean(persistedStartFlowState?.hasChangesSinceStartOpen) || hasPersistedDirtyTracking);
        const shouldSubmitRemountClose = wasOpenBeforeRemount && !startSignal && hadChangesBeforeRemount && !isFormSaving;
        if (shouldSubmitRemountClose) {
          hasChangesSinceStartOpen = false;
          lastStartParamWasTrue = false;
          persistStartFlowState();
          if (changedFieldKeys.size === 0 && persistedChangedTracking?.keys?.length) {
            changedFieldKeys = new Set(persistedChangedTracking.keys);
          }
          logStartState("remount-close-trigger-submit", {
            persistedStartFlowState,
            changedKeyCount: changedFieldKeys.size,
            trigger: "start-close-remount",
            hadChangesBeforeRemount,
            hasPersistedDirtyTracking
          });
          traceAutosave("remount-close-context", collectEditContextSnapshot({
            trigger: "start-close-remount",
            persistedLastStartParamWasTrue: Boolean(persistedStartFlowState?.lastStartParamWasTrue),
            persistedHasChanges: Boolean(persistedStartFlowState?.hasChangesSinceStartOpen),
            hasPersistedDirtyTracking,
            hadChangesBeforeRemount,
            changedKeyCount: changedFieldKeys.size
          }));
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "start-close-remount", modeHint: getSubmitModeHint() });
        }
        persistStartFlowState();
      }
      if (currentDataSignature) {
        lastObservedDataSignature = currentDataSignature;
      }

      if (window.history && typeof window.history.pushState === "function") {
        const originalPushState = window.history.pushState.bind(window.history);
        window.history.pushState = function pushStatePatched(...args) {
          const result = originalPushState(...args);
          evaluateStartSignalTransition();
          evaluateEditingSignalTransition();
          return result;
        };
      }

      if (window.history && typeof window.history.replaceState === "function") {
        const originalReplaceState = window.history.replaceState.bind(window.history);
        window.history.replaceState = function replaceStatePatched(...args) {
          const result = originalReplaceState(...args);
          evaluateStartSignalTransition();
          evaluateEditingSignalTransition();
          return result;
        };
      }

      window.addEventListener("popstate", evaluateStartSignalTransition);
      window.addEventListener("hashchange", evaluateStartSignalTransition);
      window.addEventListener("beforeunload", handleBeforeUnload);
      setInterval(() => {
        evaluateStartSignalTransition();
        evaluateEditingSignalTransition();
      }, 300);
    }

    function debounceFormChange() {
      if (state.autoSaveTimer) {
        clearTimeout(state.autoSaveTimer);
      }
      state.autoSaveTimer = setTimeout(() => {
        emit("onFormChange", {
          values: buildExportJson(),
          validMap: state.validMap,
          isFormValid: Object.values(state.validMap).every(Boolean)
        });
        if (IS_EDITING_MODE) {
          maybeRunAutosaveOnStartClose("debounce-form-change");
        }
      }, 500);
    }

    function setEditModeLoading(isLoading, message = "") {
      if (!editModeLoading) return;
      editModeLoading.style.display = isLoading ? "grid" : "none";
      if (editStageLayout) editStageLayout.style.display = isLoading ? "none" : "grid";
      if (editModeLoadingText && message) {
        editModeLoadingText.textContent = message;
      }
    }

    function parseIncomingJson(rawValue) {
      if (rawValue === null || rawValue === undefined) return null;
      if (typeof rawValue === "string") {
        const trimmed = rawValue.trim();
        if (!trimmed) return null;
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          return null;
        }
      }
      return rawValue;
    }

    function readEditModePayloadSources() {
      const source = window.BUBBLE_INPUTS || {};
      const stageRaw = source.editSchemaJson ?? source.editUiSchema ?? source.EDITING_STAGE_GROUPS_JSON ?? source.editingStageGroups ?? source.editing_stage_groups ?? null;
      const allRaw = source.EDITING_ALL_FIELDS_JSON ?? source.editingAllFields ?? source.editing_all_fields ?? null;
      const rawSignature = `${typeof stageRaw}:${String(stageRaw ?? "").slice(0, 50000)}||${typeof allRaw}:${String(allRaw ?? "").slice(0, 50000)}`;
      if (rawSignature === editCachedPayloadRawSignature) {
        return editCachedPayloadParsed;
      }
      const parsed = {
        stageGroups: parseIncomingJson(stageRaw),
        allFields: parseIncomingJson(allRaw)
      };
      editCachedPayloadRawSignature = rawSignature;
      editCachedPayloadParsed = parsed;
      return parsed;
    }

    function buildEditPayloadSignature(payload) {
      try {
        const stage = payload?.stageGroups || [];
        const all = payload?.allFields || [];
        return `${JSON.stringify(stage).length}:${JSON.stringify(all).length}`;
      } catch (error) {
        return `${Date.now()}`;
      }
    }

    function getStageKey(name, order, fallbackIndex = 0) {
      const normalizedName = String(name || "").trim();
      if (normalizedName) return `name:${normalizedName.toLocaleLowerCase("tr-TR")}`;
      const orderNumber = Number(order);
      if (Number.isFinite(orderNumber)) return `order:${orderNumber}`;
      return `fallback:${fallbackIndex}`;
    }

    function getStageLabel(name, order, fallbackIndex = 0) {
      const normalizedName = String(name || "").trim();
      if (normalizedName) return normalizedName;
      const orderNumber = Number(order);
      if (Number.isFinite(orderNumber)) return `Stage ${orderNumber}`;
      return `Stage ${fallbackIndex + 1}`;
    }

    function normalizeEditFieldItem(item, index, stageName = "", stageKey = "") {
      const raw = item && typeof item === "object" ? item : { value: item };
      const key = String(raw.id || raw.key || raw.fieldName || raw.name || raw.header || raw.label || `field_${index + 1}`).trim();
      const label = String(raw.header || raw.label || raw.fieldName || raw.name || key).trim() || key;
      const normalized = normalizeColumnType(raw.type || "text", raw.multiple || raw.allowMultiple);
      const type = String(normalized.type || raw.type || "text").toLowerCase();
      const value = raw.value ?? raw.currentValue ?? raw.fieldValue ?? raw.default ?? "";
      const sourceOptions = Array.isArray(raw.source) ? raw.source : [];
      const options = Array.isArray(raw.options) ? raw.options : sourceOptions;
      const header = String(raw.header || raw.fieldHeader || raw.columnHeader || "").trim();
      return {
        key,
        fieldName: key,
        label,
        type,
        displayType: normalized.displayType || raw.type || "text",
        required: normalizeStageType(raw.stageType || "optional") === "mandatory" || Boolean(raw.required),
        stageType: raw.stageType || "optional",
        allowMultiple: Boolean(raw.multiple || raw.allowMultiple),
        readOnly: Boolean(raw.readOnly),
        options: options.map((opt) => {
          if (typeof opt === "object" && opt) {
            const value = String(opt.value ?? opt.id ?? opt.label ?? "").trim();
            const label = String(opt.label ?? opt.value ?? opt.id ?? "").trim();
            return { value, label };
          }
          const text = String(opt ?? "").trim();
          return { value: text, label: text };
        }).filter((opt) => opt.value),
        default: raw.default ?? "",
        ui: raw.ui || {},
        _stageName: stageName,
        _stageKey: stageKey,
        _initialValue: value,
        _searchHeader: header,
        _isInColumnData: false,
        _columnOrder: Number.POSITIVE_INFINITY
      };
    }

    function buildConfigFromEditPayload(payload) {
      const stageGroups = Array.isArray(payload?.stageGroups) ? payload.stageGroups : [];
      const allFields = Array.isArray(payload?.allFields) ? payload.allFields : [];
      const list = [];
      editModeStageOrder = [];
      editModeStageMeta = [];

      if (stageGroups.length) {
        const sortedGroups = [...stageGroups].sort((a, b) => Number(a?.stage?.order || 0) - Number(b?.stage?.order || 0));
        sortedGroups.forEach((group, groupIndex) => {
          const stageName = String(group?.stage?.name || "").trim();
          const stageOrder = Number(group?.stage?.order);
          const stageKey = getStageKey(stageName, stageOrder, groupIndex);
          const stageLabel = getStageLabel(stageName, stageOrder, groupIndex);
          const fields = Array.isArray(group?.fields) ? group.fields : [];
          if (!fields.length) return;
          const normalizedFields = [];
          fields.forEach((field, index) => {
            if (isInnerStageType(field?.stageType)) return;
            normalizedFields.push(normalizeEditFieldItem(field, index, stageLabel, stageKey));
          });
          if (!normalizedFields.length) return;
          editModeStageOrder.push(stageKey);
          editModeStageMeta.push({ key: stageKey, name: stageName, order: Number.isFinite(stageOrder) ? stageOrder : null, label: stageLabel });
          normalizedFields.forEach((field) => list.push(field));
        });
      }

      if (allFields.length) {
        const map = new Map(list.map((field) => [field.key, field]));
        allFields.forEach((field, index) => {
          if (isInnerStageType(field?.stageType)) return;
          const normalized = normalizeEditFieldItem(field, index, "Ungrouped", "Ungrouped");
          if (!map.has(normalized.key)) {
            list.push(normalized);
            map.set(normalized.key, normalized);
          } else {
            const existing = map.get(normalized.key);
            if (isEmptyValue(existing?._initialValue) && !isEmptyValue(normalized._initialValue)) {
              existing._initialValue = normalized._initialValue;
            }
          }
        });
      }
      if (!list.length) return null;

      const columnDataColumns = Array.isArray(columnJson?.columns) ? columnJson.columns : [];
      const normalizeSearchToken = (value) => String(value || "").trim().toLocaleLowerCase("tr-TR");
      const columnLookup = new Map();
      columnDataColumns.forEach((column, index) => {
        const aliases = [column?.id, column?.key, column?.fieldName, column?.name, column?.header, column?.label]
          .map(normalizeSearchToken)
          .filter(Boolean);
        aliases.forEach((alias) => {
          if (!columnLookup.has(alias)) columnLookup.set(alias, index);
        });
      });

      list.forEach((field, index) => {
        const aliases = [field.key, field.fieldName, field.label, field._searchHeader]
          .map(normalizeSearchToken)
          .filter(Boolean);
        let matchedOrder = Number.POSITIVE_INFINITY;
        aliases.forEach((alias) => {
          if (columnLookup.has(alias)) {
            matchedOrder = Math.min(matchedOrder, Number(columnLookup.get(alias)));
          }
        });
        field._isInColumnData = Number.isFinite(matchedOrder);
        field._columnOrder = Number.isFinite(matchedOrder) ? matchedOrder : Number.POSITIVE_INFINITY;
        field._sourceOrder = index;
      });

      const initialValues = {};
      list.forEach((field) => {
        initialValues[field.key] = field._initialValue;
      });

      return {
        fields: list.map((field) => {
          const next = {
            ...field,
            editStageName: field._stageName || "Ungrouped",
            editStageKey: field._stageKey || "Ungrouped",
            editInColumnData: Boolean(field._isInColumnData),
            editColumnOrder: Number.isFinite(field._columnOrder) ? field._columnOrder : Number.POSITIVE_INFINITY,
            editSourceOrder: Number.isFinite(field._sourceOrder) ? field._sourceOrder : 0,
            searchHeader: field._searchHeader || ""
          };
          delete next._initialValue;
          return next;
        }),
        currentDateTimeISO: defaultSchema.currentDateTimeISO,
        locale: "tr-TR",
        timezone: "Europe/Istanbul",
        mode: "edit",
        initialValues,
        requiredPolicy: "soft",
        showInlineHelp: false,
        autoFocusFirstInvalid: false
      };
    }

    function hydrateEditHumanDataFromBubble(config) {
      const sourceObj = readCurrentBubbleDataObject() || {};
      const fields = Array.isArray(config?.fields) ? config.fields : [];
      if (!fields.length) return;
      const indexMap = new Map();
      fields.forEach((field) => {
        const aliases = [field.key, field.fieldName, field.label]
          .map((v) => String(v || "").trim())
          .filter(Boolean);
        aliases.forEach((alias) => {
          if (!indexMap.has(alias)) indexMap.set(alias, field.key);
          const lower = alias.toLocaleLowerCase("tr-TR");
          if (!indexMap.has(lower)) indexMap.set(lower, field.key);
        });
      });

      Object.entries(sourceObj).forEach(([rawKey, rawValue]) => {
        const key = String(rawKey || "").trim();
        if (!key) return;
        const direct = indexMap.get(key) || indexMap.get(key.toLocaleLowerCase("tr-TR"));
        if (!direct) return;
        humanData[direct] = rawValue;
        sourceByField[direct] = "human";
      });
    }

    function applyEditModePayloadIfReady(forceEditMode = false) {
      if (!IS_EDITING_MODE && !forceEditMode && !isEditPanelOpen) return false;
      const payload = readEditModePayloadSources();
      const hasStage = Array.isArray(payload?.stageGroups) && payload.stageGroups.length > 0;
      const hasAll = Array.isArray(payload?.allFields) && payload.allFields.length > 0;
      if (!hasStage && !hasAll) {
        editModeStablePollCount = 0;
        traceAutosave("edit-payload-waiting", { hasStage, hasAll });
        setEditModeLoading(true, "Edit verileri bekleniyor…");
        return false;
      }

      const signature = buildEditPayloadSignature(payload);
      if (editModePayloadLoaded && signature === lastEditModePayloadSignature) {
        editModeStablePollCount += 1;
        traceAutosave("edit-payload-stable", { signature });
        setEditModeLoading(false);
        return true;
      }

      const config = buildConfigFromEditPayload(payload);
      if (!config) {
        editModeStablePollCount = 0;
        traceAutosave("edit-payload-invalid", { signature });
        setEditModeLoading(true, "Edit verisi çözümlenemedi…");
        return false;
      }

      humanData = { ...(humanData || {}), ...(config.initialValues || {}) };
      hydrateEditHumanDataFromBubble(config);
      Object.keys(config.initialValues || {}).forEach((key) => {
        if (!sourceByField[key]) sourceByField[key] = "human";
      });
      state.config = config;
      lastEditModePayloadSignature = signature;
      editModePayloadLoaded = true;
      hasEnteredEditSession = true;
      traceAutosave("edit-payload-applied", { signature, fieldCount: Array.isArray(config.fields) ? config.fields.length : 0 });
      editModeStablePollCount = 0;
      setEditModeLoading(false);
      renderForm(config);
      flushPendingSubmitAfterConfigReady();
      return true;
    }

    function stopEditModePayloadPolling() {
      if (editModePayloadPollTimer) {
        clearInterval(editModePayloadPollTimer);
        editModePayloadPollTimer = null;
      }
      if (editModeSlowPollTimer) {
        clearInterval(editModeSlowPollTimer);
        editModeSlowPollTimer = null;
      }
      editModeStablePollCount = 0;
    }

    function ensureEditModePayloadPolling(forceEditMode = false) {
      if (!IS_EDITING_MODE && !forceEditMode && !isEditPanelOpen) return;
      const startFastPolling = () => {
        if (editModeSlowPollTimer) {
          clearInterval(editModeSlowPollTimer);
          editModeSlowPollTimer = null;
        }
        if (editModePayloadPollTimer) return;
        editModePayloadPollTimer = setInterval(() => {
          applyEditModePayloadIfReady(forceEditMode);
          if (editModeStablePollCount >= 8) {
            clearInterval(editModePayloadPollTimer);
            editModePayloadPollTimer = null;
            editModeSlowPollTimer = setInterval(() => {
              const before = lastEditModePayloadSignature;
              const applied = applyEditModePayloadIfReady(forceEditMode);
              const changed = before !== lastEditModePayloadSignature;
              if (!applied || changed) {
                if (editModeSlowPollTimer) {
                  clearInterval(editModeSlowPollTimer);
                  editModeSlowPollTimer = null;
                }
                startFastPolling();
              }
            }, 2500);
          }
        }, 300);
      };
      if (editModePayloadPollTimer || editModeSlowPollTimer) return;
      startFastPolling();
    }

    function resolveActiveProcessStageKey(stageMeta) {
      const dataObj = readCurrentBubbleDataObject() || {};
      const rawStage = dataObj.stage;
      if (rawStage === null || rawStage === undefined || rawStage === "") return "";
      const stageText = String(rawStage).trim();
      const stageTextLower = stageText.toLocaleLowerCase("tr-TR");

      const byName = stageMeta.find((item) => String(item.name || "").trim().toLocaleLowerCase("tr-TR") === stageTextLower);
      if (byName) return byName.key;

      const numericValue = Number(rawStage);
      if (Number.isFinite(numericValue)) {
        const byOrder = stageMeta.find((item) => Number(item.order) === numericValue);
        if (byOrder) return byOrder.key;
      }
      return "unknown";
    }

    function getProcessStageStatus(stageIndex, activeIndex) {
      if (activeIndex < 0) return "upcoming";
      if (stageIndex < activeIndex) return "completed";
      if (stageIndex === activeIndex) return "active";
      return "upcoming";
    }

    function getStageDisplayLabel(stageMetaByKey, stageKey, fallbackIndex = 0) {
      if (String(stageKey) === "Ungrouped") return "Tüm alanlar";
      const meta = stageMetaByKey.get(stageKey) || null;
      const label = String(meta?.label || meta?.name || "").trim();
      if (label) return label;
      const order = Number(meta?.order);
      if (Number.isFinite(order)) return `Stage ${order}`;
      return `Stage ${fallbackIndex + 1}`;
    }

    function fuzzySimilarityScore(haystack, needle) {
      if (!needle) return 0;
      let matches = 0;
      let cursor = 0;
      for (let i = 0; i < haystack.length && cursor < needle.length; i += 1) {
        if (haystack[i] === needle[cursor]) {
          matches += 1;
          cursor += 1;
        }
      }
      if (!matches) return 0;
      return matches / needle.length;
    }

    function getFieldSearchTargets(field) {
      const id = String(field?.key || field?.fieldName || "").trim();
      const label = String(field?.label || "").trim();
      const header = String(field?.searchHeader || field?.header || "").trim();
      return [
        { key: "id", value: id },
        { key: "ad", value: label },
        { key: "header", value: header }
      ].filter((item) => item.value);
    }

    function fieldSearchScore(field, term) {
      if (!term) return 0;
      const targets = getFieldSearchTargets(field).map((item) => item.value.toLocaleLowerCase("tr-TR"));
      let best = 0;
      targets.forEach((target) => {
        if (!target) return;
        if (target.startsWith(term)) best = Math.max(best, 300 + (term.length / Math.max(target.length, 1)));
        else if (target.includes(term)) best = Math.max(best, 220 + (term.length / Math.max(target.length, 1)));
        else best = Math.max(best, 100 * fuzzySimilarityScore(target, term));
      });
      return best;
    }

    function escapeRegExp(value) {
      return String(value || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function renderHighlightedText(text, term) {
      const source = String(text || "");
      if (!source || !term) return source;
      const rx = new RegExp(`(${escapeRegExp(term)})`, "ig");
      return source.replace(rx, '<mark class="edit-search-highlight">$1</mark>');
    }

    function applySearchResultDecoration({ wrapper, field, term }) {
      if (!wrapper) return;
      wrapper.classList.remove("search-result");
      const labelEl = wrapper.querySelector('.label-text');
      if (labelEl) {
        labelEl.textContent = String(field.label || field.key || "");
      }
      if (!term) return;
      wrapper.classList.add("search-result");
      if (labelEl) {
        labelEl.innerHTML = renderHighlightedText(String(field.label || field.key || ""), term);
      }
    }

    function stageNameSearchScore(stageLabel, term) {
      const target = String(stageLabel || "").toLocaleLowerCase("tr-TR");
      if (!term || !target) return 0;
      if (target.startsWith(term)) return 300 + (term.length / Math.max(target.length, 1));
      if (target.includes(term)) return 200 + (term.length / Math.max(target.length, 1));
      return 100 * fuzzySimilarityScore(target, term);
    }

    function renderSelectedStageFieldsProgressively({ stageKey, selectedFields, wrappersByKey, retryCount = 0, searchTerm = "", searchMode = false }) {
      editStageRenderSeq += 1;
      const renderSeq = editStageRenderSeq;
      if (editStageStatus) {
        editStageStatus.textContent = selectedFields.length ? "İçerik yükleniyor…" : "Bu aşamada gösterilecek alan yok.";
      }
      if (editStageFields) {
        editStageFields.innerHTML = selectedFields.length
          ? '<div class="edit-stage-fields-skeleton"><div class="line"></div><div class="line"></div><div class="line"></div></div>'
          : '';
        editStageFields.classList.remove('search-transition');
        requestAnimationFrame(() => editStageFields.classList.add('search-transition'));
      }
      let cursor = 0;
      const chunkSize = 4;
      const total = selectedFields.length;
      let appended = 0;
      const pump = () => {
        if (renderSeq !== editStageRenderSeq) return;
        if (stageKey !== editSelectedStage) return;
        if (!editStageFields) return;
        if (cursor === 0) editStageFields.innerHTML = "";
        const limit = Math.min(cursor + chunkSize, total);
        for (let i = cursor; i < limit; i += 1) {
          const field = selectedFields[i];
          const wrapper = wrappersByKey.get(field.key);
          if (wrapper) {
            applySearchResultDecoration({ wrapper, field, term: searchTerm });
            editStageFields.appendChild(wrapper);
            appended += 1;
          }
        }
        cursor = limit;
        if (cursor < total) {
          requestAnimationFrame(pump);
          return;
        }
        if (editStageStatus) {
          editStageStatus.textContent = total ? `${appended}/${total} alan listelendi.` : "Bu aşamada gösterilecek alan yok.";
        }
        if (appended < total && retryCount < 3) {
          setTimeout(() => {
            if (stageKey !== editSelectedStage) return;
            renderSelectedStageFieldsProgressively({ stageKey, selectedFields, wrappersByKey, retryCount: retryCount + 1, searchTerm, searchMode });
          }, 180);
        }
      };
      requestAnimationFrame(pump);
    }

    function markPayloadAsChanged(payload, sourceKind = "human") {
      if (!payload || !state.config) return;
      const keyMap = buildFieldKeyMap();
      Object.entries(payload).forEach(([jsonKey]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) return;
        const field = state.config.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        const effective = getEffectiveValue(fieldKey);
        if (isEmptyValue(effective)) return;
        if (sourceKind === "ai" && sourceByField[fieldKey] !== "ai") return;
        markFieldAsChanged(fieldKey);
        rememberChangedFieldValue(fieldKey, normalizeValueForComparison(field, effective, state.config));
      });
      isFormDirty = computeDirtyState();
    }

    function runColumnSearchRender(rawTerm = "") {
      if (!formEl || !state.config) return;
      const term = String(rawTerm || "").trim().toLocaleLowerCase("tr-TR");
      const wrappersByKey = new Map();
      Object.keys(state.fieldRefs || {}).forEach((fieldKey) => {
        const wrapper = state.fieldRefs?.[fieldKey]?.wrapper;
        if (wrapper) wrappersByKey.set(fieldKey, wrapper);
      });
      const fields = Array.isArray(state.config.fields) ? state.config.fields : [];
      const scored = fields
        .map((field, index) => ({
          field,
          index,
          score: term ? fieldSearchScore(field, term) : 1
        }))
        .filter((item) => item.score > 0)
        .sort((a, b) => term ? ((b.score - a.score) || (a.index - b.index)) : (a.index - b.index))
        .map((item) => item.field);

      formEl.innerHTML = "";
      scored.forEach((field) => {
        const wrapper = wrappersByKey.get(field.key);
        if (!wrapper) return;
        applySearchResultDecoration({ wrapper, field, term });
        formEl.appendChild(wrapper);
      });
      if (editSearchEmpty) {
        editSearchEmpty.style.display = term && scored.length === 0 ? "block" : "none";
        editSearchEmpty.textContent = term && scored.length === 0 ? "Sonuç bulunamadı" : "";
      }
      formEl.classList.remove("search-transition");
      requestAnimationFrame(() => formEl.classList.add("search-transition"));
    }

    function refreshConflictSlotLayout() {
      const refs = Object.values(state.fieldRefs || {});
      const hasAnyConflict = refs.some((ref) => ref && ref._hasConflict);
      refs.forEach((ref) => {
        if (!ref || !ref.conflictChip) return;
        const hasAi = Boolean(ref._hasAi);
        if (ref._hasConflict) {
          ref.conflictChip.style.display = "inline-flex";
          ref.conflictChip.classList.remove("is-spacer");
        } else if (hasAnyConflict && hasAi) {
          ref.conflictChip.style.display = "inline-flex";
          ref.conflictChip.classList.add("is-spacer");
          if (ref.conflictPopover) ref.conflictPopover.classList.remove("open");
        } else {
          ref.conflictChip.style.display = "none";
          ref.conflictChip.classList.remove("is-spacer");
          if (ref.conflictPopover) ref.conflictPopover.classList.remove("open");
        }

        const showGroup = hasAi || ref._hasConflict || (hasAnyConflict && hasAi);
        if (ref.statusGroup) {
          ref.statusGroup.style.display = showGroup ? "inline-flex" : "none";
        }
        if (ref.control) {
          ref.control.classList.toggle("with-status-group", showGroup);
        }
      });
    }

    function clearEditSearchState() {
      if (editModeDebounceTimer) {
        clearTimeout(editModeDebounceTimer);
        editModeDebounceTimer = null;
      }
      editModeSearchTerm = "";
      if (editSearchInput) editSearchInput.value = "";
      if (editSearchClear) editSearchClear.style.display = "none";
      if (editSearchEmpty) {
        editSearchEmpty.style.display = "none";
        editSearchEmpty.textContent = "";
      }
    }

    function runEditModeFilterRender() {
      if (!state.config) return;
      const isEditUiActive = IS_EDITING_MODE || isEditPanelOpen;
      const rawTerm = String(editModeSearchTerm || "").trim();
      if (!isEditUiActive) {
        runColumnSearchRender(rawTerm);
        return;
      }
      const term = rawTerm.toLocaleLowerCase("tr-TR");
      const searchMode = Boolean(term);
      const fields = Array.isArray(state.config.fields) ? state.config.fields : [];
      const stageMap = new Map();
      fields.forEach((field) => {
        const stageKey = String(field.editStageKey || "Ungrouped");
        if (!stageMap.has(stageKey)) stageMap.set(stageKey, []);
        stageMap.get(stageKey).push(field);
      });

      const stageLabelByKey = new Map((editModeStageMeta || []).map((stage) => [stage.key, stage]));
      const stageKeys = [];
      if (stageMap.has("Ungrouped")) stageKeys.push("Ungrouped");
      (editModeStageOrder || []).forEach((stageKey) => {
        if (stageKeys.includes(stageKey)) return;
        if (stageMap.has(stageKey)) stageKeys.push(stageKey);
      });
      Array.from(stageMap.keys()).forEach((stageKey) => {
        if (stageKeys.includes(stageKey)) return;
        stageKeys.push(stageKey);
      });

      if (searchMode && stageKeys.length > 1) {
        const pinnedTop = stageKeys[0] === "Ungrouped" ? ["Ungrouped"] : [];
        const sortable = pinnedTop.length ? stageKeys.slice(1) : [...stageKeys];
        sortable.sort((a, b) => {
          const aScore = stageNameSearchScore(getStageDisplayLabel(stageLabelByKey, a, 0), term);
          const bScore = stageNameSearchScore(getStageDisplayLabel(stageLabelByKey, b, 0), term);
          if (bScore !== aScore) return bScore - aScore;
          return 0;
        });
        stageKeys.splice(0, stageKeys.length, ...(pinnedTop.length ? [...pinnedTop, ...sortable] : sortable));
      }

      const filteredCountByStage = new Map();
      stageKeys.forEach((stageKey) => {
        const inStage = stageMap.get(stageKey) || [];
        const count = searchMode
          ? inStage.filter((field) => fieldSearchScore(field, term) > 0).length
          : inStage.length;
        filteredCountByStage.set(stageKey, count);
      });

      const firstWithFields = stageKeys.find((stageKey) => (filteredCountByStage.get(stageKey) || 0) > 0);
      if (searchMode) {
        editSelectedStage = "Ungrouped";
      } else if (!editSelectedStage || !stageKeys.includes(editSelectedStage)) {
        editSelectedStage = stageKeys.includes("Ungrouped") ? "Ungrouped" : (firstWithFields || stageKeys[0] || "");
      }
      if (editStageLayout) {
        editStageLayout.style.display = stageKeys.length ? "grid" : "none";
      }

      const wrappersByKey = new Map();
      Object.keys(state.fieldRefs || {}).forEach((fieldKey) => {
        const wrapper = state.fieldRefs?.[fieldKey]?.wrapper;
        if (wrapper) wrappersByKey.set(fieldKey, wrapper);
      });
      const wrapperPool = [
        ...Array.from(formEl.querySelectorAll('.field-wrapper')),
        ...(editModeRoot ? Array.from(editModeRoot.querySelectorAll('.field-wrapper')) : [])
      ];
      wrapperPool.forEach((wrapper) => {
        const key = wrapper.dataset.fieldKey || "";
        if (key && !wrappersByKey.has(key)) wrappersByKey.set(key, wrapper);
      });

      if (editStageTabs) editStageTabs.innerHTML = "";
      if (editStageSelect) editStageSelect.innerHTML = "";
      if (editStageHeading) {
        editStageHeading.textContent = getStageDisplayLabel(stageLabelByKey, editSelectedStage, 0);
      }

      if (editSearchEmpty) {
        editSearchEmpty.style.display = "none";
        editSearchEmpty.textContent = "";
      }
      if (editSearchClear) {
        editSearchClear.style.display = rawTerm ? "inline-flex" : "none";
      }

      const activeProcessIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === editProcessActiveStageKey);
      stageKeys.forEach((stageKey, visibleIndex) => {
        const stageMetaIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === stageKey);
        const status = getProcessStageStatus(stageMetaIndex, activeProcessIndex);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `edit-stage-tab ${status}`;
        const count = filteredCountByStage.get(stageKey) || 0;
        btn.textContent = `${getStageDisplayLabel(stageLabelByKey, stageKey, visibleIndex)} (${count})`;
        if (stageKey === editSelectedStage) btn.classList.add('active');
        if (stageKey === editProcessActiveStageKey) btn.dataset.activeProcess = "1";
        btn.addEventListener('click', () => {
          clearEditSearchState();
          editSelectedStage = stageKey;
          runEditModeFilterRender();
        });
        if (editStageTabs) editStageTabs.appendChild(btn);

        if (editStageSelect) {
          const option = document.createElement('option');
          option.value = stageKey;
          option.textContent = `${getStageDisplayLabel(stageLabelByKey, stageKey, visibleIndex)} (${count})`;
          option.selected = stageKey === editSelectedStage;
          editStageSelect.appendChild(option);
        }
      });

      if (editStageSelect) {
        editStageSelect.value = editSelectedStage;
      }

      const globallySortedResults = searchMode
        ? [...fields]
          .map((field, index) => ({ field, index, score: fieldSearchScore(field, term) }))
          .filter((item) => item.score > 0)
          .sort((a, b) => (b.score - a.score) || (a.index - b.index))
          .map((item) => item.field)
        : [];

      let selectedFields = [];
      if (searchMode) {
        selectedFields = globallySortedResults;
      } else {
        const ungroupedFields = [...(stageMap.get(editSelectedStage) || [])];
        if (String(editSelectedStage) === "Ungrouped") {
          ungroupedFields.sort((a, b) => {
            const aIn = a.editInColumnData ? 0 : 1;
            const bIn = b.editInColumnData ? 0 : 1;
            if (aIn !== bIn) return aIn - bIn;
            if (aIn === 0) {
              const aOrder = Number.isFinite(a.editColumnOrder) ? a.editColumnOrder : Number.POSITIVE_INFINITY;
              const bOrder = Number.isFinite(b.editColumnOrder) ? b.editColumnOrder : Number.POSITIVE_INFINITY;
              if (aOrder !== bOrder) return aOrder - bOrder;
            }
            const aSource = Number.isFinite(a.editSourceOrder) ? a.editSourceOrder : 0;
            const bSource = Number.isFinite(b.editSourceOrder) ? b.editSourceOrder : 0;
            return aSource - bSource;
          });
        }
        selectedFields = ungroupedFields;
      }

      if (searchMode && !selectedFields.length && editSearchEmpty) {
        editSearchEmpty.style.display = "block";
        editSearchEmpty.textContent = "Sonuç bulunamadı";
      }


      const selectedStageMetaIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === editSelectedStage);
      const activeProcessIndexForSelected = (editModeStageMeta || []).findIndex((stage) => stage.key === editProcessActiveStageKey);
      const selectedStageStatus = getProcessStageStatus(selectedStageMetaIndex, activeProcessIndexForSelected);
      if (editStageChip) {
        editStageChip.className = `edit-stage-chip ${selectedStageStatus}`;
        const statusLabel = selectedStageStatus === "active" ? "Current" : (selectedStageStatus === "completed" ? "Completed" : "Pending");
        editStageChip.textContent = statusLabel;
      }

      renderSelectedStageFieldsProgressively({
        stageKey: editSelectedStage,
        selectedFields,
        wrappersByKey,
        searchTerm: term,
        searchMode,
        retryCount: 0
      });

    }



    function renderForm(config) {
      formEl.innerHTML = "";
      state.values = {};
      state.validMap = {};
      state.errors = {};
      state.touched = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.fieldRefs = {};
      summaryBox.style.display = "none";

      const isEditUiActive = IS_EDITING_MODE || isEditPanelOpen;
      if (actionBar) actionBar.style.display = IS_EDITING_MODE ? "none" : "";
      if (formEl) formEl.style.display = isEditUiActive ? "none" : "grid";

      let previousGroup = null;
      config.fields.forEach((field, index) => {

        const wrapper = document.createElement("div");
        wrapper.className = "field-wrapper";
        wrapper.dataset.fieldKey = field.key;

        const normalizedType = String(field.type || "").toLowerCase();
        const fieldLabelLower = String(field.label || field.key || "").toLowerCase();
        const isAmountField = ["integer", "number", "currency", "percent", "duration"].includes(normalizedType)
          || (!["boolean", "checkbox", "dropdown", "date", "datetime", "time", "file", "multifile", "image", "textarea", "json"].includes(normalizedType)
            && /(tutar|bedel|ücret|ucret|fiyat|amount|price)/i.test(fieldLabelLower));
        const isDateField = ["date", "datetime", "time"].includes(normalizedType)
          || /(tarih|date|saat|time)/i.test(fieldLabelLower);
        const isFileField = ["file", "multifile", "image"].includes(normalizedType);
        const isMultilineField = ["textarea", "json"].includes(normalizedType);
        const isMultiDropdownField = normalizedType === "dropdown" && field.allowMultiple === true;
        const currentGroup = isDateField ? "date" : (isAmountField ? "amount" : "other");
        if (currentGroup === "date" && previousGroup === "amount") {
          wrapper.classList.add("group-break-date");
        }
        previousGroup = currentGroup;

        const row = document.createElement("div");
        row.className = "field-row";
        if (isAmountField) row.classList.add("is-amount-field");
        if (isDateField) row.classList.add("is-date-field");
        if (isFileField) row.classList.add("is-file-field");
        if (isMultilineField || isMultiDropdownField) row.classList.add("is-multiline-field");

        const labelColumn = document.createElement("div");
        labelColumn.className = "field-label";

        const labelTop = document.createElement("div");
        labelTop.className = "label-top";

        const typeMeta = getTypeMeta(field);
        const typeIcon = document.createElement("span");
        typeIcon.className = "type-icon";
        typeIcon.append(renderIcon(typeMeta.iconKey));
        typeIcon.title = typeMeta.label;

        const label = document.createElement("label");
        label.className = "label-text";
        label.htmlFor = `field-${field.key}`;
        label.textContent = truncateLabelText(field.label, 34);
        label.title = String(field.label || "");

        labelTop.append(typeIcon, label);

        const labelMeta = document.createElement("div");
        labelMeta.className = "label-meta";

        if (field.required) {
          labelTop.append(createMandatoryBadge());
        }

        const aiBadge = document.createElement("button");
        aiBadge.type = "button";
        aiBadge.className = "ai-badge";
        aiBadge.title = "AI önerisi";
        aiBadge.innerHTML = `<img src="https://upload.wikimedia.org/wikipedia/commons/0/04/ChatGPT_logo.svg" alt="ChatGPT" />`;
        aiBadge.addEventListener("click", () => {
          const currentSource = getActiveSource(field.key);
          const hasAi = !isEmptyValue(aiData[field.key]);
          if (!hasAi) return;
          const nextSource = currentSource === "ai" ? "human" : "ai";
          sourceByField[field.key] = nextSource;
          updateFieldDisplayValue(field.key);
          emit("onPredictedToggle", {
            key: field.key,
            mode: nextSource
          });
        });

        const applyAiBtn = document.createElement("button");
        applyAiBtn.type = "button";
        applyAiBtn.className = "pill";
        applyAiBtn.textContent = "AI'den doldur";
        applyAiBtn.style.display = "none";
        applyAiBtn.addEventListener("click", () => {
          const aiValue = aiData[field.key];
          if (isEmptyValue(aiValue)) return;
          humanData[field.key] = aiValue;
          sourceByField[field.key] = "human";
          markFieldAsChanged(field.key);
          rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(applyAiBtn);

        const revertAiBtn = document.createElement("button");
        revertAiBtn.type = "button";
        revertAiBtn.className = "pill";
        revertAiBtn.textContent = "AI'ye dön";
        revertAiBtn.style.display = "none";
        revertAiBtn.addEventListener("click", () => {
          if (isEmptyValue(aiData[field.key])) return;
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(revertAiBtn);

        const statusGroup = document.createElement("div");
        statusGroup.className = "field-status-group";
        const conflictChip = document.createElement("button");
        conflictChip.type = "button";
        conflictChip.className = "conflict-chip";
        conflictChip.textContent = "⚠";
        conflictChip.setAttribute("aria-label", "Çakışma detayı");
        conflictChip.title = "Çakışma detayı";
        conflictChip.style.display = "none";
        const conflictPopover = document.createElement("div");
        conflictPopover.className = "conflict-popover";
        conflictPopover.innerHTML = `
          <strong>AI vs Human</strong>
          <div><small>Human</small><pre data-conflict-human></pre></div>
          <div><small>AI</small><pre data-conflict-ai></pre></div>
          <div class="conflict-actions">
            <button type="button" class="secondary" data-apply-human>Human uygula</button>
            <button type="button" class="secondary" data-apply-ai>AI uygula</button>
          </div>
        `;
        conflictChip.addEventListener("click", () => {
          conflictPopover.classList.toggle("open");
        });
        const applyHumanBtn = conflictPopover.querySelector("[data-apply-human]");
        const applyAiBtnInPopover = conflictPopover.querySelector("[data-apply-ai]");
        safeOn(applyHumanBtn, "click", () => {
          sourceByField[field.key] = "human";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        safeOn(applyAiBtnInPopover, "click", () => {
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        statusGroup.append(conflictChip, aiBadge, conflictPopover);


        labelColumn.append(labelTop);
        if (labelMeta.childElementCount) {
          labelColumn.append(labelMeta);
        }

        const control = document.createElement("div");
        control.className = "field-control";
        control.dataset.fieldKey = field.key;
        const stageClass = normalizeStageType(field.stageType);
        if (stageClass) {
          control.classList.add(`stage-${stageClass}`);
        }
        const aiPill = document.createElement("span");
        aiPill.className = "ai-pill";
        aiPill.textContent = "AI";
        aiPill.style.display = "none";
        control.append(aiPill);
        control.append(statusGroup);

        let inputEl = null;
        let extraControls = null;
        let inlineActions = null;
        let setValue = null;

        const initialValue = getInitialValue(field, config);
        if (humanData[field.key] === undefined) {
          humanData[field.key] = initialValue;
        }
        if (!sourceByField[field.key]) {
          sourceByField[field.key] = (!isEmptyValue(aiData[field.key]) || aiExplicitFieldKeys.has(field.key)) ? "ai" : "human";
        }
        const effectiveInitial = getEffectiveValue(field.key);
        state.values[field.key] = effectiveInitial;
        state.validMap[field.key] = !validateField(field, effectiveInitial);

        if (["text", "email", "phone", "url", "password", "integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
          inputEl = document.createElement("input");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "Empty";
          if (field.type === "password") inputEl.type = "password";
          if (field.type === "email") inputEl.type = "email";
          if (field.type === "url") inputEl.type = "url";
          if (field.type === "phone") inputEl.type = "tel";
          if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) inputEl.inputMode = field.type === "integer" ? "numeric" : "decimal";

          setValue = (value) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const formatted = field.type === "integer"
                ? formatNumberDisplay(value, { maximumFractionDigits: 0 })
                : formatNumberDisplay(value, { maximumFractionDigits: 2 });
              inputEl.value = formatted || (value ?? "");
              return;
            }
            inputEl.value = value ?? "";
          };
          setValue(effectiveInitial);

          inputEl.addEventListener("input", (event) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const raw = event.target.value;
              const sanitizedRaw = sanitizeNumberTyping(raw, { integer: field.type === "integer" });
              if (sanitizedRaw !== raw) {
                event.target.value = sanitizedRaw;
              }
              setFieldValue(field.key, normalizeNumberInput(sanitizedRaw), field, sanitizedRaw);
            } else {
              setFieldValue(field.key, event.target.value, field);
            }
          });

          inputEl.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            let value = event.target.value;
            if (field.type === "email" && value) {
              value = value.toLowerCase();
              event.target.value = value;
            }
            if (field.type === "phone" && value && field.ui?.autoTrPrefix) {
              const digits = value.replace(/\D/g, "");
              if (digits.startsWith("0")) {
                value = `+90${digits.slice(1)}`;
                event.target.value = value;
              }
            }
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const normalized = normalizeNumberInput(value);
              const formatted = field.type === "integer" ? formatNumberDisplay(normalized, { maximumFractionDigits: 0 }) : formatNumberDisplay(normalized, { maximumFractionDigits: 2 });
              event.target.value = formatted || value;
              setFieldValue(field.key, normalized, field, formatted);
            } else {
              setFieldValue(field.key, value, field);
            }
            updateError(control, field);
          });

        } else if (field.type === "textarea" || field.type === "json") {
          inputEl = document.createElement("textarea");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "Empty";
          inputEl.value = effectiveInitial || "";
          setValue = (value) => {
            inputEl.value = value ?? "";
          };

          inputEl.addEventListener("input", (event) => {
            setFieldValue(field.key, event.target.value, field);
          });
          inputEl.addEventListener("blur", () => {
            updateError(control, field);
          });
        } else if (field.type === "boolean") {
          control.classList.add("toggle");
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.setAttribute("aria-label", field.label);
          inputEl.checked = Boolean(effectiveInitial);
          setValue = (value) => {
            inputEl.checked = Boolean(value);
          };
          control.append(inputEl);
          inputEl.addEventListener("change", () => {
            setFieldValue(field.key, inputEl.checked, field);
            updateError(control, field);
          });
        } else if (field.type === "dropdown" && !field.allowMultiple) {
          const select = document.createElement("select");
          select.className = "field-input";
          select.id = `field-${field.key}`;
          select.setAttribute("aria-describedby", `error-${field.key}`);

          const buildOptions = () => {
            select.innerHTML = "";
            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "Empty";
            select.append(emptyOption);
            const groups = {};
            (field.options || []).forEach((opt) => {
              if (opt.group) {
                if (!groups[opt.group]) groups[opt.group] = [];
                groups[opt.group].push(opt);
              } else {
                groups.__default = groups.__default || [];
                groups.__default.push(opt);
              }
            });

            Object.entries(groups).forEach(([groupName, opts]) => {
              if (groupName === "__default") {
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  select.append(option);
                });
              } else {
                const group = document.createElement("optgroup");
                group.label = groupName;
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  group.append(option);
                });
                select.append(group);
              }
            });
          };

          buildOptions();
          select.value = effectiveInitial || "";
          setValue = (value) => {
            select.value = value ?? "";
          };

          select.addEventListener("change", () => {
            setFieldValue(field.key, select.value, field);
            updateError(control, field);
          });

          control.append(select);
        } else if (field.type === "dropdown" && field.allowMultiple) {
          control.classList.add("multiselect-control");
          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "multiselect-options";

          const chips = document.createElement("div");
          chips.className = "chip-row";

          let selectedValues = Array.isArray(effectiveInitial) ? effectiveInitial : [];

          const renderOptions = () => {
            optionsWrapper.innerHTML = "";
            (field.options || []).forEach((opt) => {
              const optionRow = document.createElement("label");
              optionRow.className = "multiselect-option";
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              const normalizedOptValue = normalizeMultiSelectToken(opt.value);
              checkbox.value = normalizedOptValue;
              checkbox.dataset.value = normalizedOptValue;
              checkbox.checked = selectedValues.includes(normalizedOptValue);
              checkbox.disabled = opt.disabled || false;
              const text = document.createElement("span");
              text.textContent = opt.label;
              optionRow.append(checkbox, text);
              checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                  selectedValues = [...new Set([...selectedValues, normalizedOptValue])];
                } else {
                  selectedValues = selectedValues.filter((val) => val !== normalizedOptValue);
                }
                renderChips();
                setFieldValue(field.key, selectedValues, field);
                updateError(control, field);
              });
              optionsWrapper.append(optionRow);
            });
          };

          const renderChips = () => {
            chips.innerHTML = "";
            selectedValues.forEach((val) => {
              const opt = (field.options || []).find((o) => normalizeMultiSelectToken(o.value) === normalizeMultiSelectToken(val));
              const chip = document.createElement("span");
              chip.className = "chip";
              chip.textContent = opt ? opt.label : val;
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.textContent = "×";
              removeBtn.addEventListener("click", () => {
                selectedValues = selectedValues.filter((v) => v !== val);
                renderChips();
                renderOptions();
                setFieldValue(field.key, selectedValues, field);
              });
              chip.append(removeBtn);
              chips.append(chip);
            });
          };

          renderOptions();
          renderChips();
          setValue = (value) => {
            selectedValues = normalizeMultiValue(value);
            renderOptions();
            renderChips();
          };
          control.append(chips, optionsWrapper);
          updateEffectiveState(field.key, field);
        } else if (field.type === "date") {
          const dateInput = document.createElement("input");
          dateInput.type = "text";
          dateInput.className = "field-input is-date-input";
          dateInput.id = `field-${field.key}`;
          dateInput.setAttribute("aria-describedby", `error-${field.key}`);
          dateInput.placeholder = field.placeholder || "GG.AA.YYYY";
          dateInput.inputMode = "numeric";
          inputEl = dateInput;

          const normalizedInitial = effectiveInitial ? normalizeDateInput(effectiveInitial, config) : "";
          const initialDisplay = normalizedInitial && isValidDateString(normalizedInitial)
            ? formatDateDisplay(normalizedInitial)
            : (typeof effectiveInitial === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(effectiveInitial) ? effectiveInitial : "");
          dateInput.value = initialDisplay;

          setValue = (value) => {
            const normalized = value ? normalizeDateInput(String(value), config) : "";
            dateInput.value = normalized && isValidDateString(normalized) ? formatDateDisplay(normalized) : "";
          };

          const calendar = buildCalendarPopover(config, {
            initialDate: normalizedInitial && isValidDateString(normalizedInitial) ? normalizedInitial : "",
            onSelect: (dateValue) => {
              const displayValue = formatDateDisplay(dateValue);
              dateInput.value = displayValue;
              setFieldValue(field.key, dateValue, field, displayValue);
              updateError(control, field);
              closePopover();
            },
            onClose: () => {}
          });

          control.append(dateInput, calendar.element);

          const handleOutside = (event) => {
            if (!control.contains(event.target)) {
              closePopover();
            }
          };

          const openPopover = () => {
            calendar.element.classList.add("open");
            document.addEventListener("click", handleOutside);
          };

          const closePopover = () => {
            calendar.element.classList.remove("open");
            document.removeEventListener("click", handleOutside);
          };


          const syncDate = (raw) => {
            if (!raw) {
              dateInput.value = "";
              setFieldValue(field.key, "", field, "");
              updateError(control, field);
              calendar.setSelectedDate("");
              return;
            }
            const normalized = normalizeDateInput(raw, config);
            if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
              const displayValue = formatDateDisplay(normalized);
              dateInput.value = displayValue;
              if (isValidDateString(normalized)) {
                setFieldValue(field.key, normalized, field, displayValue);
                calendar.setSelectedDate(normalized);
              } else {
                setFieldValue(field.key, "", field, displayValue);
                calendar.setSelectedDate("");
              }
              updateError(control, field);
              return;
            }
            const masked = formatDateMask(raw);
            dateInput.value = masked;
            const parsed = parseDateDisplay(masked);
            if (parsed && isValidDateString(parsed)) {
              setFieldValue(field.key, parsed, field, masked);
              calendar.setSelectedDate(parsed);
            } else {
              setFieldValue(field.key, "", field, masked);
              calendar.setSelectedDate("");
            }
            updateError(control, field);
          };

          dateInput.addEventListener("input", (event) => syncDate(event.target.value));
          dateInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncDate(event.target.value);
          });
          dateInput.addEventListener("focus", () => {
            if (!calendar.element.classList.contains("open")) openPopover();
          });
          dateInput.addEventListener("pointerdown", () => {
            if (!calendar.element.classList.contains("open")) openPopover();
          });
          dateInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === "Tab" || event.key === "Escape") {
              closePopover();
            }
          });
        } else if (field.type === "datetime") {
          const datetimeInput = document.createElement("input");
          datetimeInput.type = "text";
          datetimeInput.className = "field-input is-date-input";
          datetimeInput.id = `field-${field.key}`;
          datetimeInput.setAttribute("aria-describedby", `error-${field.key}`);
          datetimeInput.placeholder = field.placeholder || "GG.AA.YYYY SS:DD";
          datetimeInput.inputMode = "numeric";
          inputEl = datetimeInput;

          const normalizedInitial = effectiveInitial ? normalizeDateTimeInput(effectiveInitial, config) : "";
          const dateValue = normalizedInitial ? getDateFromIso(normalizedInitial) : "";
          const timeValue = normalizedInitial ? getTimeFromIso(normalizedInitial) : "";
          datetimeInput.value = dateValue && timeValue ? formatDateTimeDisplay(normalizedInitial) : "";

          let selectedDate = dateValue;
          let selectedTime = timeValue;

          setValue = (value) => {
            if (!value) {
              datetimeInput.value = "";
              return;
            }
            const normalized = normalizeDateTimeInput(String(value), config);
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
              datetimeInput.value = formatDateTimeDisplay(normalized);
              selectedDate = getDateFromIso(normalized);
              selectedTime = getTimeFromIso(normalized);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
            } else {
              datetimeInput.value = "";
            }
          };

          const calendar = buildCalendarPopover(config, {
            initialDate: selectedDate,
            quickActionLabel: "Şimdi",
            onQuickAction: ({ selectDate }) => {
              const now = getCurrentDateTime(config);
              const nowDate = getDateFromIso(now);
              const nowTime = getTimeFromIso(now);
              selectedDate = nowDate;
              selectedTime = nowTime;
              selectDate(nowDate);
              setTimeSelects(nowTime);
              const displayValue = `${formatDateDisplay(nowDate)} ${nowTime}`;
              datetimeInput.value = displayValue;
              const normalized = normalizeDateTimeInput(`${nowDate}T${nowTime}`, config);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
              closePopover();
            },
            onSelect: (dateValue) => {
              selectedDate = dateValue;
              const nextTime = selectedTime || getTimeFromIso(getCurrentDateTime(config));
              const displayValue = `${formatDateDisplay(dateValue)} ${nextTime}`;
              datetimeInput.value = displayValue;
              const normalized = normalizeDateTimeInput(`${dateValue}T${nextTime}`, config);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
            },
            onClose: () => {}
          });

          const timeRow = document.createElement("div");
          timeRow.className = "picker-time";
          const hourSelect = document.createElement("select");
          hourSelect.className = "field-input";
          hourSelect.tabIndex = -1;
          const minuteSelect = document.createElement("select");
          minuteSelect.className = "field-input";
          minuteSelect.tabIndex = -1;

          const buildTimeOptions = (select, max) => {
            select.innerHTML = "";
            for (let i = 0; i <= max; i += 1) {
              const option = document.createElement("option");
              option.value = String(i).padStart(2, "0");
              option.textContent = option.value;
              select.append(option);
            }
          };

          buildTimeOptions(hourSelect, 23);
          buildTimeOptions(minuteSelect, 59);

          const setTimeSelects = (timeValue) => {
            if (!timeValue || !isValidTimeString(timeValue)) return;
            const [hour, minute] = timeValue.split(":");
            hourSelect.value = hour;
            minuteSelect.value = minute;
          };

          if (selectedTime) {
            setTimeSelects(selectedTime);
          }

          const updateTime = () => {
            selectedTime = `${hourSelect.value}:${minuteSelect.value}`;
            if (!selectedDate) return;
            const displayValue = `${formatDateDisplay(selectedDate)} ${selectedTime}`;
            datetimeInput.value = displayValue;
            const normalized = normalizeDateTimeInput(`${selectedDate}T${selectedTime}`, config);
            setFieldValue(field.key, normalized, field, displayValue);
            updateError(control, field);
          };

          hourSelect.addEventListener("change", updateTime);
          minuteSelect.addEventListener("change", updateTime);

          timeRow.append(hourSelect, minuteSelect);
          calendar.element.insertBefore(timeRow, calendar.element.lastElementChild);

          control.append(datetimeInput, calendar.element);

          const handleOutside = (event) => {
            if (!control.contains(event.target)) {
              closePopover();
            }
          };

          const openPopover = () => {
            calendar.element.classList.add("open");
            document.addEventListener("click", handleOutside);
          };

          const closePopover = () => {
            calendar.element.classList.remove("open");
            document.removeEventListener("click", handleOutside);
          };


          const syncDatetime = (raw) => {
            if (!raw) {
              datetimeInput.value = "";
              setFieldValue(field.key, "", field, "");
              updateError(control, field);
              return;
            }
            const normalized = normalizeDateTimeInput(raw, config);
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
              const displayValue = formatDateTimeDisplay(normalized);
              datetimeInput.value = displayValue;
              selectedDate = getDateFromIso(normalized);
              selectedTime = getTimeFromIso(normalized);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
              return;
            }
            const masked = formatDateTimeMask(raw);
            datetimeInput.value = masked;
            const parsed = parseDateTimeDisplay(masked, config);
            if (parsed) {
              selectedDate = getDateFromIso(parsed);
              selectedTime = getTimeFromIso(parsed);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
              setFieldValue(field.key, parsed, field, masked);
            } else {
              setFieldValue(field.key, "", field, masked);
            }
            updateError(control, field);
          };

          datetimeInput.addEventListener("input", (event) => syncDatetime(event.target.value));
          datetimeInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncDatetime(event.target.value);
          });
          datetimeInput.addEventListener("focus", () => {
            if (!calendar.element.classList.contains("open")) openPopover();
          });
          datetimeInput.addEventListener("pointerdown", () => {
            if (!calendar.element.classList.contains("open")) openPopover();
          });
          datetimeInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === "Tab" || event.key === "Escape") {
              closePopover();
            }
          });
        } else if (field.type === "time") {
          const timeInput = document.createElement("input");
          timeInput.type = "text";
          timeInput.className = "field-input";
          timeInput.id = `field-${field.key}`;
          timeInput.setAttribute("aria-describedby", `error-${field.key}`);
          timeInput.placeholder = field.placeholder || "SS:DD";
          timeInput.inputMode = "numeric";
          inputEl = timeInput;

          setValue = (value) => {
            timeInput.value = value ? formatTimeMask(String(value)) : "";
          };
          setValue(effectiveInitial);

          const syncTime = (raw) => {
            const masked = formatTimeMask(raw);
            timeInput.value = masked;
            const parsed = parseTimeDisplay(masked);
            if (parsed && isValidTimeString(parsed)) {
              setFieldValue(field.key, parsed, field, masked);
            } else {
              setFieldValue(field.key, "", field, masked);
            }
            updateError(control, field);
          };

          timeInput.addEventListener("input", (event) => syncTime(event.target.value));
          timeInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncTime(event.target.value);
          });

          if (field.ui?.quickActions) {
            const actions = document.createElement("div");
            actions.className = "field-actions";
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "Şu an";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const timeValue = getTimeFromIso(now);
              timeInput.value = timeValue;
              setFieldValue(field.key, timeValue, field, timeValue);
              updateError(control, field);
            });
            actions.append(nowBtn);
            inlineActions = actions;
          }
        } else if (field.type === "duration") {
          const durationInput = document.createElement("input");
          durationInput.className = "field-input";
          durationInput.setAttribute("aria-describedby", `error-${field.key}`);
          durationInput.placeholder = "hh:mm";
          durationInput.value = effectiveInitial || "";
          setValue = (value) => {
            durationInput.value = value ?? "";
          };
          durationInput.addEventListener("blur", () => {
            const normalized = normalizeTimeInput(durationInput.value);
            durationInput.value = normalized;
            const [h, m] = normalized.split(":");
            const minutes = (Number(h || 0) * 60) + Number(m || 0);
            if (field.ui?.durationFormat === "iso") {
              setFieldValue(field.key, `PT${Number(h || 0)}H${Number(m || 0)}M`, field, normalized);
            } else {
              setFieldValue(field.key, minutes, field, normalized);
            }
            updateError(control, field);
          });
          durationInput.addEventListener("input", () => {
            setFieldValue(field.key, durationInput.value, field);
          });
          inputEl = durationInput;
        } else if (field.type === "address") {
          const street = document.createElement("input");
          const district = document.createElement("input");
          const city = document.createElement("input");
          const postal = document.createElement("input");
          const country = document.createElement("input");
          [street, district, city, postal, country].forEach((input) => {
            input.className = "field-input";
          });
          street.placeholder = "Sokak / Mahalle";
          district.placeholder = "İlçe";
          city.placeholder = "İl";
          postal.placeholder = "Posta Kodu";
          country.placeholder = "Ülke";
          const grid = document.createElement("div");
          grid.className = "grid two";
          grid.append(street, district, city, postal, country);
          setValue = (value) => {
            const normalized = value && typeof value === "object" ? value : {};
            street.value = normalized.street || "";
            district.value = normalized.district || "";
            city.value = normalized.city || "";
            postal.value = normalized.postalCode || "";
            country.value = normalized.country || "";
          };
          setValue(effectiveInitial);
          const updateAddress = () => {
            const value = {
              street: street.value,
              district: district.value,
              city: city.value,
              postalCode: postal.value,
              country: country.value
            };
            setFieldValue(field.key, value, field);
            updateError(control, field);
          };
          [street, district, city, postal, country].forEach((input) => {
            input.addEventListener("input", updateAddress);
            input.addEventListener("blur", updateAddress);
          });
          inputEl = grid;
        } else if (["file", "multifile", "image"].includes(field.type)) {
          control.classList.add("file-field-control");
          const drop = document.createElement("div");
          drop.className = "file-drop";
          drop.textContent = "Dosya sürükleyin veya seçin";

          const allowMultiple = field.type === "multifile" || field.allowMultiple === true;

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "field-input";
          fileInput.id = `field-${field.key}`;
          fileInput.setAttribute("aria-describedby", `error-${field.key}`);
          const accept = field.ui?.accept || "";
          if (accept) fileInput.accept = accept;
          fileInput.multiple = allowMultiple;

          const list = document.createElement("div");
          list.className = "file-list";

          const renderFiles = () => {
            list.innerHTML = "";
            const files = state.fileBuffers[field.key] || [];
            const isImageGrid = field.type === "image" && (fileInput.multiple || files.length > 1);
            list.className = isImageGrid ? "file-grid" : "file-list";

            files.forEach((file, idx) => {
              const isImage = field.type === "image" || isImageLike(file);
              const row = document.createElement("div");
              row.className = isImageGrid ? "file-card" : "file-item";
              const meta = document.createElement("div");
              meta.className = "file-meta";
              meta.innerHTML = `<strong>${file.name}</strong><span>${Math.round(file.size / 1024)} KB</span>`;

              if (isImage) {
                const thumbWrap = document.createElement("div");
                thumbWrap.className = "file-thumb-wrap";
                const thumb = document.createElement("img");
                thumb.className = isImageGrid ? "file-thumb large" : "file-thumb";
                thumb.src = file.preview || file.url || "";
                thumb.alt = file.name || "görsel";
                const overlay = document.createElement("div");
                overlay.className = "file-thumb-overlay";
                overlay.textContent = "🔍";
                thumbWrap.append(thumb, overlay);
                thumbWrap.addEventListener("click", () => openLightbox(file.preview || file.url || ""));
                if (isImageGrid) {
                  row.append(thumbWrap);
                } else {
                  const left = document.createElement("div");
                  left.className = "inline-row";
                  left.append(thumbWrap, meta);
                  row.append(left);
                }
              } else {
                const left = document.createElement("div");
                left.className = "inline-row";
                const icon = document.createElement("div");
                icon.className = "file-icon";
                icon.textContent = "📄";
                left.append(icon, meta);
                if (file.url && (isPdfDataUrl(file.url) || file.url.startsWith("http"))) {
                  const previewBtn = document.createElement("button");
                  previewBtn.type = "button";
                  previewBtn.className = "preview-btn";
                  previewBtn.textContent = "Önizle";
                  previewBtn.addEventListener("click", () => openFilePreview(file.url));
                  left.append(previewBtn);
                }
                row.append(left);
              }

              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "file-remove";
              removeBtn.textContent = "×";
              removeBtn.addEventListener("click", () => {
                state.fileBuffers[field.key] = files.filter((_, fileIdx) => fileIdx !== idx);
                renderFiles();
                if (file.url) {
                  const currentValue = getEffectiveValue(field.key);
                  const values = Array.isArray(currentValue) ? currentValue : currentValue ? [currentValue] : [];
                  const filtered = values.filter((val) => val !== file.url);
                  if (allowMultiple) {
                    humanData[field.key] = filtered;
                  } else {
                    humanData[field.key] = filtered[0] || "";
                  }
                } else {
                  humanData[field.key] = "";
                }
                const filePayload = (state.fileBuffers[field.key] || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  lastModified: f.lastModified
                }));
                state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((f) => f.raw).filter(Boolean);
                sourceByField[field.key] = "human";
                markFieldAsChanged(field.key);
                rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
                updateEffectiveState(field.key, field);
                updateAiVisuals(field.key);
                emit("onFileSelected", {
                  key: field.key,
                  files: filePayload,
                  rawFiles: (state.fileBuffers[field.key] || []).map((f) => f.raw)
                });
              });

              if (isImageGrid) {
                row.append(meta, removeBtn);
              } else {
                row.append(removeBtn);
              }

              list.append(row);
            });
          };

          const handleFiles = async (fileList) => {
            const files = Array.from(fileList);
            const maxFiles = field.ui?.maxFiles || (allowMultiple ? 10 : 1);
            const maxSizeMB = field.ui?.maxSizeMB || 25;
            const errors = [];
            const accepted = [];

            const matchesAccept = (file) => {
              if (!accept) return true;
              const acceptRules = accept
                .split(",")
                .map((rule) => rule.trim().toLowerCase())
                .filter(Boolean);
              if (!acceptRules.length) return true;
              const fileType = String(file.type || "").toLowerCase();
              const fileName = String(file.name || "").toLowerCase();
              return acceptRules.some((rule) => {
                if (rule === "*/*") return true;
                if (rule.endsWith("/*")) {
                  return fileType.startsWith(rule.slice(0, -1));
                }
                if (rule.startsWith(".")) {
                  return fileName.endsWith(rule);
                }
                return fileType === rule;
              });
            };

            for (const file of files) {
              if (accepted.length >= maxFiles) continue;
              if (file.size > maxSizeMB * 1024 * 1024) {
                errors.push(`${file.name}: Dosya çok büyük.`);
                continue;
              }
              if (!matchesAccept(file)) {
                errors.push(`${file.name}: Tür desteklenmiyor.`);
                continue;
              }

              let processedFile = file;
              try {
                processedFile = await maybeCompressImageFile(file);
              } catch (error) {
                console.warn("image compression skipped", error);
              }

              const shouldPreview = field.type === "image" || processedFile.type.startsWith("image/");
              let base64Data = "";
              try {
                base64Data = stripDataUrlPrefix(await readFileAsDataUrl(processedFile));
              } catch (error) {
                console.warn("base64 read failed", error);
              }
              accepted.push({
                raw: processedFile,
                name: processedFile.name || file.name,
                size: processedFile.size,
                type: processedFile.type || file.type,
                lastModified: processedFile.lastModified || file.lastModified,
                base64: base64Data,
                preview: shouldPreview ? URL.createObjectURL(processedFile) : ""
              });
            }

            if (errors.length) {
              setFieldValue(field.key, "", field);
              state.errors[field.key] = errors.join(" ");
            }

            const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
            if (field.type === "multifile" || fileInput.multiple) {
              state.fileBuffers[field.key] = [...currentFiles, ...accepted].slice(0, maxFiles);
            } else {
              state.fileBuffers[field.key] = accepted.slice(0, 1);
            }
            renderFiles();

            const filePayload = (state.fileBuffers[field.key] || []).map((file) => ({
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified
            }));
            state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((file) => file.raw).filter(Boolean);
            humanData[field.key] = "";
            sourceByField[field.key] = "human";
            markFieldAsChanged(field.key);
            rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
            updateEffectiveState(field.key, field);
            updateAiVisuals(field.key);
            console.log("Pending file selected", {
              field: field.key,
              files: filePayload
            });
            emit("onFileSelected", {
              key: field.key,
              files: filePayload,
              rawFiles: (state.fileBuffers[field.key] || []).map((file) => file.raw)
            });
          };

          const setDropActive = (active) => {
            drop.style.borderColor = active ? varPrimary() : "";
          };

          const isInteractiveFileActionTarget = (eventTarget) => {
            return Boolean(eventTarget && eventTarget.closest && eventTarget.closest("button, a, input, .file-thumb-wrap"));
          };

          control.addEventListener("dragover", (event) => {
            event.preventDefault();
            setDropActive(true);
          });
          control.addEventListener("dragleave", (event) => {
            if (event.relatedTarget && control.contains(event.relatedTarget)) {
              return;
            }
            setDropActive(false);
          });
          control.addEventListener("drop", (event) => {
            event.preventDefault();
            handleFiles(event.dataTransfer.files);
            setDropActive(false);
          });

          fileInput.addEventListener("change", (event) => {
            handleFiles(event.target.files);
            event.target.value = "";
          });

          control.addEventListener("click", (event) => {
            if (isInteractiveFileActionTarget(event.target)) return;
            fileInput.click();
          });

          control.append(drop, fileInput, list);
          setValue = (value) => {
            const initialFiles = parseInitialFiles(value, allowMultiple, field);
            if (initialFiles.length) {
              state.fileBuffers[field.key] = initialFiles;
            } else if (!state.fileStaging[field.key]?.length) {
              state.fileBuffers[field.key] = [];
            }
            renderFiles();
          };
          setValue(effectiveInitial);
          updateEffectiveState(field.key, field);
        }

        if (inputEl) {
          if (!inputEl.dataset.fieldKey) {
            inputEl.dataset.fieldKey = field.key;
          }
          if (!control.contains(inputEl)) {
            control.append(inputEl);
          }
          if (inlineActions) {
            control.append(inlineActions);
          }
        }

        if (field.helpText && config.showInlineHelp) {
          const help = document.createElement("div");
          help.className = "helper-text";
          help.textContent = field.helpText;
          labelColumn.append(help);
        }

        const errorText = document.createElement("div");
        errorText.className = "error-text";
        errorText.dataset.errorFor = field.key;

        const controlStack = document.createElement("div");
        controlStack.className = "control-stack";
        controlStack.append(control);
        if (extraControls) {
          controlStack.append(extraControls);
        }
        controlStack.append(errorText);

        state.fieldRefs[field.key] = {
          field,
          wrapper,
          control,
          inputEl,
          setValue,
          aiBadge,
          aiPill,
          applyAiBtn,
          revertAiBtn,
          conflictChip,
          conflictPopover,
          statusGroup
        };
        updateAiVisuals(field.key);

        row.append(labelColumn, controlStack);
        wrapper.append(row);
        formEl.append(wrapper);

        if (index === 0 && config.autoFocusFirstInvalid) {
          setTimeout(() => {
            const focusTarget = wrapper.querySelector("input, textarea, select");
            if (focusTarget) focusTarget.focus();
          }, 0);
        }
      });
      if (IS_EDITING_MODE || isEditPanelOpen) {
        runEditModeFilterRender();
      }
      updateToolbarStatus();
      updateSubmitState(config);
      captureInitialSnapshot();
    }

    function varPrimary() {
      return getComputedStyle(document.documentElement).getPropertyValue("--primary");
    }

    function openLightbox(src) {
      if (IS_VERSION_MODE || !src || !lightboxEl || !lightboxImage) return;
      lightboxImage.src = src;
      lightboxEl.classList.add("open");
      lightboxEl.setAttribute("aria-hidden", "false");
    }

    function openFilePreview(url) {
      if (!url) return;
      window.open(url, "_blank", "noopener");
    }

    function closeLightbox() {
      if (!lightboxEl || !lightboxImage) return;
      lightboxEl.classList.remove("open");
      lightboxEl.setAttribute("aria-hidden", "true");
      lightboxImage.src = "";
    }

    function openExportModal(kind = "export") {
      if (IS_VERSION_MODE || !exportModal) return;
      exportModal.classList.add("open");
      exportModal.setAttribute("aria-hidden", "false");
      setExportTab(kind);
    }

    function closeExportModal() {
      if (!exportModal || !exportContent) return;
      exportModal.classList.remove("open");
      exportModal.setAttribute("aria-hidden", "true");
      exportContent.value = "";
    }

    function setExportTab(kind) {
      exportTabs.forEach((tab) => {
        tab.classList.toggle("active", tab.dataset.exportTab === kind);
      });
      if (kind === "human") {
        exportContent.value = JSON.stringify(humanData, null, 2);
        return;
      }
      if (kind === "ai") {
        exportContent.value = JSON.stringify(aiData, null, 2);
        return;
      }
      if (kind === "column") {
        exportContent.value = JSON.stringify(columnJson || {}, null, 2);
        return;
      }
      exportContent.value = JSON.stringify(buildExportJson(), null, 2);
    }

    safeOn("#lightbox", "click", (event) => {
      if (event.target === qs("#lightbox")) {
        closeLightbox();
      }
    });

    safeOn("#lightbox .lightbox-close", "click", closeLightbox);
    safeOn("#closeExport", "click", closeExportModal);
    safeOn("#exportModal", "click", (event) => {
      if (event.target === qs("#exportModal")) {
        closeExportModal();
      }
    });
    exportTabs.forEach((tab) => {
      safeOn(tab, "click", () => {
        setExportTab(tab.dataset.exportTab);
      });
    });

    function updateError(control, field) {
      const errorText = formEl.querySelector(`[data-error-for="${CSS.escape(field.key)}"]`);
      if (!errorText) {
        return;
      }
      const error = state.errors[field.key] || "";
      errorText.textContent = error;
      if (error) {
        control.classList.add("invalid");
      } else {
        control.classList.remove("invalid");
      }
      updateSubmitState(state.config);
    }

    function updateSubmitState(config) {

      const isValid = (config.fields || []).every((field) => {
        let validationValue = getMergedValidationValue(field);
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(validationValue)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        if (isFieldRequired(field)) {
          const fieldOk = !isEmptyValue(validationValue);
          if (!fieldOk) {

          }
          return fieldOk;
        }
        return true;
      });
      if (config.requiredPolicy === "strict") {
        submitBtn.disabled = !isValid;
        submitBtn.title = isValid ? "" : "Zorunlu alanları doldurun";
      } else {
        submitBtn.disabled = false;
        submitBtn.title = "";
      }

    }

    function focusFirstInvalid() {
      const firstInvalid = Object.keys(state.validMap).find((key) => !state.validMap[key]);
      if (!firstInvalid) return null;
      const target = qs(`#field-${CSS.escape(firstInvalid)}`) || qs(`[data-field="${CSS.escape(firstInvalid)}"]`);
      if (target) {
        focusFieldIntoView(target);
        if (target.focus) target.focus();
      }
      return firstInvalid;
    }

    function validateAll() {
      state.config.fields.forEach((field) => {
        let value = getEffectiveValue(field.key);
        if (field.type === "date" && typeof value === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(value)) {
          value = normalizeDateInput(value, state.config || {});
        }
        if (field.type === "time" && typeof value === "string" && !/^\d{2}:\d{2}$/.test(value)) {
          value = parseTimeDisplay(value) || value;
        }
        state.values[field.key] = value;
        let validationValue = value;
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(value)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        state.errors[field.key] = validateField(field, validationValue);
        state.validMap[field.key] = !state.errors[field.key];
        const control = qs(`#error-${CSS.escape(field.key)}`)?.parentElement?.querySelector(".field-control");
        if (control) updateError(control, field);
      });
    }

    function applyAiValuesToHuman({ overwrite, reason = "manual-apply" }) {
      if (!state.config) return;
      traceAutosave("apply-ai-values-to-human:start", {
        reason,
        overwrite,
        changedFieldCount: changedFieldKeys.size
      });
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        if (isEmptyValue(aiValue)) return;
        if (!overwrite && !isEmptyValue(humanData[field.key])) return;
        humanData[field.key] = aiValue;
        sourceByField[field.key] = "human";
        markFieldAsChanged(field.key);
        rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
      });
      traceAutosave("apply-ai-values-to-human:done", {
        reason,
        overwrite,
        changedFieldCount: changedFieldKeys.size
      });
      refreshAllFields();
    }

    function resetAllStores() {
      humanData = {};
      aiData = {};
      aiExplicitFieldKeys = new Set();
      sourceByField = {};
      humanTouchedFieldKeys = new Set();
      state.fileBuffers = {};
      state.fileStaging = {};
      state.values = {};
      state.validMap = {};
      state.errors = {};
      taskStartTimestamp = null;
      selectedActionId = "";
      selectedActionName = getDefaultActionLabel();
      triggeredActionUniqueId = "";
      isFormDirty = false;
      isFormSaving = false;
      submitRefreshSignature = "";
      setFormRefreshLoading(false);
      clearChangedTracking();
      hasAiHydratedData = false;
      updateActionBarUi();
      if (columnJson) {
        applyColumnJson(columnJson, { persistRestore: true });
      } else {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
      }
    }

    BDF.submit = () => {
      if (!formEl) return;
      formEl.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
    };

    BDF.reset = () => {
      resetAllStores();
    };

    window.BDF_submit = () => {
      if (!formEl) return;
      runSubmitFlow({ autosave: false });
    };

    if (!BDF.__listenersBound) {
      BDF.__listenersBound = true;

      initAutosaveStartWatcher();

      if (actionChevronBtn) {
        actionChevronBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!actionOptions.length) return;
          actionMenu.classList.toggle("open");
        });
      }

      if (actionTriggerBtn) {
        actionTriggerBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!actionOptions.length) {
            selectedActionId = "";
            selectedActionName = getDefaultActionLabel();
            triggerSelectedAction();
            return;
          }
          triggerSelectedAction();
        });
      }

      if (toggleInlineEditBtn) {
        toggleInlineEditBtn.addEventListener("click", (event) => {
          event.preventDefault();
          setInlineEditPanelOpen(!isEditPanelOpen);
        });
      }

      if (moreActionsBtn) {
        moreActionsBtn.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (!moreActionsMenu) return;
          moreActionsMenu.classList.toggle("open");
        });
      }

      if (addFieldBtn) {
        addFieldBtn.addEventListener("click", (event) => {
          event.preventDefault();
          triggerBubbleFnBySuffix("add_field");
          if (moreActionsMenu) moreActionsMenu.classList.remove("open");
        });
      }

      if (manageFieldsBtn) {
        manageFieldsBtn.addEventListener("click", (event) => {
          event.preventDefault();
          triggerBubbleFnBySuffix("manage_field");
          if (moreActionsMenu) moreActionsMenu.classList.remove("open");
        });
      }

      if (predictedActionBtn) {
        predictedActionBtn.addEventListener("click", (event) => {
          event.preventDefault();
          const actionId = predictedActionBtn.dataset.actionId || "";
          const actionName = predictedActionBtn.dataset.actionName || "";
          if (!actionId) return;
          selectActionAndTrigger({ id: actionId, name: actionName });
        });
      }

      document.addEventListener("click", (event) => {
        if (actionSplit && actionMenu && !actionSplit.contains(event.target)) {
          closeActionMenu();
        }
        if (moreActions && moreActionsMenu && !moreActions.contains(event.target)) {
          moreActionsMenu.classList.remove("open");
        }
      });

      if (formContainer) {
        formContainer.addEventListener("focusin", (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const isMobileLike = (window.matchMedia && window.matchMedia("(max-width: 900px)").matches)
            || (window.visualViewport && window.visualViewport.height < window.innerHeight - 120);
          const delayMs = isMobileLike ? 0 : 220;
          setTimeout(() => {
            if (document.activeElement !== target) return;
            focusFieldIntoView(target);
          }, delayMs);
        });
      }

      if (editSearchInput) {
        const applySearchTerm = (nextTerm) => {
          if (editModeDebounceTimer) clearTimeout(editModeDebounceTimer);
          editModeDebounceTimer = setTimeout(() => {
            editModeSearchTerm = String(nextTerm || "");
            runEditModeFilterRender();
          }, 160);
        };
        editSearchInput.addEventListener("input", (event) => {
          const nextTerm = String(event?.target?.value || "");
          applySearchTerm(nextTerm);
        });
        editSearchInput.addEventListener("keydown", (event) => {
          if (event.key !== "Escape") return;
          event.preventDefault();
          if (editSearchInput.value) {
            editSearchInput.value = "";
            applySearchTerm("");
          }
        });
      }

      if (editSearchClear) {
        editSearchClear.addEventListener("click", () => {
          if (!editSearchInput) return;
          editSearchInput.value = "";
          editModeSearchTerm = "";
          runEditModeFilterRender();
          editSearchInput.focus();
        });
      }

      if (editStageSelect) {
        editStageSelect.addEventListener("change", (event) => {
          const nextStage = String(event?.target?.value || "").trim();
          if (!nextStage) return;
          clearEditSearchState();
          editSelectedStage = nextStage;
          runEditModeFilterRender();
        });
      }

      safeOn("#dynamicForm", "submit", (event) => {
        event.preventDefault();
        runSubmitFlow({ autosave: false });
      });

      safeOn("#submitBtn", "click", () => {

        const submitOutputsPayload = buildSubmitOutputsPayload();
        renderSubmitOutputs(submitOutputsPayload);
      });

      safeOn("#dynamicForm", "keydown", (event) => {
      if (event.key === "Escape") {
        if (event.target && event.target.blur) event.target.blur();
        return;
      }
      if (event.key !== "Enter") return;
      if (event.target?.tagName === "TEXTAREA") return;
      if (event.target?.type === "button") return;
      event.preventDefault();
      const focusables = Array.from(formEl.querySelectorAll("input, select, textarea")).filter((el) => !el.disabled && el.type !== "hidden");
      const currentIndex = focusables.indexOf(event.target);
      const next = focusables[currentIndex + 1];
      if (next) {
        next.focus();
      } else {
        submitBtn.click();
      }
      });

      safeOn("#clearBtn", "click", () => {
        emit("onClear", {});
        resetAllStores();
      });

      ["#columnJsonInput", "#humanJsonInput", "#predictedJsonInput"].forEach((selector) => {
        safeOn(selector, "input", () => {
          syncManualJsonInputs();
        });
      });

      safeOn("#loadHumanJson", "click", () => {
        syncManualJsonInputs();
        initialSnapshot = null;
        if (state.config) {
          initialSnapshot = buildBaselineSnapshot(MANUAL_DATA_JSON);
        }
        const payload = MANUAL_DATA_JSON || SAMPLE_DATA_JSON;
        if (!payload) {
          humanData = {};
          refreshAllFields();
          updateActionBarUi();
          return;
        }
        emit("debug:human-json", payload);
        loadJsonSafeToForm("human", payload, { source: "loadHumanJsonBtn", stage: "manual-human-load" });
        clearChangedTracking();
        isFormDirty = computeDirtyState();
        updateActionBarUi();
        openExportModal("human");
      });

      safeOn("#loadPredictedJson", "click", () => {
      syncManualJsonInputs();
      const payload = MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON;
      if (!payload) {
        aiData = {};
        aiExplicitFieldKeys = new Set();
        initializeSourceByFieldFromAi();
        refreshAllFields();
        return;
      }
      emit("debug:predicted-json", payload);
      traceAutosave("predicted-json-load:start", {
        predictedKeyCount: Object.keys(payload || {}).length,
        predictedKeys: Object.keys(payload || {}),
        payload
      });
      loadJsonSafeToForm("ai", payload, { source: "loadPredictedJsonBtn", stage: "manual-ai-load" });
      initializeSourceByFieldFromAi();
      refreshAllFields();
      hasAiHydratedData = true;
      traceAutosave("predicted-json-load:applied", {
        aiKeys: Object.keys(aiData || {}),
        sourceByFieldSnapshot: sourceByField,
        effectiveChangedDetails: collectChangedFieldDebugDetails(),
        hasAiHydratedData
      });
      updateActionBarUi();
      openExportModal("ai");
      });

      safeOn("#loadColumnJson", "click", () => {
      syncManualJsonInputs();
      columnJson = MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON;
      applyColumnJson(columnJson, { persistRestore: true });
      emit("debug:column-json", columnJson);
      openExportModal("column");
      });

      safeOn("#applyAiToEmpty", "click", () => {
        applyAiValuesToHuman({ overwrite: false, reason: "button-apply-ai-to-empty" });
      });

      safeOn("#overwriteAiToAll", "click", () => {
        const confirmed = window.confirm("AI tüm alanları overwrite edecek. Devam edilsin mi?");
        if (!confirmed) return;
        applyAiValuesToHuman({ overwrite: true, reason: "button-overwrite-ai-to-all" });
      });

      safeOn("#resetStores", "click", () => {
        resetAllStores();
      });

      safeOn("#exportJson", "click", () => {
        openExportModal("export");
      });

      if (scenarioColumnOnlyBtn) {
        safeOn("#scenarioColumnOnly", "click", () => {
          applyScenario({
            name: "column-only",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON
          });
        });
      }

      if (scenarioColumnHumanBtn) {
        safeOn("#scenarioColumnHuman", "click", () => {
          applyScenario({
            name: "column-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON
          });
        });
      }

      if (scenarioColumnAiBtn) {
        safeOn("#scenarioColumnAi", "click", () => {
          applyScenario({
            name: "column-ai",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioColumnAiHumanBtn) {
        safeOn("#scenarioColumnAiHuman", "click", () => {
          applyScenario({
            name: "column-ai-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioConflictBtn) {
        safeOn("#scenarioConflict", "click", () => {
          applyScenario({
            name: "conflict",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: {
              "Kusur Oranı": "40",
              "Hasar Onarım Tutarı": "120000"
            },
            ai: {
              "Kusur Oranı": "80",
              "Hasar Onarım Tutarı": "145000"
            }
          });
        });
      }

    }

    if (currentDateTimeInput) currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
    if (schemaInput) schemaInput.value = JSON.stringify(defaultSchema, null, 2);
    syncManualJsonInputs();
    if (MANUAL_COLUMN_JSON) {
      columnJson = MANUAL_COLUMN_JSON;
    }
    applyVersionVisibility();
    syncActionOptions();
    updateInlineEditToggleUi();
    initLateIncomingDataSync();
    const hasStagePayloadInput = Boolean(INITIAL_INPUTS?.editSchemaJson || INITIAL_INPUTS?.editUiSchema || INITIAL_INPUTS?.EDITING_STAGE_GROUPS_JSON || INITIAL_INPUTS?.editingStageGroups || INITIAL_INPUTS?.editing_stage_groups);
    const hasAllFieldsPayloadInput = Boolean(INITIAL_INPUTS?.EDITING_ALL_FIELDS_JSON || INITIAL_INPUTS?.editingAllFields || INITIAL_INPUTS?.editing_all_fields);
    const hasEditPayloadInput = hasStagePayloadInput || hasAllFieldsPayloadInput;
    const shouldUseEditPayloadBootstrap = IS_EDITING_MODE || (hasEnteredEditSession && hasEditPayloadInput && readStartSignalValue() !== true);
    traceAutosave("edit-session-bootstrap", {
      initialEditingMode: IS_EDITING_MODE,
      initialEditingInput: INITIAL_INPUTS?.editing,
      hasStagePayloadInput,
      hasAllFieldsPayloadInput,
      hasColumnJsonInput: Boolean(INITIAL_INPUTS?.COLUMN_JSON || INITIAL_INPUTS?.column_json),
      hasBubbleDataInput: Boolean(INITIAL_INPUTS?.BUBBLE_DATA_JSON || INITIAL_INPUTS?.bubble_data_json),
      shouldUseEditPayloadBootstrap
    });
    if (shouldUseEditPayloadBootstrap) {
      const payloadAppliedNow = applyEditModePayloadIfReady(!IS_EDITING_MODE);
      if (!payloadAppliedNow) {
        formContainer.style.display = "block";
        if (formEl) formEl.innerHTML = "";
      }
      ensureEditModePayloadPolling(!IS_EDITING_MODE);
    } else if (columnJson) {
      applyColumnJson(columnJson, { persistRestore: true });
      setTimeout(() => {
        if (MANUAL_DATA_JSON) {
          loadJsonSafeToForm("human", MANUAL_DATA_JSON, { source: "initializeApp", stage: "initial-human-json" });
        }
        if (MANUAL_PREDICTED_JSON) {
          loadJsonSafeToForm("ai", MANUAL_PREDICTED_JSON, { source: "initializeApp", stage: "initial-predicted-json" });
          initializeSourceByFieldFromAi();
          refreshAllFields();
        }
      }, 0);
    } else {
      formEl.innerHTML = "";
      formContainer.style.display = "none";
    }
    })();
  </script>
</body>
</html>
