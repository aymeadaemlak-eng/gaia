<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Dynamic Form Element Demo</title>
  <!--
  ‚ùóÔ∏èBU BLOK ARTIK DEƒûƒ∞≈ûTƒ∞Rƒ∞LMEYECEK. ALTINDAN G√úNCELLEME YAPILACAK.
  Veriyi tam buraya gireceksin (√∂rnek deƒüerlerle g√∂sterim):
  -->
  <script>
    window.BUBBLE_INPUTS = {
      COLUMN_JSON: {
        columns: [
          { fieldName: "Ad Soyad", type: "text", required: true }
        ],
        currentDateTimeISO: "2026-02-09T12:34:56+03:00",
        locale: "tr-TR",
        timezone: "Europe/Istanbul",
        mode: "create"
      },
      BUBBLE_DATA_JSON: {
        "Ad Soyad": "Ay≈üe Yƒ±lmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      PREDICTED_JSON: {
        "Ad Soyad": "Ay≈üe Yƒ±lmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      VERSION: true
    };
  </script>
  <style>
    :root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e5e7eb;
      --danger: #ef4444;
      --success: #16a34a;
      --warning: #f59e0b;
      --focus: rgba(37, 99, 235, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      gap: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    h1, h2, h3 {
      margin: 0 0 12px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .required-star {
      color: var(--danger);
      font-weight: 700;
    }

    .required-hint {
      font-size: 0.75rem;
      color: var(--danger);
      font-weight: 600;
    }

    .field-wrapper {
      display: grid;
      gap: 6px;
      padding: 8px 0;
      border-bottom: 1px solid #eef2f7;
      transition: box-shadow 0.2s ease, transform 0.2s ease;
    }

    .field-wrapper:last-child {
      border-bottom: none;
    }

    .field-wrapper:hover {
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.08);
      transform: translateY(-1px);
      border-radius: 12px;
    }

    .field-row {
      display: grid;
      grid-template-columns: minmax(180px, 35%) minmax(0, 65%);
      gap: 14px;
      align-items: start;
    }

    .field-label {
      display: grid;
      gap: 4px;
    }

    .label-top {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .label-text {
      font-weight: 700;
    }

    .label-meta {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 6px;
    }

    .type-icon {
      font-size: 14px;
      line-height: 1;
    }

    .stage-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: capitalize;
    }

    .stage-optional {
      background: #f3f4f6;
      color: #6b7280;
    }

    .stage-mandatory {
      background: rgba(239, 68, 68, 0.12);
      color: var(--danger);
    }

    .stage-control {
      background: rgba(37, 99, 235, 0.12);
      color: var(--primary);
    }

    .ai-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(37, 99, 235, 0.25);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.12), rgba(99, 102, 241, 0.2));
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 0.7rem;
      cursor: pointer;
      color: var(--primary);
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .ai-badge img {
      width: 14px;
      height: 14px;
      display: inline-block;
      object-fit: contain;
    }

    .ai-badge.is-active {
      border-color: rgba(34, 197, 94, 0.4);
      background: rgba(34, 197, 94, 0.12);
      color: #15803d;
    }

    .ai-badge.is-passive {
      opacity: 0.7;
      filter: grayscale(0.2);
    }

    .ai-badge::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.5), transparent);
      transform: translateX(-120%);
      animation: sparkle 4s ease-in-out infinite;
      opacity: 0.4;
      pointer-events: none;
    }

    @keyframes sparkle {
      0%, 70% {
        transform: translateX(-120%);
      }
      100% {
        transform: translateX(120%);
      }
    }

    .control-stack {
      display: grid;
      gap: 6px;
    }

    .field-control {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2px;
      background: #fff;
      position: relative;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .field-control::before {
      content: "";
      position: absolute;
      left: 0;
      top: 6px;
      bottom: 6px;
      width: 4px;
      border-radius: 999px;
      background: transparent;
      opacity: 0.6;
    }

    .field-control.stage-optional::before {
      background: #d1d5db;
    }

    .field-control.stage-mandatory::before {
      background: var(--danger);
    }

    .field-control.stage-control::before {
      background: var(--primary);
    }

    .field-control.ai-active {
      background: rgba(37, 99, 235, 0.06);
    }

    .field-control.ai-active .field-input {
      background: rgba(37, 99, 235, 0.04);
      padding-right: 56px;
    }

    .ai-pill {
      position: absolute;
      top: 6px;
      right: 36px;
      font-size: 0.65rem;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.14);
      color: var(--primary);
      pointer-events: none;
    }

    .field-control:focus-within {
      border-color: rgba(37, 99, 235, 0.75);
      box-shadow: 0 0 0 3px var(--focus);
    }

    .field-control.invalid {
      border-color: rgba(239, 68, 68, 0.75);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.18);
    }

    .field-input,
    select,
    textarea {
      width: 100%;
      border: none;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 0.85rem;
      background: transparent;
      color: var(--text);
      outline: none;
      min-height: 34px;
    }

    textarea.field-input {
      resize: vertical;
      min-height: 96px;
    }

    .field-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .helper-text {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .error-text {
      font-size: 0.75rem;
      color: var(--danger);
      min-height: 16px;
    }

    .inline-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
    }

    button.secondary {
      background: #e5e7eb;
      color: var(--text);
    }

    button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .console {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.82rem;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      font-size: 0.7rem;
      font-weight: 600;
    }

    .chip button {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(37, 99, 235, 0.2);
    }

    .file-drop {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      color: var(--muted);
      background: #fafafa;
    }

    .file-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    .file-grid {
      display: grid;
      gap: 8px;
      margin-top: 10px;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    }

    .file-item {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
    }

    .file-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
      background: #fff;
      position: relative;
      overflow: hidden;
    }

    .file-meta {
      display: grid;
      gap: 4px;
      font-size: 0.82rem;
    }

    .file-thumb {
      width: 52px;
      height: 52px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid var(--border);
      background: #f3f4f6;
    }

    .file-thumb.large {
      width: 100%;
      height: 90px;
    }

    .file-thumb-wrap {
      position: relative;
      display: inline-block;
    }

    .file-thumb-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.2s ease;
      border-radius: 8px;
    }

    .file-thumb-wrap:hover .file-thumb-overlay {
      opacity: 1;
    }

    .preview-btn {
      border: none;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .conflict-chip {
      background: rgba(239, 68, 68, 0.12);
      color: var(--danger);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
    }

    .conflict-popover {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 6px;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-width: 220px;
      max-width: 320px;
      width: max-content;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.16);
      display: none;
      z-index: 20;
    }

    .conflict-popover.open {
      display: grid;
      gap: 6px;
    }

    .conflict-popover pre {
      margin: 0;
      padding: 6px 8px;
      background: #f8fafc;
      border-radius: 8px;
      font-size: 0.72rem;
      max-height: 120px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .conflict-popover small {
      color: var(--muted);
      font-weight: 600;
    }

    .conflict-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .conflict-actions button {
      padding: 6px 10px;
      font-size: 0.72rem;
    }

    .date-wrapper {
      position: relative;
      display: grid;
      gap: 6px;
    }

    .date-overlay-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-icon {
      font-size: 22px;
      width: 44px;
      text-align: center;
    }

    .file-remove {
      border: none;
      background: transparent;
      color: var(--danger);
      font-weight: 700;
      cursor: pointer;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .toggle input {
      width: 40px;
      height: 22px;
    }

    .summary-box {
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
    }

    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 999;
    }

    .lightbox.open {
      display: flex;
    }

    .lightbox-content {
      max-width: min(720px, 90vw);
      max-height: 80vh;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .lightbox-content img {
      width: 100%;
      height: auto;
      border-radius: 12px;
    }

    .lightbox-close {
      justify-self: end;
      background: #111827;
      color: #fff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
    }

    .debug-toolbar {
      position: sticky;
      top: 12px;
      z-index: 10;
      display: grid;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
    }

    .toolbar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .toolbar-actions button {
      padding: 8px 12px;
      font-size: 0.78rem;
    }

    .toolbar-status {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 600;
    }

    .debug-warning {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #f8fafc;
      margin-bottom: 16px;
    }

    .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

    .export-modal.open {
      display: flex;
    }

    .export-panel {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      width: min(920px, 95vw);
      max-height: 85vh;
      display: grid;
      gap: 12px;
    }

    .export-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .export-tabs button {
      padding: 6px 10px;
      font-size: 0.75rem;
    }

    .export-tabs button.active {
      background: var(--primary);
      color: #fff;
    }

    .export-panel textarea {
      width: 100%;
      min-height: 240px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
    }

    .input-error {
      color: var(--danger);
      font-size: 0.75rem;
      font-weight: 600;
      min-height: 16px;
    }

    @media (max-width: 720px) {
      .field-row {
        grid-template-columns: 1fr;
        gap: 6px;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <div id="debugPanels">
      <section class="card" id="jsonInputsSection">
      <h2>Bubble JSON Giri≈üleri</h2>
      <p class="helper-text">
        Bubble‚Äôdan gelen JSON verilerini buraya yapƒ±≈ütƒ±rƒ±n. Hatalƒ± JSON girildiƒüinde ilgili alan kƒ±rmƒ±zƒ± uyarƒ± verir.
      </p>
      <div class="grid three">
        <div>
          <label for="columnJsonInput">Column JSON</label>
          <textarea id="columnJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="columnJsonError"></div>
        </div>
        <div>
          <label for="humanJsonInput">Bubble Data JSON</label>
          <textarea id="humanJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="humanJsonError"></div>
        </div>
        <div>
          <label for="predictedJsonInput">Predicted JSON</label>
          <textarea id="predictedJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="predictedJsonError"></div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <input id="versionInput" type="checkbox" />
        <label for="versionInput">version (true ise sadece form g√∂r√ºns√ºn)</label>
      </div>
      </section>

      <section class="card">
      <h1>Bubble Dynamic Form Element</h1>
      <p class="helper-text">
        Bu demo tek HTML dosyasƒ±nda √ßalƒ±≈üƒ±r. Bubble elementine alan ≈üemasƒ±nƒ± JSON olarak girip ‚ÄúRender Et‚Äù diyebilirsiniz.
      </p>
      <div class="grid two">
        <div>
          <label for="schemaInput">Schema (fields + config)</label>
          <textarea id="schemaInput" class="field-input" rows="12"></textarea>
        </div>
        <div class="grid">
          <div>
            <label for="currentDateTime">currentDateTimeISO</label>
            <input id="currentDateTime" class="field-input" type="text" />
          </div>
          <div class="grid two">
            <div>
              <label for="localeInput">locale</label>
              <input id="localeInput" class="field-input" type="text" value="tr-TR" />
            </div>
            <div>
              <label for="timezoneInput">timezone</label>
              <input id="timezoneInput" class="field-input" type="text" value="Europe/Istanbul" />
            </div>
          </div>
          <div class="grid two">
            <div>
              <label for="modeInput">mode</label>
              <select id="modeInput" class="field-input">
                <option value="create">create</option>
                <option value="edit">edit</option>
              </select>
            </div>
            <div>
              <label for="requiredPolicyInput">requiredPolicy</label>
              <select id="requiredPolicyInput" class="field-input">
                <option value="strict">strict</option>
                <option value="soft">soft</option>
              </select>
            </div>
          </div>
          <div class="grid two">
            <div class="inline-row">
              <input id="showInlineHelp" type="checkbox" checked />
              <label for="showInlineHelp">showInlineHelp</label>
            </div>
            <div class="inline-row">
              <input id="autoFocusInvalid" type="checkbox" checked />
              <label for="autoFocusInvalid">autoFocusFirstInvalid</label>
            </div>
          </div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="loadSample">√ñrnek Schema Y√ºkle</button>
        <button class="secondary" id="renderForm">Render Et</button>
        <button class="ghost" id="clearConsole">Console Temizle</button>
      </div>
      </section>

      <section class="card" id="eventConsoleSection">
        <h2>Event Console</h2>
        <div id="eventConsole" class="console"></div>
      </section>

      <section class="card" id="submitOutputsSection">
        <h2>Submit Outputs</h2>
        <div id="submitOutputs" class="console"></div>
      </section>

      <section class="card">
        <h2>Dynamic Form</h2>
        <div class="debug-toolbar" id="debugToolbar">
        <div class="toolbar-actions">
          <button type="button" id="loadColumnJson">Column Y√ºkle (√ñrnek)</button>
          <button type="button" class="secondary" id="loadHumanJson">Human JSON Y√ºkle</button>
          <button type="button" class="secondary" id="loadPredictedJson">Predicted JSON Y√ºkle</button>
          <button type="button" class="ghost" id="applyAiToEmpty">AI -> Bo≈ü Human Alanlara Uygula</button>
          <button type="button" class="ghost" id="overwriteAiToAll">AI -> Hepsini Overwrite</button>
          <button type="button" class="ghost" id="resetStores">Reset</button>
          <button type="button" class="secondary" id="exportJson">Export JSON</button>
          <button type="button" class="ghost" id="scenarioColumnOnly">Scenario: Column</button>
          <button type="button" class="ghost" id="scenarioColumnHuman">Scenario: Column+Human</button>
          <button type="button" class="ghost" id="scenarioColumnAi">Scenario: Column+AI</button>
          <button type="button" class="ghost" id="scenarioColumnAiHuman">Scenario: Column+AI+Human</button>
          <button type="button" class="ghost" id="scenarioConflict">Scenario: Conflict</button>
        </div>
        <div class="toolbar-status">
          <span id="aiFieldCount">AI alan sayƒ±sƒ±: 0</span>
          <span id="humanFieldCount">Human deƒüi≈ütirilen alan sayƒ±sƒ±: 0</span>
        </div>
        </div>
        <div id="columnWarning" class="debug-warning" style="display:none;">
          Column JSON y√ºklenmedi. Debug toolbar √ºzerinden √∂rnek y√ºkleyin.
        </div>
      </section>
    </div>

    <section class="card">
      <div id="formContainer">
        <div id="summaryBox" class="summary-box" style="display:none;"></div>
        <form id="dynamicForm" class="grid"></form>
        <div class="inline-row" id="formActions" style="margin-top: 12px;">
          <button id="submitBtn" type="submit">Submit</button>
          <button id="clearBtn" type="button" class="ghost">Temizle</button>
        </div>
      </div>
    </section>
  </main>
  <div id="lightbox" class="lightbox" aria-hidden="true">
    <div class="lightbox-content">
      <button type="button" class="lightbox-close">Kapat</button>
      <img id="lightboxImage" alt="√ñnizleme" />
    </div>
  </div>
  <div id="exportModal" class="export-modal" aria-hidden="true">
    <div class="export-panel">
      <div class="inline-row" style="justify-content: space-between;">
        <strong>JSON Export</strong>
        <button type="button" class="ghost" id="closeExport">Kapat</button>
      </div>
      <div class="export-tabs">
        <button type="button" class="secondary active" data-export-tab="export">Aktif JSON</button>
        <button type="button" class="secondary" data-export-tab="human">Human JSON</button>
        <button type="button" class="secondary" data-export-tab="ai">Predicted JSON</button>
        <button type="button" class="secondary" data-export-tab="column">Column JSON</button>
      </div>
      <textarea id="exportContent" readonly></textarea>
    </div>
  </div>

  <script>
    (function () {
      const BDF = (window.__BDF__ = window.__BDF__ || {});
      const IS_VERSION_MODE = Boolean(window.BUBBLE_INPUTS?.VERSION);
      const IS_DEBUG_MODE = Boolean(window.BUBBLE_INPUTS?.DEBUG_MODE);
      BDF.DEBUG_MODE = IS_DEBUG_MODE && !IS_VERSION_MODE;

      const INITIAL_INPUTS = window.BUBBLE_INPUTS || {};

    let MANUAL_COLUMN_JSON = INITIAL_INPUTS.COLUMN_JSON || null;
    let MANUAL_DATA_JSON = INITIAL_INPUTS.BUBBLE_DATA_JSON || null;
    let MANUAL_PREDICTED_JSON = INITIAL_INPUTS.PREDICTED_JSON || null;

    const SAMPLE_COLUMN_JSON = {
      columns: [
        {
          fieldName: "Davacƒ± Ad Soyad",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Davacƒ± TCKN/VKN",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Kaza Tarihi",
          type: "date",
          required: true,
          stageType: "mandatory",
          default: "$TODAY"
        },
        {
          fieldName: "ƒ∞htar Tarihi",
          type: "date",
          required: false,
          stageType: "optional"
        },
        {
          fieldName: "Randevu Datetime",
          type: "datetime",
          stageType: "control"
        },
        {
          fieldName: "Uygun Saat",
          type: "time",
          stageType: "optional"
        },
        {
          fieldName: "Aracƒ±n Tipi",
          type: "dropdown",
          stageType: "mandatory",
          options: [
            { value: "Hususi", label: "Hususi" },
            { value: "Ticari", label: "Ticari" },
            { value: "Kiralƒ±k", label: "Kiralƒ±k" }
          ]
        },
        {
          fieldName: "Ek √ñzellikler",
          type: "dropdown",
          stageType: "optional",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri g√∂r√º≈ü kamera" }
          ]
        },
        {
          fieldName: "Hasar Onarƒ±m Tutarƒ±",
          type: "currency",
          stageType: "mandatory"
        },
        {
          fieldName: "Kusur Oranƒ±",
          type: "percent",
          stageType: "mandatory"
        },
        {
          fieldName: "Aracƒ±n Kilometresi",
          type: "number",
          stageType: "optional"
        },
        {
          fieldName: "Belgeleri Y√ºkle",
          type: "file",
          allowMultiple: false,
          stageType: "control"
        },
        {
          fieldName: "Hasar Fotoƒüraflarƒ±",
          type: "image",
          allowMultiple: true,
          stageType: "optional"
        },
        {
          fieldName: "Ek Dosyalar",
          type: "multifile",
          allowMultiple: true,
          stageType: "optional"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create"
    };

    const SAMPLE_DATA_JSON = {
      "Belgeleri Y√ºkle": "https://gaiasphere.io/version-live/fileupload/f1770577885537x578585456537153500/hasar_ekspertiz_raporu.pdf",
      "Davacƒ± Kimlik Tipi": "TC Kimlik",
      "Davacƒ± Ad Soyad": "ƒ∞SMAƒ∞L Dƒ∞NCER",
      "Davacƒ± TCKN/VKN": "12928963404",
      "Davacƒ± Plaka": "19BA618",
      "Davacƒ± Marka Model": "TOYOTA COROLLA 1,6 TERRA SEDAN (Y) 2006",
      "Davacƒ± ≈ûase No": "NMTBZ28E90R141719",
      "Kar≈üƒ± Ad Soyad": "YILMAZ HI≈ûIR",
      "Kar≈üƒ± TCKN/VKN": "31066362344",
      "Kar≈üƒ± Plaka": "19ABA563",
      "Kaza Tarihi": "2024-11-15",
      "Aracƒ±n Markasƒ±": "TOYOTA",
      "Aracƒ±n Tipi": "Hususi",
      "Aracƒ±n Model Yƒ±lƒ±": "2006",
      "Kaza Yeri": "√áorum / Merkez / √ñƒüretmen Lisesi 1. Cad. ‚Äì √ñƒüretmen Lisesi Cad. kav≈üaƒüƒ±",
      "Davacƒ± Ara√ß S√ºr√ºc√ºs√º": "ƒ∞SMAƒ∞L Dƒ∞NCER",
      "Kar≈üƒ± Ara√ß S√ºr√ºc√ºs√º": "YILMAZ HI≈ûIR",
      "Kar≈üƒ± Poli√ße T√ºr√º": "Zorunlu Trafik Sigortasƒ±",
      "Kar≈üƒ± Poli√ße No": "104781355",
      "Kar≈üƒ± Poli√ße Biti≈ü Tarihi": "2025-09-03",
      "Kaza tespit tutanaƒüƒ± t√ºr√º": "Anla≈ümalƒ± Kaza Tespit Tutanaƒüƒ±",
      "Eksper Rp Tarihi": "2025-02-28",
      "Hasar Onarƒ±m Tutarƒ±": "140000",
      "Kusur Oranƒ±": "75",
      "Davali Adi": "Corpus Sigorta A.≈û.",
      "Aracƒ±n Kilometresi": "231328",
      "action": "DK Hesaba Ta≈üƒ±",
      "ƒ∞htar Tarihi": "Bug√ºn√ºn tarihi",
      "predictedAction": "ƒ∞htar Dilek√ßesi Hazƒ±rla",
      "uniqueid": "1770577890579x349136294770973500",
      "Stage": "DK Hesabƒ±",
      "Hasar Fotoƒüraflarƒ±": [
        "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=800&q=60",
        "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=800&q=60"
      ],
      "Ek Dosyalar": [
        "https://example.com/docs/hasar-foto-1.pdf",
        "https://example.com/docs/hasar-foto-2.pdf"
      ],
      "Esas No": ""
    };

    const SAMPLE_PREDICTED_JSON = {
      "ƒ∞htar Tarihi": "$TODAY",
      "Hasar Onarƒ±m Tutarƒ±": "145000",
      "Kusur Oranƒ±": "80",
      "predictedAction": "ƒ∞htar Dilek√ßesi Hazƒ±rla"
    };

    let columnJson = null;
    let humanData = {};
    let aiData = {};
    let sourceByField = {};
    let taskStartTimestamp = null;
    let initialSnapshot = null;

    const schemaInput = document.getElementById("schemaInput");
    const columnJsonInput = document.getElementById("columnJsonInput");
    const humanJsonInput = document.getElementById("humanJsonInput");
    const predictedJsonInput = document.getElementById("predictedJsonInput");
    const columnJsonError = document.getElementById("columnJsonError");
    const humanJsonError = document.getElementById("humanJsonError");
    const predictedJsonError = document.getElementById("predictedJsonError");
    const versionInput = document.getElementById("versionInput");
    const jsonInputsSection = document.getElementById("jsonInputsSection");
    const debugPanels = document.getElementById("debugPanels");
    const currentDateTimeInput = document.getElementById("currentDateTime");
    const localeInput = document.getElementById("localeInput");
    const timezoneInput = document.getElementById("timezoneInput");
    const modeInput = document.getElementById("modeInput");
    const requiredPolicyInput = document.getElementById("requiredPolicyInput");
    const showInlineHelpInput = document.getElementById("showInlineHelp");
    const autoFocusInvalidInput = document.getElementById("autoFocusInvalid");
    const formEl = document.getElementById("dynamicForm");
    const submitBtn = document.getElementById("submitBtn");
    const clearBtn = document.getElementById("clearBtn");
    const summaryBox = document.getElementById("summaryBox");
    const formContainer = document.getElementById("formContainer");
    const formActions = document.getElementById("formActions");
    const consoleEl = document.getElementById("eventConsole");
    const submitOutputsEl = document.getElementById("submitOutputs");
    const eventConsoleSection = document.getElementById("eventConsoleSection");
    const submitOutputsSection = document.getElementById("submitOutputsSection");
    const lightboxEl = document.getElementById("lightbox");
    const lightboxImage = document.getElementById("lightboxImage");
    const exportModal = document.getElementById("exportModal");
    const exportContent = document.getElementById("exportContent");
    const exportTabs = document.querySelectorAll("[data-export-tab]");
    const loadHumanJsonBtn = document.getElementById("loadHumanJson");
    const loadPredictedJsonBtn = document.getElementById("loadPredictedJson");
    const loadColumnJsonBtn = document.getElementById("loadColumnJson");
    const applyAiToEmptyBtn = document.getElementById("applyAiToEmpty");
    const overwriteAiToAllBtn = document.getElementById("overwriteAiToAll");
    const resetStoresBtn = document.getElementById("resetStores");
    const scenarioColumnOnlyBtn = document.getElementById("scenarioColumnOnly");
    const scenarioColumnHumanBtn = document.getElementById("scenarioColumnHuman");
    const scenarioColumnAiBtn = document.getElementById("scenarioColumnAi");
    const scenarioColumnAiHumanBtn = document.getElementById("scenarioColumnAiHuman");
    const scenarioConflictBtn = document.getElementById("scenarioConflict");
    const exportJsonBtn = document.getElementById("exportJson");
    const closeExportBtn = document.getElementById("closeExport");
    const aiFieldCountEl = document.getElementById("aiFieldCount");
    const humanFieldCountEl = document.getElementById("humanFieldCount");
    const columnWarning = document.getElementById("columnWarning");
    const debugToolbar = document.getElementById("debugToolbar");

    if (columnJsonInput && MANUAL_COLUMN_JSON) {
      columnJsonInput.value = JSON.stringify(MANUAL_COLUMN_JSON, null, 2);
    }
    if (humanJsonInput && MANUAL_DATA_JSON) {
      humanJsonInput.value = JSON.stringify(MANUAL_DATA_JSON, null, 2);
    }
    if (predictedJsonInput && MANUAL_PREDICTED_JSON) {
      predictedJsonInput.value = JSON.stringify(MANUAL_PREDICTED_JSON, null, 2);
    }
    if (versionInput) {
      versionInput.checked = IS_VERSION_MODE;
    }

    const state = {
      config: null,
      values: {},
      validMap: {},
      touched: {},
      errors: {},
      autoSaveTimer: null,
      fileBuffers: {},
      fileStaging: {},
      fieldRefs: {},
      columnData: null
    };

    const defaultSchema = {
      fields: [
        {
          key: "fullName",
          label: "Ad Soyad",
          type: "text",
          required: true,
          placeholder: "√ñrn. Ay≈üe Yƒ±lmaz",
          helpText: "Kimlikteki ad-soyad",
          minLen: 3
        },
        {
          key: "email",
          label: "E-posta",
          type: "email",
          required: true,
          placeholder: "ornek@mail.com"
        },
        {
          key: "phone",
          label: "Telefon",
          type: "phone",
          required: true,
          placeholder: "05xx xxx xx xx",
          ui: { autoTrPrefix: true }
        },
        {
          key: "website",
          label: "Website",
          type: "url",
          placeholder: "https://",
          ui: { suggestHttps: true }
        },
        {
          key: "password",
          label: "≈ûifre",
          type: "password",
          required: true,
          minLen: 8
        },
        {
          key: "bio",
          label: "A√ßƒ±klama",
          type: "textarea",
          placeholder: "Kƒ±sa notlar...",
          maxLen: 240
        },
        {
          key: "age",
          label: "Ya≈ü",
          type: "integer",
          min: 18,
          max: 99
        },
        {
          key: "salary",
          label: "Maa≈ü (‚Ç∫)",
          type: "currency",
          ui: { currency: "‚Ç∫", step: 0.01, thousandSeparator: true }
        },
        {
          key: "discount",
          label: "ƒ∞ndirim (%)",
          type: "percent",
          ui: { step: 0.1 }
        },
        {
          key: "subscribe",
          label: "KVKK Onayƒ±",
          type: "boolean",
          required: true,
          helpText: "Zorunlu onay"
        },
        {
          key: "vehicleType",
          label: "Ara√ß Tipi",
          type: "dropdown",
          options: [
            { value: "hususi", label: "Hususi", group: "Binek" },
            { value: "ticari", label: "Ticari", group: "Ticari" },
            { value: "kiralik", label: "Kiralƒ±k", group: "Ticari" }
          ],
          required: true
        },
        {
          key: "extras",
          label: "Ek √ñzellikler",
          type: "dropdown",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri g√∂r√º≈ü kamera" },
            { value: "isik", label: "LED far" }
          ]
        },
        {
          key: "appointmentDate",
          label: "Randevu Tarihi",
          type: "date",
          required: true,
          default: "$TODAY",
          ui: { showCalendar: true, allowTyping: true, quickActions: true }
        },
        {
          key: "appointmentDateTime",
          label: "Randevu Datetime",
          type: "datetime",
          default: "$NOW",
          ui: { quickActions: true }
        },
        {
          key: "appointmentTime",
          label: "Uygun Saat",
          type: "time",
          default: "$CURRENT_TIME",
          ui: { quickActions: true }
        },
        {
          key: "duration",
          label: "S√ºre",
          type: "duration",
          ui: { durationFormat: "minutes" }
        },
        {
          key: "address",
          label: "Adres",
          type: "address",
          helpText: "Minimum sokak, il√ße, il ve posta kodu"
        },
        {
          key: "attachments",
          label: "Dosyalar",
          type: "multifile",
          ui: { accept: "image/*,application/pdf", maxFiles: 5, maxSizeMB: 10, showPreview: true }
        },
        {
          key: "profileImage",
          label: "Profil Fotoƒürafƒ±",
          type: "image",
          ui: { accept: "image/*", maxFiles: 1, maxSizeMB: 5, showPreview: true }
        },
        {
          key: "metadata",
          label: "JSON (advanced)",
          type: "json",
          placeholder: "{\"foo\":\"bar\"}"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create",
      initialValues: {},
      requiredPolicy: "strict",
      showInlineHelp: true,
      autoFocusFirstInvalid: true
    };

    function parseJsonInput(value, errorEl) {
      const trimmed = value.trim();
      if (!trimmed) {
        if (errorEl) errorEl.textContent = "";
        return null;
      }
      try {
        const parsed = JSON.parse(trimmed);
        if (errorEl) errorEl.textContent = "";
        return parsed;
      } catch (error) {
        if (errorEl) errorEl.textContent = "JSON formatƒ± hatalƒ±.";
        return null;
      }
    }

    function syncManualJsonInputs() {
      MANUAL_COLUMN_JSON = parseJsonInput(columnJsonInput?.value || "", columnJsonError);
      MANUAL_DATA_JSON = parseJsonInput(humanJsonInput?.value || "", humanJsonError);
      MANUAL_PREDICTED_JSON = parseJsonInput(predictedJsonInput?.value || "", predictedJsonError);
    }

    function applyVersionVisibility() {
      const formOnly = IS_VERSION_MODE;
      const debugVisible = !formOnly && BDF.DEBUG_MODE;
      if (debugPanels) {
        debugPanels.style.display = debugVisible ? "block" : "none";
      }
      if (jsonInputsSection) {
        jsonInputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (eventConsoleSection) {
        eventConsoleSection.style.display = debugVisible ? "block" : "none";
      }
      if (submitOutputsSection) {
        submitOutputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (debugToolbar) {
        debugToolbar.style.display = debugVisible ? "flex" : "none";
      }
      if (columnWarning) {
        columnWarning.style.display = debugVisible && !columnJson ? "block" : "none";
      }
    if (formActions) {
        formActions.style.display = "none";
      }
      if (formContainer) {
        formContainer.style.display = "block";
        const formSection = formContainer.closest("section");
        if (formSection) {
          Array.from(formSection.children).forEach((child) => {
            if (child === formContainer) return;
            child.style.display = formOnly ? "none" : "";
          });
        }
      }
    }

    const sampleColumnData = {
      columns: defaultSchema.fields.map((field) => ({
        key: field.key,
        label: field.label,
        type: field.type
      })),
      source: "sample-column-json"
    };

    function setConsole(message, payload) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      if (!consoleEl) return;
      const timestamp = new Date().toLocaleTimeString("tr-TR");
      consoleEl.textContent += `[${timestamp}] ${message}` + (payload ? `\n${payload}` : "") + "\n";
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function renderSubmitOutputs(payload) {
      if (IS_VERSION_MODE) return;
      if (!submitOutputsEl) {
        console.warn("submitOutputs panel not found");
        return;
      }
      const safePayload = payload || {};
      const listToText = (list) => (Array.isArray(list) ? list.join("\n") : String(list ?? ""));
      submitOutputsEl.textContent = [
        `output1: ${safePayload.output1 ?? ""}`,
        `output2: ${safePayload.output2 ?? ""}`,
        `output3: ${safePayload.output3 ?? ""}`,
        "outputlist1:",
        listToText(safePayload.outputlist1),
        "outputlist2:",
        listToText(safePayload.outputlist2),
        "outputlist3:",
        listToText(safePayload.outputlist3),
        "outputlist4:",
        listToText(safePayload.outputlist4)
      ].join("\n");
      console.info("submitOutputs rendered", safePayload);
    }

    function buildSubmitOutputsPayload() {
      const endTimestamp = new Date().toISOString();
      const startTimestamp = taskStartTimestamp || endTimestamp;
      const durationMs = new Date(endTimestamp).getTime() - new Date(startTimestamp).getTime();
      return {
        output1: startTimestamp,
        output2: endTimestamp,
        output3: durationMs,
        outputlist1: buildKeyValueListFromSources(),
        outputlist2: buildAddedCustomFields(),
        outputlist3: buildDeletedFields(),
        outputlist4: buildModifiedFields()
      };
    }

    function emit(eventName, detail) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      setConsole(eventName, JSON.stringify(detail, null, 2));
    }

    function safeJsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return null;
      }
    }

    function getCurrentDateTime(config) {
      return config.currentDateTimeISO || new Date().toISOString();
    }

    function getOffsetFromIso(iso) {
      const match = String(iso).match(/([+-]\d{2}:?\d{2}|Z)$/);
      if (!match) return "Z";
      if (match[1] === "Z") return "Z";
      const offset = match[1].includes(":") ? match[1] : `${match[1].slice(0, 3)}:${match[1].slice(3)}`;
      return offset;
    }

    function getDateFromIso(iso) {
      return String(iso).slice(0, 10);
    }

    function getTimeFromIso(iso) {
      return String(iso).slice(11, 16);
    }

    function normalizeDateInput(raw) {
      if (!raw) return "";
      const trimmed = raw.trim();
      if (trimmed.includes("T")) {
        return trimmed.slice(0, 10);
      }
      if (trimmed.includes(" ")) {
        return trimmed.split(" ")[0];
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmed)) {
        const [d, m, y] = trimmed.split(".");
        return `${y}-${m}-${d}`;
      }
      if (/^\d{8}$/.test(trimmed)) {
        const d = trimmed.slice(0, 2);
        const m = trimmed.slice(2, 4);
        const y = trimmed.slice(4, 8);
        return `${y}-${m}-${d}`;
      }
      return trimmed;
    }

    function isValidDateString(value) {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return false;
      const [year, month, day] = value.split("-").map((part) => Number(part));
      if (year < 1000 || year > 9999) return false;
      const date = new Date(year, month - 1, day);
      return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
    }

    function areValuesDifferent(a, b) {
      if (isEmptyValue(a) && isEmptyValue(b)) return false;
      if (Array.isArray(a) || Array.isArray(b) || typeof a === "object" || typeof b === "object") {
        return JSON.stringify(a ?? null) !== JSON.stringify(b ?? null);
      }
      return String(a ?? "") !== String(b ?? "");
    }

    function formatValueForDisplay(value) {
      if (Array.isArray(value) || typeof value === "object") {
        return JSON.stringify(value, null, 2);
      }
      return String(value ?? "");
    }

    function normalizeTimeInput(raw) {
      if (!raw) return "";
      const cleaned = raw.replace(/\s/g, "");
      if (/^\d{1,2}$/.test(cleaned)) return `${cleaned.padStart(2, "0")}:00`;
      if (/^\d{3}$/.test(cleaned)) return `${cleaned.slice(0, 1).padStart(2, "0")}:${cleaned.slice(1)}`;
      if (/^\d{4}$/.test(cleaned)) return `${cleaned.slice(0, 2)}:${cleaned.slice(2)}`;
      if (/^\d{2}:\d{2}$/.test(cleaned)) return cleaned;
      return cleaned;
    }

    function normalizeDateTimeInput(raw, config) {
      if (!raw) return "";
      const trimmed = String(raw).trim().replace(" ", "T");
      const offset = getOffsetFromIso(getCurrentDateTime(config));
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
        return `${trimmed}T00:00:00${offset}`;
      }
      const match = trimmed.match(/^(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2})(:\d{2})?(Z|[+-]\d{2}:?\d{2})?$/);
      if (match) {
        const [, datePart, timePart, secondsPart, tzPart] = match;
        const seconds = secondsPart || ":00";
        const tz = tzPart ? (tzPart.includes(":") || tzPart === "Z" ? tzPart : `${tzPart.slice(0, 3)}:${tzPart.slice(3)}`) : offset;
        return `${datePart}T${timePart}${seconds}${tz}`;
      }
      return trimmed;
    }

    function normalizeNumberInput(raw) {
      if (raw === null || raw === undefined || raw === "") return "";
      const normalized = String(raw).replace(/\./g, "").replace(",", ".");
      return normalized;
    }

    function formatNumberDisplay(value, options = {}) {
      if (value === "" || value === null || value === undefined || Number.isNaN(Number(value))) return "";
      const numeric = Number(value);
      const formatter = new Intl.NumberFormat("tr-TR", {
        minimumFractionDigits: options.minimumFractionDigits || 0,
        maximumFractionDigits: options.maximumFractionDigits || 2
      });
      return formatter.format(numeric);
    }

    function formatDateDisplay(value) {
      if (!value) return "";
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const [y, m, d] = value.split("-");
        return `${d}.${m}.${y}`;
      }
      return value;
    }

    function getDefaultValue(field, config) {
      if (!field.default) return "";
      const token = field.default;
      const now = getCurrentDateTime(config);
      if (token === "$NOW") return now;
      if (token === "$TODAY") return getDateFromIso(now);
      if (token === "$CURRENT_TIME") return getTimeFromIso(now);
      return token;
    }

    function getInitialValue(field, config) {
      const initialValues = config.initialValues || {};
      if (initialValues[field.key] !== undefined) return initialValues[field.key];
      if (config.mode === "create") {
        return getDefaultValue(field, config);
      }
      return "";
    }

    function isEmptyValue(value) {
      if (Array.isArray(value)) return value.length === 0;
      if (value === null || value === undefined) return true;
      if (typeof value === "string") return value.trim() === "";
      return false;
    }

    function normalizeKey(key) {
      if (key === null || key === undefined) return "";
      return String(key).trim();
    }

    function buildFieldKeyMap() {
      const map = new Map();
      (state.config?.fields || []).forEach((field) => {
        if (field.key) map.set(normalizeKey(field.key), field.key);
      });
      return map;
    }

    function getFieldKeyFromJsonKey(jsonKey, keyMap) {
      if (!jsonKey) return null;
      return keyMap.get(normalizeKey(jsonKey)) || null;
    }

    function getActiveSource(fieldKey) {
      if (!isEmptyValue(humanData[fieldKey])) return "human";
      if (!isEmptyValue(aiData[fieldKey])) return "ai";
      return "human";
    }

    function getStoreValue(fieldKey, source) {
      return source === "ai" ? aiData[fieldKey] : humanData[fieldKey];
    }

    function getEffectiveValue(fieldKey) {
      const humanValue = humanData[fieldKey];
      if (!isEmptyValue(humanValue)) return humanValue;
      const aiValue = aiData[fieldKey];
      if (!isEmptyValue(aiValue)) return aiValue;
      return "";
    }

    function ensureTaskStartTimestamp() {
      if (!taskStartTimestamp) {
        taskStartTimestamp = new Date().toISOString();
      }
    }

    function setHumanValue(fieldKey, value, field, displayValue) {
      ensureTaskStartTimestamp();
      humanData[fieldKey] = value;
      sourceByField[fieldKey] = "human";
      updateEffectiveState(fieldKey, field, displayValue);
      updateAiVisuals(fieldKey);
      updateToolbarStatus();
    }

    function updateEffectiveState(fieldKey, field, displayValue) {
      ensureTaskStartTimestamp();
      const effectiveValue = getEffectiveValue(fieldKey);
      state.values[fieldKey] = effectiveValue;
      let validationValue = effectiveValue;
      if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(effectiveValue)) {
        const stagedFiles = state.fileBuffers[fieldKey] || [];
        if (stagedFiles.length) {
          validationValue = ["__file_selected__"];
        }
      }
      const error = validateField(field, validationValue);
      state.errors[fieldKey] = error;
      state.validMap[fieldKey] = !error;
      emit("onFieldChange", {
        key: fieldKey,
        value: effectiveValue,
        displayValue: displayValue ?? effectiveValue,
        source: getActiveSource(fieldKey),
        isValid: !error
      });
      if (state.config) {
        updateSubmitState(state.config);
      }
      debounceFormChange();
    }

    function updateToolbarStatus() {
      const aiCount = Object.values(aiData).filter((value) => !isEmptyValue(value)).length;
      const humanCount = Object.entries(humanData).filter(([key, value]) => {
        return sourceByField[key] === "human" && !isEmptyValue(value);
      }).length;
      aiFieldCountEl.textContent = `AI alan sayƒ±sƒ±: ${aiCount}`;
      humanFieldCountEl.textContent = `Human deƒüi≈ütirilen alan sayƒ±sƒ±: ${humanCount}`;
    }

    const typeMetaMap = {
      text: { icon: "üìù", label: "Text" },
      textarea: { icon: "üìù", label: "Textarea" },
      email: { icon: "‚úâÔ∏è", label: "Email" },
      phone: { icon: "üìû", label: "Phone" },
      url: { icon: "üîó", label: "URL" },
      integer: { icon: "üî¢", label: "Integer" },
      number: { icon: "üî¢", label: "Number" },
      decimal: { icon: "üî¢", label: "Decimal" },
      currency: { icon: "üî¢", label: "Currency" },
      percent: { icon: "üî¢", label: "Percent" },
      boolean: { icon: "‚úÖ", label: "Boolean" },
      dropdown: { icon: "‚¨áÔ∏è", label: "Dropdown" },
      date: { icon: "üìÖ", label: "Date" },
      time: { icon: "‚è±Ô∏è", label: "Time" },
      datetime: { icon: "üóìÔ∏è‚è±Ô∏è", label: "Datetime" },
      file: { icon: "üìé", label: "File" },
      image: { icon: "üñºÔ∏è", label: "Image" },
      multifile: { icon: "üóÇÔ∏è", label: "Multi file" }
    };

    const displayTypeMetaMap = {
      "text (long)": { icon: "üìù", label: "Text (long)" },
      "multiline text": { icon: "üìù", label: "Multiline text" },
      "e-mail": { icon: "‚úâÔ∏è", label: "E-mail" },
      "image&pdf": { icon: "üìé", label: "Image&Pdf" },
      reference: { icon: "üîó", label: "Reference" },
      embed: { icon: "üîó", label: "Embed" },
      user: { icon: "üë§", label: "User" },
      "sys.cf": { icon: "‚öôÔ∏è", label: "Sys.cf" },
      "action.cf": { icon: "‚öôÔ∏è", label: "Action.cf" }
    };

    function getTypeMeta(field) {
      const displayKey = String(field.displayType || "").toLowerCase();
      return displayTypeMetaMap[displayKey] || typeMetaMap[field.type] || { icon: "üìù", label: field.type || "text" };
    }

    function normalizeStageType(stageType) {
      if (!stageType) return "";
      return String(stageType).trim().toLowerCase();
    }

    function isFieldRequired(field) {
      return Boolean(field.required) || normalizeStageType(field.stageType) === "mandatory";
    }

    function getMergedValidationValue(field) {
      return getEffectiveValue(field.key);
    }

    function getStageBadge(stageType) {
      const normalized = normalizeStageType(stageType);
      if (!["optional", "mandatory", "control"].includes(normalized)) return null;
      const badge = document.createElement("span");
      badge.className = `stage-badge stage-${normalized}`;
      badge.textContent = normalized === "optional" ? "Optional" : normalized === "mandatory" ? "Mandatory" : "Control";
      return badge;
    }

    function isImageLike(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith("image/")) return true;
      if (file.url && String(file.url).startsWith("data:image/")) return true;
      if (file.url) {
        return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(file.url);
      }
      return false;
    }

    function isDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:");
    }

    function isPdfDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:application/pdf");
    }

    function isLikelyBase64(value) {
      if (typeof value !== "string") return false;
      if (value.length < 60) return false;
      if (value.includes("://")) return false;
      if (value.startsWith("data:")) return false;
      return /^[A-Za-z0-9+/=\r\n]+$/.test(value);
    }

    function normalizeFileValueForPreview(field, value) {
      if (!value || typeof value !== "string") return value;
      if (field.type === "image" && isLikelyBase64(value)) {
        return `data:image/*;base64,${value}`;
      }
      return value;
    }

    function parseInitialFiles(initialValue, allowMultiple, field) {
      if (!initialValue) return [];
      let values = Array.isArray(initialValue) ? initialValue : [initialValue];
      if (!allowMultiple && values.length > 1) {
        values = [values[0]];
      }
      values = values.map((value) => normalizeFileValueForPreview(field, value));
      return values
        .filter((val) => typeof val === "string")
        .map((url) => ({
          url,
          name: isDataUrl(url) ? (isPdfDataUrl(url) ? "dosya.pdf" : "gorsel") : url.split("/").pop() || "dosya",
          size: 0,
          type: isImageLike({ url }) ? "image/*" : isPdfDataUrl(url) ? "application/pdf" : "",
          lastModified: null,
          preview: url
        }));
    }

    function resolveTokenValue(rawValue, field, config) {
      if (rawValue === "$TODAY") {
        return getDateFromIso(getCurrentDateTime(config));
      }
      if (rawValue === "$NOW") {
        return getCurrentDateTime(config);
      }
      if (rawValue === "$CURRENT_TIME") {
        return getTimeFromIso(getCurrentDateTime(config));
      }
      return rawValue;
    }

    function normalizeJsonValueForField(field, value, config) {
      if (value === null || value === undefined) return "";
      let resolved = resolveTokenValue(value, field, config);
      if (field.type === "date") {
        resolved = normalizeDateInput(String(resolved));
        return resolved;
      }
      if (field.type === "time") {
        resolved = normalizeTimeInput(String(resolved));
        return resolved;
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(resolved), config);
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        return normalizeNumberInput(resolved);
      }
      if (field.type === "boolean") {
        if (typeof resolved === "string") {
          return resolved.toLowerCase() === "true";
        }
        return Boolean(resolved);
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        if (Array.isArray(resolved)) return resolved;
        if (typeof resolved === "string") return resolved.split(",").map((val) => val.trim()).filter(Boolean);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(resolved)) return resolved.filter((val) => typeof val === "string");
        if (typeof resolved === "string") return resolved;
        return "";
      }
      return resolved;
    }

    function normalizeMultiValue(value) {
      if (Array.isArray(value)) {
        return Array.from(new Set(value.map((entry) => String(entry)))).sort();
      }
      if (typeof value === "string") {
        const parts = value.split(",").map((entry) => entry.trim()).filter(Boolean);
        return Array.from(new Set(parts)).sort();
      }
      return [];
    }

    function normalizeValueForComparison(field, value, config) {
      if (isEmptyValue(value)) return "";
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        const numeric = Number(normalizeNumberInput(value));
        return Number.isNaN(numeric) ? "" : numeric;
      }
      if (field.type === "date") {
        return normalizeDateInput(String(value));
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(value), config);
      }
      if (field.type === "time") {
        return normalizeTimeInput(String(value));
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        return normalizeMultiValue(value);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(value)) {
          return Array.from(new Set(value.filter((entry) => typeof entry === "string"))).sort();
        }
        return typeof value === "string" ? value : "";
      }
      if (field.type === "boolean") {
        return Boolean(value);
      }
      return value;
    }

    function updateAiVisuals(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const aiValue = aiData[fieldKey];
      const hasAi = !isEmptyValue(aiValue);
      const activeSource = getActiveSource(fieldKey);
      const humanValue = humanData[fieldKey];
      const hasHuman = !isEmptyValue(humanValue);
      const hasConflict = hasAi && hasHuman && areValuesDifferent(humanValue, aiValue);
      ref.aiBadge.style.display = hasAi ? "inline-flex" : "none";
      ref.aiBadge.classList.toggle("is-active", activeSource === "ai");
      ref.aiBadge.classList.toggle("is-passive", activeSource !== "ai" && hasAi);
      ref.control.classList.toggle("ai-active", activeSource === "ai" && hasAi);
      ref.aiPill.style.display = activeSource === "ai" && hasAi ? "inline-flex" : "none";
      if (ref.applyAiBtn) {
        ref.applyAiBtn.style.display = !hasHuman && hasAi ? "inline-flex" : "none";
      }
      if (ref.revertAiBtn) {
        ref.revertAiBtn.style.display = hasHuman && hasAi && activeSource !== "ai" ? "inline-flex" : "none";
      }
      if (ref.conflictChip) {
        ref.conflictChip.style.display = hasConflict ? "inline-flex" : "none";
      }
      if (ref.conflictPopover) {
        if (hasConflict) {
          ref.conflictPopover.querySelector("[data-conflict-human]").textContent = formatValueForDisplay(humanValue);
          ref.conflictPopover.querySelector("[data-conflict-ai]").textContent = formatValueForDisplay(aiValue);
        } else {
          ref.conflictPopover.classList.remove("open");
        }
      }
    }

    function updateFieldDisplayValue(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const value = getEffectiveValue(fieldKey);
      if (ref.setValue) {
        ref.setValue(value);
      }
      updateAiVisuals(fieldKey);
      updateEffectiveState(fieldKey, ref.field);
    }

    function refreshAllFields() {
      Object.keys(state.fieldRefs).forEach((fieldKey) => {
        updateFieldDisplayValue(fieldKey);
      });
      updateToolbarStatus();
      if (state.config) {
        updateSubmitState(state.config);
      }
    }

    function loadJsonSafeToForm(kind, jsonObj) {
      if (!jsonObj || !state.config) return;
      const keyMap = buildFieldKeyMap();
      console.info("loadJsonSafeToForm:start", { kind, keys: Object.keys(jsonObj || {}) });
      Object.entries(jsonObj).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) {
          console.warn(`E≈üle≈ümeyen JSON key: ${jsonKey}`);
          setConsole("E≈üle≈ümeyen JSON key", jsonKey);
          return;
        }
        const field = state.config.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        const normalized = normalizeJsonValueForField(field, rawValue, state.config);
        if (kind === "ai") {
          aiData[fieldKey] = normalized;
        } else {
          humanData[fieldKey] = normalized;
          sourceByField[fieldKey] = "human";
        }
      });
      refreshAllFields();
      if (state.config) {
        updateSubmitState(state.config);
      }
      console.info("loadJsonSafeToForm:done", { kind, values: buildExportJson() });
    }

    function applyScenario({ name, column, human, ai }) {
      emit("debug:scenario", { name, column, human, ai });
      applyColumnJson(column);
      humanData = {};
      aiData = {};
      sourceByField = {};
      if (human) {
        loadJsonSafeToForm("human", human);
      }
      if (ai) {
        loadJsonSafeToForm("ai", ai);
      }
      initializeSourceByFieldFromAi();
      refreshAllFields();
      if (ai && human) {
        openExportModal("export");
      } else if (ai) {
        openExportModal("ai");
      } else if (human) {
        openExportModal("human");
      } else {
        openExportModal("column");
      }
    }

    function initializeSourceByFieldFromAi() {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        sourceByField[field.key] = !isEmptyValue(aiValue) ? "ai" : "human";
      });
    }

    function normalizeAllowMultiple(value) {
      if (typeof value === "string") {
        return ["yes", "true", "1"].includes(value.trim().toLowerCase());
      }
      return Boolean(value);
    }

    function normalizeColumnType(rawType, allowMultipleValue) {
      const raw = String(rawType || "").trim();
      const normalizedRaw = raw.toLowerCase();
      let allowMultiple = normalizeAllowMultiple(allowMultipleValue);
      if (["single_select", "multi_select", "dropdown"].includes(normalizedRaw)) {
        if (normalizedRaw === "multi_select") {
          allowMultiple = true;
        }
        return { type: "dropdown", allowMultiple, displayType: raw || "dropdown" };
      }
      if (normalizedRaw === "checkbox") {
        return { type: "boolean", allowMultiple, displayType: raw || "checkbox" };
      }
      if (normalizedRaw === "text (long)" || normalizedRaw === "multiline text") {
        return { type: "textarea", allowMultiple, displayType: raw || "text (long)" };
      }
      if (normalizedRaw === "e-mail") {
        return { type: "email", allowMultiple, displayType: raw || "e-mail" };
      }
      if (normalizedRaw === "image&pdf") {
        return { type: allowMultiple ? "multifile" : "file", allowMultiple, displayType: raw || "image&pdf" };
      }
      if (["reference", "embed", "user", "sys.cf", "action.cf"].includes(normalizedRaw)) {
        return { type: "text", allowMultiple, displayType: raw || normalizedRaw };
      }
      if (normalizedRaw === "phone") {
        return { type: "phone", allowMultiple, displayType: raw || "phone" };
      }
      if (normalizedRaw === "number") {
        return { type: "number", allowMultiple, displayType: raw || "number" };
      }
      if (normalizedRaw === "date") {
        return { type: "date", allowMultiple, displayType: raw || "date" };
      }
      if (normalizedRaw === "text") {
        return { type: "text", allowMultiple, displayType: raw || "text" };
      }
      return { type: raw || "text", allowMultiple, displayType: raw || "text" };
    }

    function buildConfigFromColumnJson(columnData) {
      if (!columnData) return null;
      const columns = columnData.columns || [];
      const fields = columns.map((column, index) => {
        const fieldName = column.id || `field_${index + 1}`;
        const normalized = normalizeColumnType(column.type, column.multiple);
        const stageType = column.stageType || "optional";
        return {
          key: fieldName,
          fieldName,
          label: column.header || fieldName,
          type: normalized.type,
          displayType: normalized.displayType,
          required: normalizeStageType(stageType) === "mandatory" || Boolean(column.required),
          stageType,
          allowMultiple: Boolean(column.multiple),
          readOnly: Boolean(column.readOnly),
          options: Array.isArray(column.source) ? column.source.map((value) => ({ value, label: value })) : [],
          default: column.default,
          ui: column.ui || {}
        };
      });
      return {
        fields,
        currentDateTimeISO: columnData.currentDateTimeISO || defaultSchema.currentDateTimeISO,
        locale: columnData.locale || "tr-TR",
        timezone: columnData.timezone || "Europe/Istanbul",
        mode: columnData.mode || "create",
        requiredPolicy: defaultSchema.requiredPolicy,
        showInlineHelp: defaultSchema.showInlineHelp,
        autoFocusFirstInvalid: defaultSchema.autoFocusFirstInvalid
      };
    }

    function captureInitialSnapshot() {
      if (initialSnapshot || !state.config) return;
      initialSnapshot = buildBaselineSnapshot(MANUAL_DATA_JSON);
    }

    function applyColumnJson(columnData) {
      columnJson = columnData;
      if (!columnJson) {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
        return;
      }
      columnWarning.style.display = "none";
      formContainer.style.display = "block";
      state.config = buildConfigFromColumnJson(columnJson);
      if (!state.config) return;
      renderForm(state.config);
    }

    function buildExportJson() {
      const payload = {};
      (state.config?.fields || []).forEach((field) => {
        const value = getEffectiveValue(field.key);
        const jsonKey = field.key;
        payload[jsonKey] = normalizeValueForComparison(field, value, state.config);
      });
      return payload;
    }

    function buildBaselineSnapshot(baselineData) {
      const baseline = baselineData || {};
      const snapshot = {};
      const keyMap = buildFieldKeyMap();
      Object.entries(baseline || {}).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) return;
        const field = state.config?.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        snapshot[fieldKey] = normalizeValueForComparison(field, rawValue, state.config);
      });
      return snapshot;
    }

    function getCurrentValueForField(field) {
      const humanValue = humanData[field.key];
      if (!isEmptyValue(humanValue)) return humanValue;
      const aiValue = aiData[field.key];
      if (!isEmptyValue(aiValue)) return aiValue;
      return "";
    }

    function getCurrentNormalizedValue(field) {
      return normalizeValueForComparison(field, getCurrentValueForField(field), state.config);
    }

    function buildKeyValueListFromSources() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        const jsonKey = field.key;
        const currentValue = getCurrentNormalizedValue(field);
        const baselineValue = base[jsonKey] ?? "";
        if (!areValuesDifferent(baselineValue, currentValue)) return;
        const safeValue = isEmptyValue(currentValue) ? "" : currentValue;
        entries.push(`"${jsonKey}": ${JSON.stringify(safeValue)}`);
      });
      return entries;
    }

    function buildAddedCustomFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        if (!isEmptyValue(currentValue) && isEmptyValue(initialValue)) {
          entries.push(jsonKey);
        }
      });
      return entries;
    }

    function buildDeletedFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        if (!isEmptyValue(initialValue) && isEmptyValue(currentValue)) {
          entries.push(jsonKey);
        }
      });
      return entries;
    }

    function buildModifiedFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        if (isEmptyValue(initialValue) || isEmptyValue(currentValue)) return;
        if (areValuesDifferent(initialValue, currentValue)) {
          entries.push(jsonKey);
        }
      });
      return entries;
    }

    function getActivityType() {
      const hasPredictedData = Object.values(aiData).some((value) => !isEmptyValue(value));
      const hasAiUsage = (state.config?.fields || []).some((field) => {
        return getActiveSource(field.key) === "ai" && !isEmptyValue(aiData[field.key]);
      });
      return hasPredictedData && hasAiUsage ? "Stage complated/HITL" : "Stage complated";
    }

    function validateField(field, value) {
      if (isFieldRequired(field) && isEmptyValue(value)) {
        if (field.type === "boolean") {
          return "Zorunlu onay gerekir.";
        }
        return "Bu alan zorunlu.";
      }
      if (field.type === "email" && value) {
        if (!String(value).includes("@")) return "Ge√ßerli bir e-posta girin.";
      }
      if (field.type === "phone" && value) {
        if (!/\d{10,}/.test(String(value).replace(/\D/g, ""))) return "Telefon formatƒ± hatalƒ±.";
      }
      if (field.type === "url" && value) {
        if (!/^https?:\/\//.test(String(value))) return "URL http(s):// ile ba≈ülamalƒ±.";
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type) && value !== "") {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) return "Ge√ßerli bir sayƒ± girin.";
        if (field.min !== undefined && numeric < field.min) return `Minimum ${field.min}`;
        if (field.max !== undefined && numeric > field.max) return `Maksimum ${field.max}`;
        if (field.type === "percent" && (numeric < 0 || numeric > 100)) return "0-100 arasƒ± girin.";
      }
      if (["text", "textarea", "password", "email", "url"].includes(field.type) && value) {
        if (field.minLen && String(value).length < field.minLen) return `En az ${field.minLen} karakter.`;
        if (field.maxLen && String(value).length > field.maxLen) return `En fazla ${field.maxLen} karakter.`;
        if (field.pattern) {
          const regex = new RegExp(field.pattern);
          if (!regex.test(String(value))) return field.validate?.find((r) => r.name === "regex")?.message || "Format hatasƒ±.";
        }
      }
      if (["date", "datetime", "time"].includes(field.type) && value) {
        if (field.type === "date") {
          const normalized = normalizeDateInput(String(value));
          if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
            return "Tarih formatƒ± gg.aa.yyyy veya yyyy-mm-dd olmalƒ±.";
          }
          if (!isValidDateString(normalized)) {
            return "Ge√ßerli bir tarih girin.";
          }
        }
        if (field.type === "time" && !/^\d{2}:\d{2}$/.test(String(value))) return "Saat formatƒ± HH:mm olmalƒ±.";
        if (field.type === "datetime" && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(String(value))) return "Tarih ve saat gerekli.";
      }
      return "";
    }

    function setFieldValue(key, value, field, displayValue) {
      setHumanValue(key, value, field, displayValue);
    }

    function debounceFormChange() {
      if (state.autoSaveTimer) {
        clearTimeout(state.autoSaveTimer);
      }
      state.autoSaveTimer = setTimeout(() => {
        emit("onFormChange", {
          values: buildExportJson(),
          validMap: state.validMap,
          isFormValid: Object.values(state.validMap).every(Boolean)
        });
      }, 500);
    }

    function renderForm(config) {
      formEl.innerHTML = "";
      state.values = {};
      state.validMap = {};
      state.errors = {};
      state.touched = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.fieldRefs = {};
      summaryBox.style.display = "none";

      config.fields.forEach((field, index) => {
        const wrapper = document.createElement("div");
        wrapper.className = "field-wrapper";

        const row = document.createElement("div");
        row.className = "field-row";

        const labelColumn = document.createElement("div");
        labelColumn.className = "field-label";

        const labelTop = document.createElement("div");
        labelTop.className = "label-top";

        const typeMeta = getTypeMeta(field);
        const typeIcon = document.createElement("span");
        typeIcon.className = "type-icon";
        typeIcon.textContent = typeMeta.icon;
        typeIcon.title = typeMeta.label;

        const label = document.createElement("label");
        label.className = "label-text";
        label.htmlFor = `field-${field.key}`;
        label.textContent = field.label;

        labelTop.append(typeIcon, label);

        if (field.required) {
          const star = document.createElement("span");
          star.className = "required-star";
          star.textContent = "*";
          labelTop.append(star);
        }

        const labelMeta = document.createElement("div");
        labelMeta.className = "label-meta";

        const stageBadge = getStageBadge(field.stageType);
        if (stageBadge) labelMeta.append(stageBadge);

        const aiBadge = document.createElement("button");
        aiBadge.type = "button";
        aiBadge.className = "ai-badge";
        aiBadge.title = "AI √∂nerisi var. Tƒ±kla: ƒ∞nsan moduna ge√ß / AI moduna d√∂n";
        aiBadge.innerHTML = `<img src="https://upload.wikimedia.org/wikipedia/commons/0/04/ChatGPT_logo.svg" alt="ChatGPT logo" /><span>ChatGPT</span>`;
        aiBadge.addEventListener("click", () => {
          const currentSource = getActiveSource(field.key);
          const hasAi = !isEmptyValue(aiData[field.key]);
          if (!hasAi) return;
          const nextSource = currentSource === "ai" ? "human" : "ai";
          sourceByField[field.key] = nextSource;
          updateFieldDisplayValue(field.key);
          emit("onPredictedToggle", {
            key: field.key,
            mode: nextSource
          });
        });
        labelMeta.append(aiBadge);

        const applyAiBtn = document.createElement("button");
        applyAiBtn.type = "button";
        applyAiBtn.className = "pill";
        applyAiBtn.textContent = "AI'den doldur";
        applyAiBtn.style.display = "none";
        applyAiBtn.addEventListener("click", () => {
          const aiValue = aiData[field.key];
          if (isEmptyValue(aiValue)) return;
          humanData[field.key] = aiValue;
          sourceByField[field.key] = "human";
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(applyAiBtn);

        const revertAiBtn = document.createElement("button");
        revertAiBtn.type = "button";
        revertAiBtn.className = "pill";
        revertAiBtn.textContent = "AI'ye d√∂n";
        revertAiBtn.style.display = "none";
        revertAiBtn.addEventListener("click", () => {
          if (isEmptyValue(aiData[field.key])) return;
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(revertAiBtn);

        const conflictWrap = document.createElement("div");
        conflictWrap.style.position = "relative";
        const conflictChip = document.createElement("button");
        conflictChip.type = "button";
        conflictChip.className = "conflict-chip";
        conflictChip.textContent = "√áakƒ±≈üma";
        conflictChip.style.display = "none";
        const conflictPopover = document.createElement("div");
        conflictPopover.className = "conflict-popover";
        conflictPopover.innerHTML = `
          <strong>AI vs Human</strong>
          <div><small>Human</small><pre data-conflict-human></pre></div>
          <div><small>AI</small><pre data-conflict-ai></pre></div>
          <div class="conflict-actions">
            <button type="button" class="secondary" data-apply-human>Human uygula</button>
            <button type="button" class="secondary" data-apply-ai>AI uygula</button>
          </div>
        `;
        conflictChip.addEventListener("click", () => {
          conflictPopover.classList.toggle("open");
        });
        conflictPopover.querySelector("[data-apply-human]").addEventListener("click", () => {
          sourceByField[field.key] = "human";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        conflictPopover.querySelector("[data-apply-ai]").addEventListener("click", () => {
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        conflictWrap.append(conflictChip, conflictPopover);
        labelMeta.append(conflictWrap);

        labelColumn.append(labelTop);
        if (labelMeta.childElementCount) {
          labelColumn.append(labelMeta);
        }

        const control = document.createElement("div");
        control.className = "field-control";
        const stageClass = normalizeStageType(field.stageType);
        if (stageClass) {
          control.classList.add(`stage-${stageClass}`);
        }
        const aiPill = document.createElement("span");
        aiPill.className = "ai-pill";
        aiPill.textContent = "AI";
        aiPill.style.display = "none";
        control.append(aiPill);

        let inputEl = null;
        let extraControls = null;
        let inlineActions = null;
        let setValue = null;

        const initialValue = getInitialValue(field, config);
        if (humanData[field.key] === undefined) {
          humanData[field.key] = initialValue;
        }
        if (!sourceByField[field.key]) {
          sourceByField[field.key] = "human";
        }
        if (isEmptyValue(humanData[field.key]) && !isEmptyValue(aiData[field.key])) {
          sourceByField[field.key] = "ai";
        }
        const effectiveInitial = getEffectiveValue(field.key);
        state.values[field.key] = effectiveInitial;
        state.validMap[field.key] = !validateField(field, effectiveInitial);

        if (["text", "email", "phone", "url", "password", "integer", "decimal", "currency", "percent", "number", "time"].includes(field.type)) {
          inputEl = document.createElement("input");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          if (field.type === "password") inputEl.type = "password";
          if (field.type === "email") inputEl.type = "email";
          if (field.type === "url") inputEl.type = "url";
          if (field.type === "phone") inputEl.type = "tel";
          if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) inputEl.inputMode = field.type === "integer" ? "numeric" : "decimal";
          if (field.type === "time") inputEl.type = "time";

          setValue = (value) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const formatted = field.type === "integer"
                ? formatNumberDisplay(value, { maximumFractionDigits: 0 })
                : formatNumberDisplay(value, { maximumFractionDigits: 2 });
              inputEl.value = formatted || (value ?? "");
              return;
            }
            if (field.type === "time") {
              inputEl.value = value ? normalizeTimeInput(String(value)) : "";
              return;
            }
            inputEl.value = value ?? "";
          };
          setValue(effectiveInitial);

          inputEl.addEventListener("input", (event) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const raw = event.target.value;
              setFieldValue(field.key, normalizeNumberInput(raw), field, raw);
            } else {
              setFieldValue(field.key, event.target.value, field);
            }
          });

          inputEl.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            let value = event.target.value;
            if (field.type === "time") {
              value = normalizeTimeInput(value);
              event.target.value = value;
            }
            if (field.type === "email" && value) {
              value = value.toLowerCase();
              event.target.value = value;
            }
            if (field.type === "phone" && value && field.ui?.autoTrPrefix) {
              const digits = value.replace(/\D/g, "");
              if (digits.startsWith("0")) {
                value = `+90${digits.slice(1)}`;
                event.target.value = value;
              }
            }
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const normalized = normalizeNumberInput(value);
              const formatted = field.type === "integer" ? formatNumberDisplay(normalized, { maximumFractionDigits: 0 }) : formatNumberDisplay(normalized, { maximumFractionDigits: 2 });
              event.target.value = formatted || value;
              setFieldValue(field.key, normalized, field, formatted);
            } else {
              setFieldValue(field.key, value, field);
            }
            updateError(control, field);
          });

          if (field.type === "time" && field.ui?.quickActions) {
            const actions = document.createElement("div");
            actions.className = "field-actions";
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûu an";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const timeValue = getTimeFromIso(now);
              inputEl.value = timeValue;
              setFieldValue(field.key, timeValue, field);
              updateError(control, field);
            });
            actions.append(nowBtn);
            inlineActions = actions;
          }
        } else if (field.type === "textarea" || field.type === "json") {
          inputEl = document.createElement("textarea");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "";
          inputEl.value = effectiveInitial || "";
          setValue = (value) => {
            inputEl.value = value ?? "";
          };

          inputEl.addEventListener("input", (event) => {
            setFieldValue(field.key, event.target.value, field);
          });
          inputEl.addEventListener("blur", () => {
            updateError(control, field);
          });
        } else if (field.type === "boolean") {
          control.classList.add("toggle");
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.setAttribute("aria-label", field.label);
          inputEl.checked = Boolean(effectiveInitial);
          setValue = (value) => {
            inputEl.checked = Boolean(value);
          };
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = "Evet";
          control.append(inputEl, toggleLabel);
          inputEl.addEventListener("change", () => {
            setFieldValue(field.key, inputEl.checked, field);
            updateError(control, field);
          });
        } else if (field.type === "dropdown" && !field.allowMultiple) {
          const select = document.createElement("select");
          select.className = "field-input";
          select.id = `field-${field.key}`;
          select.setAttribute("aria-describedby", `error-${field.key}`);

          const buildOptions = () => {
            select.innerHTML = "";
            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "Se√ßiniz";
            select.append(emptyOption);
            const groups = {};
            (field.options || []).forEach((opt) => {
              if (opt.group) {
                if (!groups[opt.group]) groups[opt.group] = [];
                groups[opt.group].push(opt);
              } else {
                groups.__default = groups.__default || [];
                groups.__default.push(opt);
              }
            });

            Object.entries(groups).forEach(([groupName, opts]) => {
              if (groupName === "__default") {
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  select.append(option);
                });
              } else {
                const group = document.createElement("optgroup");
                group.label = groupName;
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  group.append(option);
                });
                select.append(group);
              }
            });
          };

          buildOptions();
          select.value = effectiveInitial || "";
          setValue = (value) => {
            select.value = value ?? "";
          };

          select.addEventListener("change", () => {
            setFieldValue(field.key, select.value, field);
            updateError(control, field);
          });

          control.append(select);
        } else if (field.type === "dropdown" && field.allowMultiple) {
          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "grid";

          const chips = document.createElement("div");
          chips.className = "chip-row";

          let selectedValues = Array.isArray(effectiveInitial) ? effectiveInitial : [];

          const renderOptions = () => {
            optionsWrapper.innerHTML = "";
            (field.options || []).forEach((opt) => {
              const optionRow = document.createElement("label");
              optionRow.className = "inline-row";
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.checked = selectedValues.includes(opt.value);
              checkbox.disabled = opt.disabled || false;
              const text = document.createElement("span");
              text.textContent = opt.label;
              optionRow.append(checkbox, text);
              checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                  selectedValues = [...new Set([...selectedValues, opt.value])];
                } else {
                  selectedValues = selectedValues.filter((val) => val !== opt.value);
                }
                renderChips();
                setFieldValue(field.key, selectedValues, field);
                updateError(control, field);
              });
              optionsWrapper.append(optionRow);
            });
          };

          const renderChips = () => {
            chips.innerHTML = "";
            selectedValues.forEach((val) => {
              const opt = (field.options || []).find((o) => o.value === val);
              const chip = document.createElement("span");
              chip.className = "chip";
              chip.textContent = opt ? opt.label : val;
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.textContent = "√ó";
              removeBtn.addEventListener("click", () => {
                selectedValues = selectedValues.filter((v) => v !== val);
                renderChips();
                renderOptions();
                setFieldValue(field.key, selectedValues, field);
              });
              chip.append(removeBtn);
              chips.append(chip);
            });
          };

          renderOptions();
          renderChips();
          setValue = (value) => {
            selectedValues = Array.isArray(value) ? value : [];
            renderOptions();
            renderChips();
          };
          control.append(chips, optionsWrapper);
          updateEffectiveState(field.key, field);
        } else if (field.type === "date") {
          const dateInput = document.createElement("input");
          dateInput.type = "date";
          dateInput.className = "field-input";
          dateInput.id = `field-${field.key}`;
          dateInput.setAttribute("aria-describedby", `error-${field.key}`);
          dateInput.placeholder = field.placeholder || "";

          const initialDate = effectiveInitial ? normalizeDateInput(effectiveInitial) : "";
          if (initialDate && /^\d{4}-\d{2}-\d{2}$/.test(initialDate)) {
            dateInput.value = initialDate;
          }

          setValue = (value) => {
            const normalized = value ? normalizeDateInput(String(value)) : "";
            dateInput.value = normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized) ? normalized : "";
          };

          const syncDate = (raw) => {
            const normalized = normalizeDateInput(raw);
            const yearPart = normalized ? normalized.split("-")[0] : "";
            if (yearPart && yearPart.length > 4) {
              const parts = normalized.split("-");
              parts[0] = parts[0].slice(0, 4);
              dateInput.value = parts.join("-");
              setFieldValue(field.key, "", field, raw);
              updateError(control, field);
              return;
            }
            if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized) && isValidDateString(normalized)) {
              setFieldValue(field.key, normalized, field, normalized);
            } else {
              setFieldValue(field.key, "", field, raw);
            }
            updateError(control, field);
          };

          dateInput.addEventListener("input", (event) => syncDate(event.target.value));
          dateInput.addEventListener("change", (event) => syncDate(event.target.value));
          dateInput.addEventListener("click", () => {
            if (dateInput.showPicker) {
              try {
                dateInput.showPicker();
              } catch (error) {
                console.warn("showPicker blocked", error);
              }
            }
          });

          const actions = document.createElement("div");
          actions.className = "field-actions";
          if (field.ui?.showCalendar) {
            const calendarBtn = document.createElement("button");
            calendarBtn.type = "button";
            calendarBtn.className = "ghost";
            calendarBtn.setAttribute("aria-label", "Takvim a√ß");
            calendarBtn.textContent = "üìÖ";
            calendarBtn.addEventListener("click", () => {
              if (dateInput.showPicker) {
                dateInput.showPicker();
              } else {
                dateInput.focus();
              }
            });
            actions.append(calendarBtn);
          }
          if (field.ui?.quickActions) {
            const todayBtn = document.createElement("button");
            todayBtn.type = "button";
            todayBtn.className = "ghost";
            todayBtn.textContent = "Bug√ºn";
            todayBtn.addEventListener("click", () => syncDate(getDateFromIso(getCurrentDateTime(config))));
            const tomorrowBtn = document.createElement("button");
            tomorrowBtn.type = "button";
            tomorrowBtn.className = "ghost";
            tomorrowBtn.textContent = "Yarƒ±n";
            tomorrowBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() + 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const yesterdayBtn = document.createElement("button");
            yesterdayBtn.type = "button";
            yesterdayBtn.className = "ghost";
            yesterdayBtn.textContent = "D√ºn";
            yesterdayBtn.addEventListener("click", () => {
              const base = new Date(getCurrentDateTime(config));
              base.setDate(base.getDate() - 1);
              syncDate(base.toISOString().slice(0, 10));
            });
            const clearBtn = document.createElement("button");
            clearBtn.type = "button";
            clearBtn.className = "ghost";
            clearBtn.textContent = "Temizle";
            clearBtn.addEventListener("click", () => {
              dateInput.value = "";
              setFieldValue(field.key, "", field);
              updateError(control, field);
            });
            actions.append(todayBtn, tomorrowBtn, yesterdayBtn, clearBtn);
          }
          control.append(dateInput, actions);
        } else if (field.type === "datetime") {
          const datetimeInput = document.createElement("input");
          datetimeInput.type = "datetime-local";
          datetimeInput.className = "field-input";
          datetimeInput.id = `field-${field.key}`;
          datetimeInput.setAttribute("aria-describedby", `error-${field.key}`);

          const normalizedInitial = effectiveInitial ? normalizeDateTimeInput(effectiveInitial, config) : "";
          const dateValue = normalizedInitial ? getDateFromIso(normalizedInitial) : "";
          const timeValue = normalizedInitial ? getTimeFromIso(normalizedInitial) : "";
          if (dateValue && timeValue) {
            datetimeInput.value = `${dateValue}T${timeValue}`;
          }

          setValue = (value) => {
            if (!value) {
              datetimeInput.value = "";
              return;
            }
            const normalized = normalizeDateTimeInput(String(value), config);
            const nextDate = getDateFromIso(normalized);
            const nextTime = getTimeFromIso(normalized);
            datetimeInput.value = nextDate && nextTime ? `${nextDate}T${nextTime}` : "";
          };

          const quickActions = document.createElement("div");
          quickActions.className = "field-actions";
          if (field.ui?.quickActions) {
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "≈ûimdi";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const isoDate = getDateFromIso(now);
              const isoTime = getTimeFromIso(now);
              const nextValue = `${isoDate}T${isoTime}`;
              datetimeInput.value = nextValue;
              syncDatetime(nextValue);
            });
            quickActions.append(nowBtn);
          }

          const syncDatetime = (raw) => {
            if (!raw) {
              setFieldValue(field.key, "", field, raw);
              updateError(control, field);
              return;
            }
            const [datePart] = raw.split("T");
            const yearPart = datePart ? datePart.split("-")[0] : "";
            if (yearPart && yearPart.length > 4) {
              const parts = datePart.split("-");
              parts[0] = parts[0].slice(0, 4);
              const nextValue = `${parts.join("-")}T${raw.split("T")[1] || ""}`;
              datetimeInput.value = nextValue;
              setFieldValue(field.key, "", field, raw);
              updateError(control, field);
              return;
            }
            const normalized = normalizeDateTimeInput(raw, config);
            setFieldValue(field.key, normalized, field, raw);
            updateError(control, field);
          };

          datetimeInput.addEventListener("input", (event) => syncDatetime(event.target.value));
          datetimeInput.addEventListener("change", (event) => syncDatetime(event.target.value));
          datetimeInput.addEventListener("click", () => {
            if (datetimeInput.showPicker) {
              try {
                datetimeInput.showPicker();
              } catch (error) {
                console.warn("showPicker blocked", error);
              }
            }
          });

          inputEl = datetimeInput;
          inlineActions = quickActions;
        } else if (field.type === "duration") {
          const durationInput = document.createElement("input");
          durationInput.className = "field-input";
          durationInput.setAttribute("aria-describedby", `error-${field.key}`);
          durationInput.placeholder = "hh:mm";
          durationInput.value = effectiveInitial || "";
          setValue = (value) => {
            durationInput.value = value ?? "";
          };
          durationInput.addEventListener("blur", () => {
            const normalized = normalizeTimeInput(durationInput.value);
            durationInput.value = normalized;
            const [h, m] = normalized.split(":");
            const minutes = (Number(h || 0) * 60) + Number(m || 0);
            if (field.ui?.durationFormat === "iso") {
              setFieldValue(field.key, `PT${Number(h || 0)}H${Number(m || 0)}M`, field, normalized);
            } else {
              setFieldValue(field.key, minutes, field, normalized);
            }
            updateError(control, field);
          });
          durationInput.addEventListener("input", () => {
            setFieldValue(field.key, durationInput.value, field);
          });
          inputEl = durationInput;
        } else if (field.type === "address") {
          const street = document.createElement("input");
          const district = document.createElement("input");
          const city = document.createElement("input");
          const postal = document.createElement("input");
          const country = document.createElement("input");
          [street, district, city, postal, country].forEach((input) => {
            input.className = "field-input";
          });
          street.placeholder = "Sokak / Mahalle";
          district.placeholder = "ƒ∞l√ße";
          city.placeholder = "ƒ∞l";
          postal.placeholder = "Posta Kodu";
          country.placeholder = "√úlke";
          const grid = document.createElement("div");
          grid.className = "grid two";
          grid.append(street, district, city, postal, country);
          setValue = (value) => {
            const normalized = value && typeof value === "object" ? value : {};
            street.value = normalized.street || "";
            district.value = normalized.district || "";
            city.value = normalized.city || "";
            postal.value = normalized.postalCode || "";
            country.value = normalized.country || "";
          };
          setValue(effectiveInitial);
          const updateAddress = () => {
            const value = {
              street: street.value,
              district: district.value,
              city: city.value,
              postalCode: postal.value,
              country: country.value
            };
            setFieldValue(field.key, value, field);
            updateError(control, field);
          };
          [street, district, city, postal, country].forEach((input) => {
            input.addEventListener("input", updateAddress);
            input.addEventListener("blur", updateAddress);
          });
          inputEl = grid;
        } else if (["file", "multifile", "image"].includes(field.type)) {
          const drop = document.createElement("div");
          drop.className = "file-drop";
          drop.textContent = "Dosya s√ºr√ºkleyin veya se√ßin";

          const allowMultiple = field.type === "multifile" || field.allowMultiple === true;

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "field-input";
          fileInput.id = `field-${field.key}`;
          fileInput.setAttribute("aria-describedby", `error-${field.key}`);
          const accept = field.ui?.accept || "";
          if (accept) fileInput.accept = accept;
          fileInput.multiple = allowMultiple;

          const list = document.createElement("div");
          list.className = "file-list";

          const renderFiles = () => {
            list.innerHTML = "";
            const files = state.fileBuffers[field.key] || [];
            const isImageGrid = field.type === "image" && (fileInput.multiple || files.length > 1);
            list.className = isImageGrid ? "file-grid" : "file-list";

            files.forEach((file, idx) => {
              const isImage = field.type === "image" || isImageLike(file);
              const row = document.createElement("div");
              row.className = isImageGrid ? "file-card" : "file-item";
              const meta = document.createElement("div");
              meta.className = "file-meta";
              meta.innerHTML = `<strong>${file.name}</strong><span>${Math.round(file.size / 1024)} KB</span>`;

              if (isImage) {
                const thumbWrap = document.createElement("div");
                thumbWrap.className = "file-thumb-wrap";
                const thumb = document.createElement("img");
                thumb.className = isImageGrid ? "file-thumb large" : "file-thumb";
                thumb.src = file.preview || file.url || "";
                thumb.alt = file.name || "g√∂rsel";
                const overlay = document.createElement("div");
                overlay.className = "file-thumb-overlay";
                overlay.textContent = "üîç";
                thumbWrap.append(thumb, overlay);
                thumbWrap.addEventListener("click", () => openLightbox(file.preview || file.url || ""));
                if (isImageGrid) {
                  row.append(thumbWrap);
                } else {
                  const left = document.createElement("div");
                  left.className = "inline-row";
                  left.append(thumbWrap, meta);
                  row.append(left);
                }
              } else {
                const left = document.createElement("div");
                left.className = "inline-row";
                const icon = document.createElement("div");
                icon.className = "file-icon";
                icon.textContent = "üìÑ";
                left.append(icon, meta);
                if (file.url && (isPdfDataUrl(file.url) || file.url.startsWith("http"))) {
                  const previewBtn = document.createElement("button");
                  previewBtn.type = "button";
                  previewBtn.className = "preview-btn";
                  previewBtn.textContent = "√ñnizle";
                  previewBtn.addEventListener("click", () => openFilePreview(file.url));
                  left.append(previewBtn);
                }
                row.append(left);
              }

              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "file-remove";
              removeBtn.textContent = "√ó";
              removeBtn.addEventListener("click", () => {
                state.fileBuffers[field.key] = files.filter((_, fileIdx) => fileIdx !== idx);
                renderFiles();
                if (file.url) {
                  const currentValue = getEffectiveValue(field.key);
                  const values = Array.isArray(currentValue) ? currentValue : currentValue ? [currentValue] : [];
                  const filtered = values.filter((val) => val !== file.url);
                  if (allowMultiple) {
                    humanData[field.key] = filtered;
                  } else {
                    humanData[field.key] = filtered[0] || "";
                  }
                } else {
                  humanData[field.key] = "";
                }
                const filePayload = (state.fileBuffers[field.key] || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  lastModified: f.lastModified
                }));
                state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((f) => f.raw).filter(Boolean);
                sourceByField[field.key] = "human";
                updateEffectiveState(field.key, field);
                updateAiVisuals(field.key);
                emit("onFileSelected", {
                  key: field.key,
                  files: filePayload,
                  rawFiles: (state.fileBuffers[field.key] || []).map((f) => f.raw)
                });
              });

              if (isImageGrid) {
                row.append(meta, removeBtn);
              } else {
                row.append(removeBtn);
              }

              list.append(row);
            });
          };

          const handleFiles = (fileList) => {
            const files = Array.from(fileList);
            const maxFiles = field.ui?.maxFiles || (allowMultiple ? 10 : 1);
            const maxSizeMB = field.ui?.maxSizeMB || 25;
            const errors = [];
            const accepted = [];

            files.forEach((file) => {
              if (accepted.length >= maxFiles) return;
              if (file.size > maxSizeMB * 1024 * 1024) {
                errors.push(`${file.name}: Dosya √ßok b√ºy√ºk.`);
                return;
              }
              if (accept && !file.type.match(accept.replace("*", ".*"))) {
                errors.push(`${file.name}: T√ºr desteklenmiyor.`);
                return;
              }
              const shouldPreview = field.type === "image" || file.type.startsWith("image/");
              accepted.push({
                raw: file,
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
                preview: shouldPreview ? URL.createObjectURL(file) : ""
              });
            });

            if (errors.length) {
              setFieldValue(field.key, "", field);
              state.errors[field.key] = errors.join(" ");
            }

            state.fileBuffers[field.key] = field.type === "multifile" || fileInput.multiple ? accepted : accepted.slice(0, 1);
            renderFiles();

            const filePayload = (state.fileBuffers[field.key] || []).map((file) => ({
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified
            }));
            state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((file) => file.raw).filter(Boolean);
            humanData[field.key] = "";
            sourceByField[field.key] = "human";
            updateEffectiveState(field.key, field);
            updateAiVisuals(field.key);
            console.log("Pending file selected", {
              field: field.key,
              files: filePayload
            });
            emit("onFileSelected", {
              key: field.key,
              files: filePayload,
              rawFiles: (state.fileBuffers[field.key] || []).map((file) => file.raw)
            });
          };

          drop.addEventListener("dragover", (event) => {
            event.preventDefault();
            drop.style.borderColor = varPrimary();
          });
          drop.addEventListener("dragleave", () => {
            drop.style.borderColor = "";
          });
          drop.addEventListener("drop", (event) => {
            event.preventDefault();
            handleFiles(event.dataTransfer.files);
            drop.style.borderColor = "";
          });

          fileInput.addEventListener("change", (event) => {
            handleFiles(event.target.files);
          });

          control.append(drop, fileInput, list);
          setValue = (value) => {
            const initialFiles = parseInitialFiles(value, allowMultiple, field);
            if (initialFiles.length) {
              state.fileBuffers[field.key] = initialFiles;
            } else if (!state.fileStaging[field.key]?.length) {
              state.fileBuffers[field.key] = [];
            }
            renderFiles();
          };
          setValue(effectiveInitial);
          updateEffectiveState(field.key, field);
        }

        if (inputEl) {
          control.append(inputEl);
          if (inlineActions) {
            control.append(inlineActions);
          }
        }

        if (field.helpText && config.showInlineHelp) {
          const help = document.createElement("div");
          help.className = "helper-text";
          help.textContent = field.helpText;
          labelColumn.append(help);
        }

        const errorText = document.createElement("div");
        errorText.className = "error-text";
        errorText.dataset.errorFor = field.key;

        const controlStack = document.createElement("div");
        controlStack.className = "control-stack";
        controlStack.append(control);
        if (extraControls) {
          controlStack.append(extraControls);
        }
        controlStack.append(errorText);

        state.fieldRefs[field.key] = {
          field,
          control,
          inputEl,
          setValue,
          aiBadge,
          aiPill,
          applyAiBtn,
          revertAiBtn,
          conflictChip,
          conflictPopover
        };
        updateAiVisuals(field.key);

        row.append(labelColumn, controlStack);
        wrapper.append(row);
        formEl.append(wrapper);

        if (index === 0 && config.autoFocusFirstInvalid) {
          setTimeout(() => {
            const focusTarget = wrapper.querySelector("input, textarea, select");
            if (focusTarget) focusTarget.focus();
          }, 0);
        }
      });
      updateToolbarStatus();
      updateSubmitState(config);
      captureInitialSnapshot();
    }

    function varPrimary() {
      return getComputedStyle(document.documentElement).getPropertyValue("--primary");
    }

    function openLightbox(src) {
      if (!src) return;
      lightboxImage.src = src;
      lightboxEl.classList.add("open");
      lightboxEl.setAttribute("aria-hidden", "false");
    }

    function openFilePreview(url) {
      if (!url) return;
      window.open(url, "_blank", "noopener");
    }

    function closeLightbox() {
      lightboxEl.classList.remove("open");
      lightboxEl.setAttribute("aria-hidden", "true");
      lightboxImage.src = "";
    }

    function openExportModal(kind = "export") {
      exportModal.classList.add("open");
      exportModal.setAttribute("aria-hidden", "false");
      setExportTab(kind);
    }

    function closeExportModal() {
      exportModal.classList.remove("open");
      exportModal.setAttribute("aria-hidden", "true");
      exportContent.value = "";
    }

    function setExportTab(kind) {
      exportTabs.forEach((tab) => {
        tab.classList.toggle("active", tab.dataset.exportTab === kind);
      });
      if (kind === "human") {
        exportContent.value = JSON.stringify(humanData, null, 2);
        return;
      }
      if (kind === "ai") {
        exportContent.value = JSON.stringify(aiData, null, 2);
        return;
      }
      if (kind === "column") {
        exportContent.value = JSON.stringify(columnJson || {}, null, 2);
        return;
      }
      exportContent.value = JSON.stringify(buildExportJson(), null, 2);
    }

    lightboxEl.addEventListener("click", (event) => {
      if (event.target === lightboxEl) {
        closeLightbox();
      }
    });

    lightboxEl.querySelector(".lightbox-close").addEventListener("click", closeLightbox);
    closeExportBtn.addEventListener("click", closeExportModal);
    exportModal.addEventListener("click", (event) => {
      if (event.target === exportModal) {
        closeExportModal();
      }
    });
    exportTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        setExportTab(tab.dataset.exportTab);
      });
    });

    function updateError(control, field) {
      const errorText = formEl.querySelector(`[data-error-for="${CSS.escape(field.key)}"]`);
      if (!errorText) {
        console.warn("error element missing", { fieldKey: field.key, field });
        return;
      }
      const error = state.errors[field.key] || "";
      errorText.textContent = error;
      if (error) {
        control.classList.add("invalid");
      } else {
        control.classList.remove("invalid");
      }
      updateSubmitState(state.config);
    }

    function updateSubmitState(config) {
      console.info("updateSubmitState:start", { fieldCount: (config.fields || []).length });
      const isValid = (config.fields || []).every((field) => {
        let validationValue = getMergedValidationValue(field);
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(validationValue)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        if (isFieldRequired(field)) {
          const fieldOk = !isEmptyValue(validationValue);
          if (!fieldOk) {
            console.info("updateSubmitState:missing", { fieldKey: field.key, label: field.label });
          }
          return fieldOk;
        }
        return true;
      });
      if (config.requiredPolicy === "strict") {
        submitBtn.disabled = !isValid;
        submitBtn.title = isValid ? "" : "Zorunlu alanlarƒ± doldurun";
      } else {
        submitBtn.disabled = false;
        submitBtn.title = "";
      }
      console.info("updateSubmitState:done", { isValid, requiredPolicy: config.requiredPolicy });
    }

    function focusFirstInvalid() {
      const firstInvalid = Object.keys(state.validMap).find((key) => !state.validMap[key]);
      if (!firstInvalid) return null;
      const target = document.querySelector(`#field-${CSS.escape(firstInvalid)}`) || document.querySelector(`[data-field='${firstInvalid}']`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "center" });
        if (target.focus) target.focus();
      }
      return firstInvalid;
    }

    function validateAll() {
      state.config.fields.forEach((field) => {
        let value = getEffectiveValue(field.key);
        if (field.type === "date" && typeof value === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(value)) {
          value = normalizeDateInput(value);
        }
        if (field.type === "time" && typeof value === "string") {
          value = normalizeTimeInput(value);
        }
        state.values[field.key] = value;
        let validationValue = value;
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(value)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        state.errors[field.key] = validateField(field, validationValue);
        state.validMap[field.key] = !state.errors[field.key];
        const control = document.querySelector(`#error-${field.key}`)?.parentElement?.querySelector(".field-control");
        if (control) updateError(control, field);
      });
    }

    function applyAiValuesToHuman({ overwrite }) {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        if (isEmptyValue(aiValue)) return;
        if (!overwrite && !isEmptyValue(humanData[field.key])) return;
        humanData[field.key] = aiValue;
        sourceByField[field.key] = "human";
      });
      refreshAllFields();
    }

    function resetAllStores() {
      humanData = {};
      aiData = {};
      sourceByField = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.values = {};
      state.validMap = {};
      state.errors = {};
      taskStartTimestamp = null;
      if (columnJson) {
        applyColumnJson(columnJson);
      } else {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
      }
    }

    BDF.submit = () => {
      if (!formEl) return;
      formEl.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
    };

    BDF.reset = () => {
      resetAllStores();
    };

    window.BDF_submit = () => {
      if (!formEl) return;
      validateAll();
      const payload = buildSubmitOutputsPayload();
      if (typeof window.bubble_fn_submit === "function") {
        window.bubble_fn_submit(payload);
      } else {
        console.warn("bubble_fn_submit not available");
      }
    };

    if (!BDF.__listenersBound) {
      BDF.__listenersBound = true;

      formEl.addEventListener("submit", (event) => {
      event.preventDefault();
      ensureTaskStartTimestamp();
      validateAll();
      const firstInvalidKey = focusFirstInvalid();
      const invalidCount = Object.values(state.validMap).filter((val) => !val).length;
      if (invalidCount > 0) {
        summaryBox.style.display = "block";
        summaryBox.textContent = `${invalidCount} alan eksik veya hatalƒ±.`;
      } else {
        summaryBox.style.display = "none";
      }
      const exportPayload = buildExportJson();
      const submitOutputsPayload = buildSubmitOutputsPayload();
      console.info("submitOutputs payload", submitOutputsPayload);
      console.info("submitOutputs:panel", { exists: Boolean(submitOutputsEl) });
      setConsole("debug:submit-outputs", JSON.stringify(submitOutputsPayload, null, 2));
      renderSubmitOutputs(submitOutputsPayload);
      emit("onSubmitAttempt", {
        values: exportPayload,
        isFormValid: invalidCount === 0,
        firstInvalidKey,
        output1: submitOutputsPayload.output1,
        output2: submitOutputsPayload.output2,
        output3: submitOutputsPayload.output3,
        outputlist1: submitOutputsPayload.outputlist1,
        outputlist2: submitOutputsPayload.outputlist2,
        outputlist3: submitOutputsPayload.outputlist3,
        outputlist4: submitOutputsPayload.outputlist4
      });
      if (typeof window.bubble_fn_submit === "function") {
        window.bubble_fn_submit(submitOutputsPayload);
      }
      });

      if (submitBtn) {
        submitBtn.addEventListener("click", () => {
          console.info("submit button clicked");
          const submitOutputsPayload = buildSubmitOutputsPayload();
          renderSubmitOutputs(submitOutputsPayload);
        });
      }

      formEl.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        if (event.target && event.target.blur) event.target.blur();
        return;
      }
      if (event.key !== "Enter") return;
      if (event.target?.tagName === "TEXTAREA") return;
      if (event.target?.type === "button") return;
      event.preventDefault();
      const focusables = Array.from(formEl.querySelectorAll("input, select, textarea")).filter((el) => !el.disabled && el.type !== "hidden");
      const currentIndex = focusables.indexOf(event.target);
      const next = focusables[currentIndex + 1];
      if (next) {
        next.focus();
      } else {
        submitBtn.click();
      }
      });

      clearBtn.addEventListener("click", () => {
        emit("onClear", {});
        resetAllStores();
      });

      [columnJsonInput, humanJsonInput, predictedJsonInput].forEach((input) => {
        if (!input) return;
        input.addEventListener("input", () => {
          syncManualJsonInputs();
        });
      });

      loadHumanJsonBtn.addEventListener("click", () => {
        syncManualJsonInputs();
        initialSnapshot = null;
        if (state.config) {
          initialSnapshot = buildBaselineSnapshot(MANUAL_DATA_JSON);
        }
        const payload = MANUAL_DATA_JSON || SAMPLE_DATA_JSON;
        if (!payload) {
          humanData = {};
          refreshAllFields();
          return;
        }
        emit("debug:human-json", payload);
        loadJsonSafeToForm("human", payload);
        openExportModal("human");
      });

      loadPredictedJsonBtn.addEventListener("click", () => {
      syncManualJsonInputs();
      const payload = MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON;
      if (!payload) {
        aiData = {};
        initializeSourceByFieldFromAi();
        refreshAllFields();
        return;
      }
      emit("debug:predicted-json", payload);
      loadJsonSafeToForm("ai", payload);
      initializeSourceByFieldFromAi();
      refreshAllFields();
      openExportModal("ai");
      });

      loadColumnJsonBtn.addEventListener("click", () => {
      syncManualJsonInputs();
      columnJson = MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON;
      applyColumnJson(columnJson);
      emit("debug:column-json", columnJson);
      openExportModal("column");
      });

      applyAiToEmptyBtn.addEventListener("click", () => {
        applyAiValuesToHuman({ overwrite: false });
      });

      overwriteAiToAllBtn.addEventListener("click", () => {
        const confirmed = window.confirm("AI t√ºm alanlarƒ± overwrite edecek. Devam edilsin mi?");
        if (!confirmed) return;
        applyAiValuesToHuman({ overwrite: true });
      });

      resetStoresBtn.addEventListener("click", () => {
        resetAllStores();
      });

      exportJsonBtn.addEventListener("click", () => {
        openExportModal("export");
      });

      if (scenarioColumnOnlyBtn) {
        scenarioColumnOnlyBtn.addEventListener("click", () => {
          applyScenario({
            name: "column-only",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON
          });
        });
      }

      if (scenarioColumnHumanBtn) {
        scenarioColumnHumanBtn.addEventListener("click", () => {
          applyScenario({
            name: "column-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON
          });
        });
      }

      if (scenarioColumnAiBtn) {
        scenarioColumnAiBtn.addEventListener("click", () => {
          applyScenario({
            name: "column-ai",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioColumnAiHumanBtn) {
        scenarioColumnAiHumanBtn.addEventListener("click", () => {
          applyScenario({
            name: "column-ai-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioConflictBtn) {
        scenarioConflictBtn.addEventListener("click", () => {
          applyScenario({
            name: "conflict",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: {
              "Kusur Oranƒ±": "40",
              "Hasar Onarƒ±m Tutarƒ±": "120000"
            },
            ai: {
              "Kusur Oranƒ±": "80",
              "Hasar Onarƒ±m Tutarƒ±": "145000"
            }
          });
        });
      }

      document.getElementById("loadSample").addEventListener("click", () => {
        schemaInput.value = JSON.stringify(defaultSchema, null, 2);
        currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
        localeInput.value = defaultSchema.locale;
        timezoneInput.value = defaultSchema.timezone;
        modeInput.value = defaultSchema.mode;
        requiredPolicyInput.value = defaultSchema.requiredPolicy;
        showInlineHelpInput.checked = defaultSchema.showInlineHelp;
        autoFocusInvalidInput.checked = defaultSchema.autoFocusFirstInvalid;
      });

      document.getElementById("renderForm").addEventListener("click", () => {
        const parsed = safeJsonParse(schemaInput.value);
        if (!parsed || !parsed.fields) {
          setConsole("Schema parse edilemedi", "");
          return;
        }
        state.config = {
          ...parsed,
          currentDateTimeISO: currentDateTimeInput.value || parsed.currentDateTimeISO,
          locale: localeInput.value || parsed.locale || "tr-TR",
          timezone: timezoneInput.value || parsed.timezone || "Europe/Istanbul",
          mode: modeInput.value || parsed.mode || "create",
          requiredPolicy: requiredPolicyInput.value || parsed.requiredPolicy || "strict",
          showInlineHelp: showInlineHelpInput.checked,
          autoFocusFirstInvalid: autoFocusInvalidInput.checked
        };
        columnJson = {
          columns: (state.config.fields || []).map((field) => ({
            fieldName: field.label || field.key,
            label: field.label,
            type: field.type,
            required: field.required || normalizeStageType(field.stageType) === "mandatory",
            stageType: field.stageType || "optional",
            options: field.options || [],
            default: field.default,
            allowMultiple: field.allowMultiple || field.ui?.allowMultiple || false,
            ui: field.ui || {}
          })),
          currentDateTimeISO: state.config.currentDateTimeISO,
          locale: state.config.locale,
          timezone: state.config.timezone,
          mode: state.config.mode
        };
        columnWarning.style.display = "none";
        formContainer.style.display = "block";
        renderForm(state.config);
      });

      document.getElementById("clearConsole").addEventListener("click", () => {
        consoleEl.textContent = "";
      });
    }

    currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
    schemaInput.value = JSON.stringify(defaultSchema, null, 2);
    syncManualJsonInputs();
    if (MANUAL_COLUMN_JSON) {
      columnJson = MANUAL_COLUMN_JSON;
    }
    applyVersionVisibility();
    if (columnJson) {
      applyColumnJson(columnJson);
      setTimeout(() => {
        if (MANUAL_DATA_JSON) {
          loadJsonSafeToForm("human", MANUAL_DATA_JSON);
        }
        if (MANUAL_PREDICTED_JSON) {
          loadJsonSafeToForm("ai", MANUAL_PREDICTED_JSON);
          initializeSourceByFieldFromAi();
          refreshAllFields();
        }
      }, 0);
    } else {
      formEl.innerHTML = "";
      formContainer.style.display = "none";
    }
    })();
  </script>
</body>
</html>
