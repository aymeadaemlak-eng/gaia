<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Dynamic Form Element Demo</title>
  <!--
  ❗️BU BLOK ARTIK DEĞİŞTİRİLMEYECEK. ALTINDAN GÜNCELLEME YAPILACAK.
  Veriyi tam buraya gireceksin (örnek değerlerle gösterim):
  -->
  <script>
    window.BUBBLE_INPUTS = {
      COLUMN_JSON: {
        columns: [
          { fieldName: "Ad Soyad", type: "text", required: true }
        ],
        currentDateTimeISO: "2026-02-09T12:34:56+03:00",
        locale: "tr-TR",
        timezone: "Europe/Istanbul",
        mode: "create"
      },
      BUBBLE_DATA_JSON: {
        "Ad Soyad": "Ayşe Yılmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      PREDICTED_JSON: {
        "Ad Soyad": "Ayşe Yılmaz",
        "Telefon": "0532 123 45 67",
        "E-posta": "ayse@example.com"
      },
      actionoptions: {
        options: [
          { id: "1770577890579x349136294770973500", name: "DK Hesaba Taşı" },
          { id: "1770577890579x349136294770973501", name: "İhtar Dilekçesi Hazırla" }
        ]
      },
      start: false,
      editing: true,
      EDITING_STAGE_GROUPS_JSON: [],
      EDITING_ALL_FIELDS_JSON: [],
      VERSION: true
    };
  </script>
  <script>
    (function (){
      const hostId = "form";
      const iframeId = "bdf-iframe";
      const defaultHeight = 650;

      function getFrame(){
        const host = document.getElementById(hostId);
        if (!host) return null;
        const frame = host.querySelector("iframe");
        if (!frame) return null;
        return { host, frame };
      }

      function applyFrameBaseStyles(host, frame){
        frame.id = iframeId;
        frame.style.width = "100%";
        frame.style.display = "block";
        frame.style.border = "0";
        frame.style.overflow = "hidden";
        host.style.width = "100%";
      }

      function applyHeight(nextHeight){
        const obj = getFrame();
        if (!obj) return;
        const height = Math.max(80, Number(nextHeight) || 0);
        applyFrameBaseStyles(obj.host, obj.frame);
        obj.frame.style.height = height + "px";
        obj.frame.style.minHeight = height + "px";
        obj.host.style.height = height + "px";
        obj.host.style.minHeight = height + "px";
      }

      function readIncomingHeight(payload){
        if (!payload) return null;
        if (payload.type === "BDF_HEIGHT") {
          return Number(payload.height);
        }
        if (payload.bdf === "resize") {
          return Number(payload.height);
        }
        return null;
      }

      window.addEventListener("message", function(e){
        const incomingHeight = readIncomingHeight(e.data);
        if (!Number.isFinite(incomingHeight) || incomingHeight < 80) return;
        applyHeight(incomingHeight);
      });

      let tries = 0;
      const tryInit = setInterval(() => {
        tries += 1;
        const obj = getFrame();
        if (obj) {
          applyHeight(defaultHeight);
          clearInterval(tryInit);
        }
        if (tries > 40) {
          clearInterval(tryInit);
        }
      }, 250);
    })();
  </script>
  <style data-bdf-style>
    #bdf-root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #2563eb;
      --border: #e6eaf0;
      --danger: #e05a5a;
      --success: #16a34a;
      --warning: #f59e0b;
      --focus: rgba(37, 99, 235, 0.12);
      --form-row-gap: 12px;
      --form-field-gap: clamp(6px, 0.8vw, 8px);
      --form-vertical-padding: 0px;
      --form-control-pad-y: clamp(5px, 0.7vw, 7px);
      --form-control-pad-x: clamp(7px, 0.9vw, 10px);
      --form-input-pad-y: clamp(6px, 0.8vw, 8px);
      --form-input-pad-x: clamp(4px, 0.6vw, 6px);
      --form-input-min-height: 32px;
      --field-gap-internal: 3px;
      --field-gap-between: 4px;
      --field-group-gap: clamp(12px, 1.6vw, 16px);
      --amount-input-max-width: 268px;
      --field-control-height: 32px;
      font-size: 14px;
      color: var(--text);
    }

    #bdf-root,
    #bdf-root * {
      box-sizing: border-box;
    }


    #bdf-root button,
    #bdf-root input,
    #bdf-root select,
    #bdf-root textarea {
      font: inherit;
      color: inherit;
    }
    #bdf-root .page {
      margin: 0;
      padding: 0;
      display: grid;
      gap: 20px;
    }

    #bdf-root .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    #bdf-root h1,
    #bdf-root h2,
    #bdf-root h3 {
      margin: 0 0 12px;
    }

    #bdf-root .grid {
      display: grid;
      gap: 16px;
    }

    #bdf-root .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    #bdf-root .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    #bdf-root label {
      font-size: 0.88rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #667085;
    }

    #bdf-root .required-hint {
      display: none !important;
    }

    #bdf-root .required-mark {
      font-size: 1.1rem;
      line-height: 1;
      color: #dc2626;
      font-weight: 800;
      margin-left: 2px;
      transform: translateY(1px);
    }

    #bdf-root .field-wrapper {
      display: grid;
      gap: var(--field-gap-internal);
      padding: var(--form-vertical-padding) 0;
      margin-bottom: 4px;
    }

    #bdf-root .field-wrapper + .field-wrapper {
      margin-top: 0;
    }

    #bdf-root .field-wrapper.group-break-date {
      margin-top: 16px;
    }

    #bdf-root .field-row {
      display: flex;
      align-items: center;
      gap: 12px;
      height: 40px;
      min-height: 40px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(15, 23, 42, 0.06);
    }

    #bdf-root .field-row.is-file-field {
      flex-direction: column;
      gap: 6px;
      align-items: stretch;
      height: auto;
      min-height: 0;
      padding: 6px 0;
    }

    #bdf-root .field-row.is-file-field .field-label {
      padding: 6px 8px;
      border: 1px solid #edf1f6;
      border-radius: 8px;
      background: #fff;
      flex: 1 1 auto;
      max-width: none;
    }

    #bdf-root .field-row.is-file-field .control-stack {
      justify-items: stretch;
    }

#bdf-root.editing-mode #formContainer {
      width: 100%;
      max-width: unset;
      height: auto;
      max-height: none;
      overflow: visible;
      padding-right: 0;
    }

#bdf-root #formContainer {
      height: 680px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 4px;
    }

#bdf-root .field-control.file-field-control {
      min-height: 110px;
      display: grid;
      align-content: start;
      gap: 8px;
      cursor: pointer;
    }

#bdf-root .field-control.file-field-control .file-drop {
      min-height: 64px;
      display: grid;
      place-items: center;
      width: 100%;
    }

#bdf-root .field-control.file-field-control .field-input[type="file"] {
      display: none;
    }

    #bdf-root .field-label {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0;
      min-height: var(--field-control-height);
      margin: 0;
      padding: 0;
      flex: 0 0 clamp(170px, 28vw, 220px);
      max-width: clamp(170px, 28vw, 220px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 18px;
    }

    #bdf-root .label-top {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 8px;
      min-height: var(--field-control-height);
      margin: 0;
      padding: 0;
    }

    #bdf-root .label-text {
      font-weight: 500;
      font-size: 14px;
      color: #6b7280;
      line-height: 18px;
      margin: 0;
      padding: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #bdf-root .label-meta {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 3px;
      min-height: 0;
    }

    #bdf-root .type-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      line-height: 1;
      border-radius: 0;
      background: transparent;
      border: none;
      color: #8a8a84;
      flex-shrink: 0;
      margin: 0;
      padding: 0;
    }

    #bdf-root .type-icon svg {
      width: 14px;
      height: 14px;
      display: block;
    }

#bdf-root .ai-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(37, 99, 235, 0.25);
      background: rgba(37, 99, 235, 0.08);
      border-radius: 999px;
      padding: 1px 8px;
      font-size: 0.68rem;
      cursor: pointer;
      color: var(--primary);
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

#bdf-root .ai-badge img {
      width: 13px;
      height: 13px;
      display: inline-block;
      object-fit: contain;
    }

#bdf-root .ai-badge.is-active {
      border-color: rgba(34, 197, 94, 0.4);
      background: rgba(34, 197, 94, 0.12);
      color: #15803d;
    }

#bdf-root .ai-badge.is-passive {
      opacity: 0.7;
      filter: grayscale(0.2);
    }

#bdf-root .ai-badge::after {
      content: none;
    }

#bdf-root .control-stack {
      display: grid;
      gap: 0;
      width: 100%;
      justify-items: start;
      align-items: center;
      min-height: var(--field-control-height);
      flex: 1 1 auto;
      min-width: 0;
    }

#bdf-root .field-row.is-amount-field .control-stack {
      max-width: min(100%, var(--amount-input-max-width));
    }

#bdf-root .field-control {
      border: 1px solid transparent;
      border-radius: 6px;
      padding: 0;
      background: transparent;
      position: relative;
      min-height: var(--field-control-height);
      display: flex;
      align-items: center;
      transition: border-color 0.14s ease, background-color 0.14s ease;
      box-shadow: none;
      box-sizing: border-box;
    }

#bdf-root .field-control::before {
      content: none;
    }

#bdf-root .field-control.ai-active {
      background: rgba(37, 99, 235, 0.03);
    }

#bdf-root .field-control.ai-active .field-input {
      background: transparent;
      padding-right: 50px;
    }

#bdf-root .ai-pill {
      position: absolute;
      top: 5px;
      right: 30px;
      font-size: 0.62rem;
      font-weight: 700;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.14);
      color: var(--primary);
      pointer-events: none;
    }

#bdf-root .field-control:hover {
      border-color: #e7e9ee;
      background: #fcfcfd;
    }

#bdf-root .field-control:focus-within {
      border-color: #cfd6e3;
      background: #ffffff;
      box-shadow: none;
    }

#bdf-root .field-control.invalid {
      border-color: rgba(224, 90, 90, 0.55);
      box-shadow: none;
    }

#bdf-root .field-input,
#bdf-root select,
#bdf-root textarea {
      width: 100%;
      border: none;
      height: var(--field-control-height);
      min-height: var(--field-control-height);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      background: transparent;
      color: #111827;
      outline: none;
      line-height: 20px;
      margin: 0;
      box-sizing: border-box;
    }

#bdf-root .field-input::placeholder,
#bdf-root textarea::placeholder {
      color: #9ca3af;
      opacity: 0.9;
    }

#bdf-root .field-input.is-date-input::placeholder {
      color: #b4bbc8;
    }

#bdf-root .field-control.has-icon .field-input {
      padding-right: 34px;
    }

#bdf-root .field-control.has-icon .field-input.is-date-input {
      padding-right: 36px;
    }

#bdf-root textarea.field-input {
      resize: vertical;
      min-height: 72px;
    }

#bdf-root .field-icon-button {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      border: 1px solid #e5e7eb;
      background: #f8fafc;
      width: 30px;
      height: 30px;
      border-radius: 8px;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #475569;
    }

#bdf-root .field-icon-button:hover {
      border-color: #d1d5db;
      background: #f3f4f6;
    }

#bdf-root .picker-popover {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      width: 270px;
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
      padding: 12px;
      display: none;
      z-index: 30;
    }

#bdf-root .picker-popover.open {
      display: grid;
      gap: 10px;
    }

#bdf-root .picker-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      color: #334155;
    }

#bdf-root .picker-nav {
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      border-radius: 8px;
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: 600;
      color: #475569;
    }

#bdf-root .picker-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      text-align: center;
      font-size: 0.72rem;
    }

#bdf-root .picker-weekday {
      color: #94a3b8;
      font-weight: 600;
      padding: 4px 0;
    }

#bdf-root .picker-day {
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 6px 0;
      cursor: pointer;
      color: #334155;
      background: transparent;
    }

#bdf-root .picker-day.is-today {
      border-color: rgba(37, 99, 235, 0.4);
      color: #1d4ed8;
    }

#bdf-root .picker-day.is-selected {
      background: rgba(37, 99, 235, 0.12);
      border-color: rgba(37, 99, 235, 0.3);
      color: #1d4ed8;
      font-weight: 700;
    }

#bdf-root .picker-time {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

#bdf-root .picker-actions {
      display: flex;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
    }

#bdf-root .picker-actions button {
      padding: 6px 10px;
      font-size: 0.72rem;
    }

#bdf-root .field-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

#bdf-root .helper-text {
      font-size: 0.75rem;
      color: var(--muted);
    }

#bdf-root .error-text {
      font-size: 0.75rem;
      color: var(--danger);
      min-height: 0;
    }

#bdf-root .inline-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

#bdf-root button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
    }

#bdf-root button.secondary {
      background: #e5e7eb;
      color: var(--text);
    }

#bdf-root button.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

#bdf-root button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

#bdf-root .console {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.82rem;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
    }

#bdf-root .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
    }

#bdf-root .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

#bdf-root .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      font-size: 0.7rem;
      font-weight: 600;
    }

#bdf-root .chip button {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(37, 99, 235, 0.2);
    }

#bdf-root .file-drop {
      border: 1px dashed #cfd8e3;
      border-radius: 12px;
      padding: 14px;
      text-align: center;
      color: #566173;
      background: linear-gradient(180deg, #fbfdff 0%, #f7fafe 100%);
    }

#bdf-root .file-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

#bdf-root .file-grid {
      display: grid;
      gap: 8px;
      margin-top: 10px;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    }

#bdf-root .file-item {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
    }

#bdf-root .file-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
      background: #fff;
      position: relative;
      overflow: hidden;
    }

#bdf-root .file-meta {
      display: grid;
      gap: 4px;
      font-size: 0.82rem;
    }

#bdf-root .file-thumb {
      width: 52px;
      height: 52px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid var(--border);
      background: #f3f4f6;
    }

#bdf-root .file-thumb.large {
      width: 100%;
      height: 90px;
    }

#bdf-root .file-thumb-wrap {
      position: relative;
      display: inline-block;
    }

#bdf-root .file-thumb-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.2s ease;
      border-radius: 8px;
    }

#bdf-root .file-thumb-wrap:hover .file-thumb-overlay {
      opacity: 1;
    }

#bdf-root .preview-btn {
      border: none;
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.7rem;
      cursor: pointer;
    }

#bdf-root .conflict-chip {
      background: rgba(239, 68, 68, 0.12);
      color: var(--danger);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
    }

#bdf-root .conflict-popover {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 6px;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-width: 220px;
      max-width: 320px;
      width: max-content;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.16);
      display: none;
      z-index: 20;
    }

#bdf-root .conflict-popover.open {
      display: grid;
      gap: 6px;
    }

#bdf-root .conflict-popover pre {
      margin: 0;
      padding: 6px 8px;
      background: #f8fafc;
      border-radius: 8px;
      font-size: 0.72rem;
      max-height: 120px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

#bdf-root .conflict-popover small {
      color: var(--muted);
      font-weight: 600;
    }

#bdf-root .conflict-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

#bdf-root .conflict-actions button {
      padding: 6px 10px;
      font-size: 0.72rem;
    }

#bdf-root .date-wrapper {
      position: relative;
      display: grid;
      gap: 6px;
    }

#bdf-root .date-overlay-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

#bdf-root .file-icon {
      font-size: 22px;
      width: 44px;
      text-align: center;
    }

#bdf-root .file-remove {
      border: none;
      background: transparent;
      color: var(--danger);
      font-weight: 700;
      cursor: pointer;
    }

#bdf-root .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

#bdf-root .toggle input {
      width: 40px;
      height: 22px;
    }


#bdf-root .action-bar {
      position: sticky;
      top: 0;
      z-index: 25;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      min-height: 58px;
      padding: 10px 12px;
      border: 1px solid #e4e8ee;
      border-radius: 12px;
      background: #f8fafc;
      box-shadow: 0 4px 14px rgba(15, 23, 42, 0.06);
      margin-bottom: 12px;
    }

#bdf-root .action-meta {
      display: grid;
      gap: 2px;
      min-width: 88px;
    }

#bdf-root .action-meta-title {
      font-size: 0.76rem;
      font-weight: 600;
      color: #64748b;
      letter-spacing: 0.01em;
    }

#bdf-root .action-meta-subtitle {
      font-size: 0.72rem;
      color: #94a3b8;
    }

#bdf-root .action-main {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }

#bdf-root .action-split {
      position: relative;
      display: inline-flex;
      align-items: stretch;
      border-radius: 10px;
      overflow: visible;
      border: 1px solid #cbd5e1;
      background: #fff;
      box-shadow: 0 1px 1px rgba(15,23,42,0.04);
    }

#bdf-root .action-split button {
      border-radius: 0;
      border: none;
    }

#bdf-root .action-trigger-btn {
      background: #ffffff;
      color: #0f172a;
      min-width: 190px;
      text-align: left;
      font-weight: 600;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
    }

#bdf-root .action-chevron-btn {
      background: #eff6ff;
      color: #1e3a8a;
      min-width: 40px;
      padding: 8px 10px;
      border-left: 1px solid #cbd5e1;
    }

#bdf-root .action-split button:hover {
      background: #f1f5f9;
    }

#bdf-root .action-split button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(59,130,246,0.2);
      position: relative;
      z-index: 1;
    }

#bdf-root .action-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      min-width: 220px;
      max-height: 240px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.14);
      display: none;
      padding: 4px;
      z-index: 20;
    }

#bdf-root .action-menu.open {
      display: grid;
      gap: 2px;
    }

#bdf-root .action-menu-item {
      width: 100%;
      text-align: left;
      background: transparent;
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 0.82rem;
    }

#bdf-root .action-menu-item:hover {
      background: #f1f5f9;
    }

#bdf-root .predicted-action-btn {
      background: rgba(37, 99, 235, 0.08);
      color: #1d4ed8;
      border: 1px dashed rgba(37, 99, 235, 0.25);
      font-size: 0.78rem;
      padding: 7px 10px;
    }

#bdf-root .predicted-action-btn:disabled {
      opacity: 0.55;
    }

#bdf-root .action-empty-msg {
      color: var(--warning);
      font-size: 0.78rem;
      font-weight: 600;
}

#bdf-root .edit-mode-root {
  display: none;
  gap: 12px;
  width: 100%;
  max-width: unset;
  flex: 1 1 auto;
}

#bdf-root .edit-mode-toolbar {
  display: grid;
  gap: 8px;
}

#bdf-root .edit-search-empty {
  display: none;
  padding: 8px 10px;
  border: 1px dashed #f1b5b5;
  background: #fff7f7;
  color: #b42318;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
}

#bdf-root .edit-progress-wrap {
  display: grid;
  gap: 8px;
  align-items: center;
}

#bdf-root .edit-progress-track {
  display: flex;
  align-items: center;
  gap: 8px;
  overflow-x: auto;
  padding: 4px 2px;
}

#bdf-root .edit-progress-step {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  color: #64748b;
  white-space: nowrap;
}

#bdf-root .edit-progress-step-dot {
  width: 18px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid #cbd5e1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  background: #fff;
}

#bdf-root .edit-progress-step.completed .edit-progress-step-dot {
  background: #1d4ed8;
  border-color: #1d4ed8;
  color: #fff;
}

#bdf-root .edit-progress-step.active {
  color: #1d4ed8;
  font-weight: 600;
}

#bdf-root .edit-progress-step.active .edit-progress-step-dot {
  border-color: #1d4ed8;
  box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.16);
}

#bdf-root .edit-progress-step.upcoming {
  opacity: 0.6;
}

#bdf-root .edit-progress-sep {
  color: #cbd5e1;
}

#bdf-root .edit-progress-toggle {
  justify-self: start;
  font-size: 12px;
  padding: 4px 8px;
}

#bdf-root .edit-quick-list {

  display: grid;
  gap: 8px;
}

#bdf-root .edit-quick-item {
  min-height: 38px;
  border: 1px solid #dbe3f2;
  background: #f8fbff;
  border-radius: 11px;
  padding: 10px 12px;
  display: flex;
  align-items: center;
  gap: 10px;
}

#bdf-root .edit-quick-item:hover {
  border-color: #93c5fd;
}

#bdf-root .edit-quick-item-label {
  color: #334155;
  font-size: 13px;
  font-weight: 600;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#bdf-root .edit-quick-item-value {
  margin-left: auto;
  color: #64748b;
  font-size: 12px;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#bdf-root .edit-quick-empty {
  color: #64748b;
  font-size: 13px;
  padding: 6px 2px;
}

#bdf-root .edit-stage-layout {
  display: grid;
  grid-template-columns: minmax(180px, 240px) minmax(0, 1fr);
  gap: 10px;
  align-items: start;
}

#bdf-root .edit-stage-tabs {
  display: grid;
  gap: 6px;
}

#bdf-root .edit-stage-tab {
  text-align: left;
  border: 1px solid #d7deeb;
  background: #fff;
  border-radius: 10px;
  padding: 9px 10px;
  color: #334155;
  font-size: 14px;
  line-height: 1.35;
  font-weight: 600;
  min-height: 40px;
}

#bdf-root .edit-stage-tab.active {
  background: rgba(37, 99, 235, 0.1);
  border-color: rgba(37, 99, 235, 0.35);
  color: #1d4ed8;
  font-weight: 600;
}

#bdf-root .edit-stage-tab.completed {
  border-color: #93c5fd;
  color: #1e40af;
}

#bdf-root .edit-stage-tab.upcoming {
  opacity: 0.9;
  color: #475569;
}

#bdf-root .edit-stage-panel {
  border: 1px solid #e6ebf5;
  border-radius: 12px;
  padding: 10px;
  min-height: 320px;
  background: #fff;
}

#bdf-root .edit-stage-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#bdf-root .edit-stage-chip {
  font-size: 11px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid #dbe3f2;
  color: #64748b;
  background: #f8fafc;
}

#bdf-root .edit-stage-chip.completed {
  color: #1e40af;
  border-color: #93c5fd;
  background: #eff6ff;
}

#bdf-root .edit-stage-chip.active {
  color: #1d4ed8;
  border-color: rgba(37, 99, 235, 0.35);
  background: rgba(37, 99, 235, 0.08);
}

#bdf-root .edit-stage-chip.upcoming {
  opacity: 0.7;
}

#bdf-root .edit-stage-status {
  font-size: 12px;
  color: #64748b;
  margin-bottom: 6px;
  min-height: 18px;
}
#bdf-root .edit-stage-fields-skeleton {
  display: grid;
  gap: 8px;
  margin-top: 4px;
}

#bdf-root .edit-stage-fields-skeleton .line {
  height: 34px;
  border-radius: 9px;
  background: linear-gradient(90deg, #eef3fb 0%, #e5edf9 50%, #eef3fb 100%);
  background-size: 220% 100%;
  animation: bdf-loading 1.2s ease-in-out infinite;
}

#bdf-root .edit-mode-loading {
  display: none;
  width: 100%;
  min-height: 220px;
  border: 1px solid #e2e8f3;
  border-radius: 12px;
  background: #fafcff;
  padding: 14px;
  gap: 12px;
  align-content: start;
}

#bdf-root .edit-mode-spinner {
  width: 18px;
  height: 18px;
  border: 2px solid #d9e2f0;
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: bdf-spin 0.8s linear infinite;
}

#bdf-root .edit-skeleton-row {
  height: 14px;
  border-radius: 999px;
  background: linear-gradient(90deg, #eef3fb 0%, #e5edf9 50%, #eef3fb 100%);
  background-size: 220% 100%;
  animation: bdf-loading 1.2s ease-in-out infinite;
}

#bdf-root .edit-skeleton-row.head { width: 40%; height: 18px; }
#bdf-root .edit-skeleton-row.wide { width: 100%; }
#bdf-root .edit-skeleton-row.mid { width: 72%; }

@keyframes bdf-loading {
  0% { background-position: 200% 0; }
  100% { background-position: -20% 0; }
}

@keyframes bdf-spin {
  to { transform: rotate(360deg); }
}
#bdf-root .summary-box {
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
    }

#bdf-root .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 999;
    }

#bdf-root .lightbox.open {
      display: flex;
    }

#bdf-root .lightbox-content {
      max-width: min(720px, 90vw);
      max-height: 80vh;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

#bdf-root .lightbox-content img {
      width: 100%;
      height: auto;
      border-radius: 12px;
    }

#bdf-root .lightbox-close {
      justify-self: end;
      background: #111827;
      color: #fff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
    }

#bdf-root .debug-toolbar {
      position: sticky;
      top: 12px;
      z-index: 10;
      display: grid;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
    }

#bdf-root .toolbar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

#bdf-root .toolbar-actions button {
      padding: 8px 12px;
      font-size: 0.78rem;
    }

#bdf-root .toolbar-status {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 600;
    }

#bdf-root .debug-warning {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #f8fafc;
      margin-bottom: 16px;
    }

#bdf-root .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

#bdf-root .export-modal.open {
      display: flex;
    }

#bdf-root .export-panel {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      width: min(920px, 95vw);
      max-height: 85vh;
      display: grid;
      gap: 12px;
    }

#bdf-root .export-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

#bdf-root .export-tabs button {
      padding: 6px 10px;
      font-size: 0.75rem;
    }

#bdf-root .export-tabs button.active {
      background: var(--primary);
      color: #fff;
    }

#bdf-root .export-panel textarea {
      width: 100%;
      min-height: 240px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
    }

#bdf-root .input-error {
      color: var(--danger);
      font-size: 0.75rem;
      font-weight: 600;
      min-height: 16px;
    }

    @media (max-width: 900px) {
#bdf-root {
        --form-row-gap: 10px;
        --form-field-gap: 6px;
        --form-vertical-padding: 0px;
        --field-gap-between: 4px;
      }

#bdf-root .field-row {
        gap: 10px;
      }

#bdf-root .field-label {
        flex-basis: clamp(150px, 34vw, 190px);
        max-width: clamp(150px, 34vw, 190px);
      }

#bdf-root .field-row.is-file-field .field-label {
        padding: 7px 9px;
      }

#bdf-root #formContainer {
        height: 680px;
        max-height: 85vh;
      }

#bdf-root .action-bar {
        align-items: flex-start;
      }

#bdf-root .action-main {
        flex-wrap: wrap;
        justify-content: flex-start;
      }

#bdf-root .field-row.is-amount-field .control-stack {
        max-width: min(100%, 248px);
      }

#bdf-root .edit-stage-layout {
        grid-template-columns: 1fr;
      }

#bdf-root .edit-stage-tabs {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

#bdf-root .edit-progress-track {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 360px) {
#bdf-root .field-row {
        flex-direction: column;
        align-items: stretch;
        gap: 4px;
      }

#bdf-root .field-label {
        max-width: none;
      }
    }
  </style>
  <script>
    (() => {
      const styleEl = document.currentScript?.previousElementSibling;
      const init = () => {
        const root = document.getElementById("bdf-root");
        if (!root) return;
        const hasMultipleRoots = document.querySelectorAll("#bdf-root").length > 1;
        if (!hasMultipleRoots) return;
        const uniqueId = `bdf-root-${Math.random().toString(36).slice(2, 9)}`;
        root.id = uniqueId;
        if (styleEl && styleEl.tagName === "STYLE") {
          styleEl.textContent = styleEl.textContent.replace(/#bdf-root/g, `#${uniqueId}`);
        }
      };
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</head>
<body>
  <div id="bdf-root" data-bdf-root>
    <main class="page">
    <div id="debugPanels">
      <section class="card" id="jsonInputsSection">
      <h2>Bubble JSON Girişleri</h2>
      <p class="helper-text">
        Bubble’dan gelen JSON verilerini buraya yapıştırın. Hatalı JSON girildiğinde ilgili alan kırmızı uyarı verir.
      </p>
      <div class="grid three">
        <div>
          <label for="columnJsonInput">Column JSON</label>
          <textarea id="columnJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="columnJsonError"></div>
        </div>
        <div>
          <label for="humanJsonInput">Bubble Data JSON</label>
          <textarea id="humanJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="humanJsonError"></div>
        </div>
        <div>
          <label for="predictedJsonInput">Predicted JSON</label>
          <textarea id="predictedJsonInput" class="field-input" rows="10" placeholder="{}"></textarea>
          <div class="input-error" id="predictedJsonError"></div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <input id="versionInput" type="checkbox" />
        <label for="versionInput">version (true ise sadece form görünsün)</label>
      </div>
      </section>

      <section class="card">
      <h1>Bubble Dynamic Form Element</h1>
      <p class="helper-text">
        Bu demo tek HTML dosyasında çalışır. Bubble elementine alan şemasını JSON olarak girip “Render Et” diyebilirsiniz.
      </p>
      <div class="grid two">
        <div>
          <label for="schemaInput">Schema (fields + config)</label>
          <textarea id="schemaInput" class="field-input" rows="12"></textarea>
        </div>
        <div class="grid">
          <div>
            <label for="currentDateTime">currentDateTimeISO</label>
            <input id="currentDateTime" class="field-input" type="text" />
          </div>
          <div class="grid two">
            <div>
              <label for="localeInput">locale</label>
              <input id="localeInput" class="field-input" type="text" value="tr-TR" />
            </div>
            <div>
              <label for="timezoneInput">timezone</label>
              <input id="timezoneInput" class="field-input" type="text" value="Europe/Istanbul" />
            </div>
          </div>
          <div class="grid two">
            <div>
              <label for="modeInput">mode</label>
              <select id="modeInput" class="field-input">
                <option value="create">create</option>
                <option value="edit">edit</option>
              </select>
            </div>
            <div>
              <label for="requiredPolicyInput">requiredPolicy</label>
              <select id="requiredPolicyInput" class="field-input">
                <option value="strict">strict</option>
                <option value="soft">soft</option>
              </select>
            </div>
          </div>
          <div class="grid two">
            <div class="inline-row">
              <input id="showInlineHelp" type="checkbox" checked />
              <label for="showInlineHelp">showInlineHelp</label>
            </div>
            <div class="inline-row">
              <input id="autoFocusInvalid" type="checkbox" checked />
              <label for="autoFocusInvalid">autoFocusFirstInvalid</label>
            </div>
          </div>
        </div>
      </div>
      <div class="inline-row" style="margin-top: 12px;">
        <button id="loadSample">Schema Yükle</button>
        <button class="secondary" id="renderForm">Render Et</button>
        <button class="ghost" id="clearConsole">Console Temizle</button>
      </div>
      </section>

      <section class="card" id="eventConsoleSection">
        <h2>Event Console</h2>
        <div id="eventConsole" class="console"></div>
      </section>

      <section class="card" id="submitOutputsSection">
        <h2>Submit Outputs</h2>
        <div id="submitOutputs" class="console"></div>
      </section>

      <section class="card">
        <h2>Dynamic Form</h2>
        <div class="debug-toolbar" id="debugToolbar">
        <div class="toolbar-actions">
          <button type="button" id="loadColumnJson">Column Yükle</button>
          <button type="button" class="secondary" id="loadHumanJson">Human JSON Yükle</button>
          <button type="button" class="secondary" id="loadPredictedJson">Predicted JSON Yükle</button>
          <button type="button" class="ghost" id="applyAiToEmpty">AI -> Boş Human Alanlara Uygula</button>
          <button type="button" class="ghost" id="overwriteAiToAll">AI -> Hepsini Overwrite</button>
          <button type="button" class="ghost" id="resetStores">Reset</button>
          <button type="button" class="secondary" id="exportJson">Export JSON</button>
          <button type="button" class="ghost" id="scenarioColumnOnly">Scenario: Column</button>
          <button type="button" class="ghost" id="scenarioColumnHuman">Scenario: Column+Human</button>
          <button type="button" class="ghost" id="scenarioColumnAi">Scenario: Column+AI</button>
          <button type="button" class="ghost" id="scenarioColumnAiHuman">Scenario: Column+AI+Human</button>
          <button type="button" class="ghost" id="scenarioConflict">Scenario: Conflict</button>
        </div>
        <div class="toolbar-status">
          <span id="aiFieldCount">AI alan sayısı: 0</span>
          <span id="humanFieldCount">Human değiştirilen alan sayısı: 0</span>
        </div>
        </div>
        <div id="columnWarning" class="debug-warning" style="display:none;">
          Column JSON yüklenmedi. Debug toolbar üzerinden yükleyin.
        </div>
      </section>
    </div>

    <section class="card">
      <div id="formContainer">
        <div id="actionBar" class="action-bar">
          <div class="action-meta">
            <span class="action-meta-title">Aksiyon</span>
            <span class="action-meta-subtitle">Süreç adımını seçin</span>
          </div>
          <div class="action-main">
            <div class="action-split" id="actionSplit">
              <button id="actionTriggerBtn" type="button" class="action-trigger-btn">Aksiyon seç</button>
              <button id="actionChevronBtn" type="button" class="action-chevron-btn" aria-label="Aksiyon menüsü">▾</button>
              <div id="actionMenu" class="action-menu"></div>
            </div>
            <button id="predictedActionBtn" type="button" class="predicted-action-btn" style="display:none;"></button>
            <span id="actionEmptyMsg" class="action-empty-msg" style="display:none;">Aksiyon yok. Kullanıcıya lütfen sürece bir buton ekleyin uyarısı verilir.</span>
          </div>
        </div>
        <div id="summaryBox" class="summary-box" style="display:none;"></div>
        <div id="editModeRoot" class="edit-mode-root">
          <div class="edit-mode-toolbar">
            <input id="editSearchInput" class="field-input" type="text" placeholder="Alan ara (id / header)" />
          </div>
          <div id="editSearchEmpty" class="edit-search-empty"></div>
          <div id="editProgressWrap" class="edit-progress-wrap" style="display:none;">
            <div id="editProgressTrack" class="edit-progress-track"></div>
            <button id="editProgressToggle" type="button" class="ghost edit-progress-toggle" style="display:none;">Tüm süreç</button>
          </div>
          <div id="editModeLoading" class="edit-mode-loading">
            <span class="edit-mode-spinner" aria-hidden="true"></span>
            <span id="editModeLoadingText">Yükleniyor</span>
            <div class="edit-skeleton-row head"></div>
            <div class="edit-skeleton-row wide"></div>
            <div class="edit-skeleton-row mid"></div>
            <div class="edit-skeleton-row wide"></div>
          </div>
          <section id="editQuickSection" style="display:none;">
            <h3 style="margin:4px 0 8px 0; font-size:14px;">Hızlı Giriş</h3>
            <div id="editQuickFields" class="edit-quick-list"></div>
          </section>
          <div id="editStageLayout" class="edit-stage-layout" style="display:none;">
            <div id="editStageTabs" class="edit-stage-tabs"></div>
            <div id="editStagePanel" class="edit-stage-panel">
              <h3 id="editStageHeading" style="margin:0 0 6px 0; font-size:14px;"></h3>
              <div id="editStageMeta" class="edit-stage-meta"><span></span><span id="editStageChip" class="edit-stage-chip"></span></div>
              <div id="editStageStatus" class="edit-stage-status"></div>
              <div id="editStageFields" class="grid" style="gap:8px;"></div>
            </div>
          </div>
        </div>
        <form id="dynamicForm" class="grid"></form>
        <div class="inline-row" id="formActions" style="margin-top: 12px;">
          <button id="submitBtn" type="submit">Submit</button>
          <button id="clearBtn" type="button" class="ghost">Temizle</button>
        </div>
      </div>
    </section>
    </main>
  <div id="lightbox" class="lightbox" aria-hidden="true">
    <div class="lightbox-content">
      <button type="button" class="lightbox-close">Kapat</button>
      <img id="lightboxImage" alt="Önizleme" />
    </div>
  </div>
  <div id="exportModal" class="export-modal" aria-hidden="true">
    <div class="export-panel">
      <div class="inline-row" style="justify-content: space-between;">
        <strong>JSON Export</strong>
        <button type="button" class="ghost" id="closeExport">Kapat</button>
      </div>
      <div class="export-tabs">
        <button type="button" class="secondary active" data-export-tab="export">Aktif JSON</button>
        <button type="button" class="secondary" data-export-tab="human">Human JSON</button>
        <button type="button" class="secondary" data-export-tab="ai">Predicted JSON</button>
        <button type="button" class="secondary" data-export-tab="column">Column JSON</button>
      </div>
      <textarea id="exportContent" readonly></textarea>
    </div>
  </div>
  </div>

  <script>
    (function () {
      const BDF = (window.__BDF__ = window.__BDF__ || {});
      const IS_VERSION_MODE = Boolean(window.BUBBLE_INPUTS?.VERSION);
      const IS_DEBUG_MODE = Boolean(window.BUBBLE_INPUTS?.DEBUG_MODE);
      BDF.DEBUG_MODE = IS_DEBUG_MODE && !IS_VERSION_MODE;

      const INITIAL_INPUTS = window.BUBBLE_INPUTS || {};
      const IS_EDITING_MODE = INITIAL_INPUTS?.editing === true;

    let MANUAL_COLUMN_JSON = INITIAL_INPUTS.COLUMN_JSON || null;
    let MANUAL_DATA_JSON = INITIAL_INPUTS.BUBBLE_DATA_JSON || null;
    let MANUAL_PREDICTED_JSON = INITIAL_INPUTS.PREDICTED_JSON || null;

    const SAMPLE_COLUMN_JSON = {
      columns: [
        {
          fieldName: "Davacı Ad Soyad",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Davacı TCKN/VKN",
          type: "text",
          required: true,
          stageType: "mandatory"
        },
        {
          fieldName: "Kaza Tarihi",
          type: "date",
          required: true,
          stageType: "mandatory",
          default: "$TODAY"
        },
        {
          fieldName: "İhtar Tarihi",
          type: "date",
          required: false,
          stageType: "optional"
        },
        {
          fieldName: "Randevu Datetime",
          type: "datetime",
          stageType: "control"
        },
        {
          fieldName: "Uygun Saat",
          type: "time",
          stageType: "optional"
        },
        {
          fieldName: "Aracın Tipi",
          type: "dropdown",
          stageType: "mandatory",
          options: [
            { value: "Hususi", label: "Hususi" },
            { value: "Ticari", label: "Ticari" },
            { value: "Kiralık", label: "Kiralık" }
          ]
        },
        {
          fieldName: "Ek Özellikler",
          type: "dropdown",
          stageType: "optional",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri görüş kamera" }
          ]
        },
        {
          fieldName: "Hasar Onarım Tutarı",
          type: "currency",
          stageType: "mandatory"
        },
        {
          fieldName: "Kusur Oranı",
          type: "percent",
          stageType: "mandatory"
        },
        {
          fieldName: "Aracın Kilometresi",
          type: "number",
          stageType: "optional"
        },
        {
          fieldName: "Belgeleri Yükle",
          type: "file",
          allowMultiple: false,
          stageType: "control"
        },
        {
          fieldName: "Hasar Fotoğrafları",
          type: "image",
          allowMultiple: true,
          stageType: "optional"
        },
        {
          fieldName: "Ek Dosyalar",
          type: "multifile",
          allowMultiple: true,
          stageType: "optional"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create"
    };

    const SAMPLE_DATA_JSON = {
      "Belgeleri Yükle": "https://gaiasphere.io/version-live/fileupload/f1770577885537x578585456537153500/hasar_ekspertiz_raporu.pdf",
      "Davacı Kimlik Tipi": "TC Kimlik",
      "Davacı Ad Soyad": "İSMAİL DİNCER",
      "Davacı TCKN/VKN": "12928963404",
      "Davacı Plaka": "19BA618",
      "Davacı Marka Model": "TOYOTA COROLLA 1,6 TERRA SEDAN (Y) 2006",
      "Davacı Şase No": "NMTBZ28E90R141719",
      "Karşı Ad Soyad": "YILMAZ HIŞIR",
      "Karşı TCKN/VKN": "31066362344",
      "Karşı Plaka": "19ABA563",
      "Kaza Tarihi": "2024-11-15",
      "Aracın Markası": "TOYOTA",
      "Aracın Tipi": "Hususi",
      "Aracın Model Yılı": "2006",
      "Kaza Yeri": "Çorum / Merkez / Öğretmen Lisesi 1. Cad. – Öğretmen Lisesi Cad. kavşağı",
      "Davacı Araç Sürücüsü": "İSMAİL DİNCER",
      "Karşı Araç Sürücüsü": "YILMAZ HIŞIR",
      "Karşı Poliçe Türü": "Zorunlu Trafik Sigortası",
      "Karşı Poliçe No": "104781355",
      "Karşı Poliçe Bitiş Tarihi": "2025-09-03",
      "Kaza tespit tutanağı türü": "Anlaşmalı Kaza Tespit Tutanağı",
      "Eksper Rp Tarihi": "2025-02-28",
      "Hasar Onarım Tutarı": "140000",
      "Kusur Oranı": "75",
      "Davali Adi": "Corpus Sigorta A.Ş.",
      "Aracın Kilometresi": "231328",
      "action": "DK Hesaba Taşı",
      "İhtar Tarihi": "Bugünün tarihi",
      "predictedAction": "İhtar Dilekçesi Hazırla",
      "uniqueid": "1770577890579x349136294770973500",
      "Stage": "DK Hesabı",
      "Hasar Fotoğrafları": [
        "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=800&q=60",
        "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=800&q=60"
      ],
      "Ek Dosyalar": [
        "https://example.com/docs/hasar-foto-1.pdf",
        "https://example.com/docs/hasar-foto-2.pdf"
      ],
      "Esas No": ""
    };

    const SAMPLE_PREDICTED_JSON = {
      "İhtar Tarihi": "$TODAY",
      "Hasar Onarım Tutarı": "145000",
      "Kusur Oranı": "80",
      "predictedAction": "İhtar Dilekçesi Hazırla"
    };

    let columnJson = null;
    let humanData = {};
    let aiData = {};
    let sourceByField = {};
    let taskStartTimestamp = null;
    let initialSnapshot = null;
    const ACTION_OUTPUT_SPLITTER = "_-@SPLİTTER@-_";
    let selectedActionId = "";
    let selectedActionName = "Create";
    let triggeredActionUniqueId = "";
    let actionOptions = [];
    let isFormDirty = false;
    let isFormSaving = false;
    let lastAutosaveAt = 0;
    const AUTOSAVE_DEBOUNCE_MS = 2000;
    let lastObservedUniqueId = "";
    let hasPendingUniqueIdSubmit = false;
    let pendingIncomingBubbleData = null;
    let pendingIncomingUniqueId = "";
    let changedFieldKeys = new Set();
    let dirtyFields = {};
    let changedFieldValuesByKey = new Map();
    let lastObservedDataSignature = "";
    let pendingIncomingDataSignature = "";
    let lastStartParamWasTrue = false;
    let hasSeenStartSignal = false;
    let lastStartLoggedState = "";
    let hasChangesSinceStartOpen = false;
    let startOpenSequence = 0;
    let pendingSubmitUntilConfigReady = null;
    const START_FLOW_STORAGE_KEY = "bdf:start-flow-state";
    const START_CHANGED_TRACKING_STORAGE_KEY = "bdf:start-changed-tracking";
    const UNIQUE_ID_STORAGE_KEY = "bdf:last-observed-uniqueid";

    const DEFAULT_CREATE_ACTION_LABEL = "Create";
    const DEFAULT_ACTION_PLACEHOLDER_LABEL = "Aksiyon seç";

    function hasExistingBubbleData() {
      const inputs = window.BUBBLE_INPUTS || {};
      const hasExplicitBubbleData = Object.prototype.hasOwnProperty.call(inputs, "BUBBLE_DATA_JSON");
      const candidate = hasExplicitBubbleData ? inputs.BUBBLE_DATA_JSON : MANUAL_DATA_JSON;
      if (candidate === null || candidate === undefined) return false;
      if (typeof candidate === "string") {
        const trimmed = candidate.trim();
        if (!trimmed) return false;
        if (["null", "undefined", "{}", "[]"].includes(trimmed.toLowerCase())) return false;
        try {
          const parsed = JSON.parse(trimmed);
          if (parsed === null || parsed === undefined) return false;
          if (Array.isArray(parsed)) return parsed.length > 0;
          if (typeof parsed === "object") return Object.keys(parsed).length > 0;
          return Boolean(parsed);
        } catch (error) {
          return false;
        }
      }
      if (Array.isArray(candidate)) return candidate.length > 0;
      if (typeof candidate === "object") return Object.keys(candidate).length > 0;
      return Boolean(candidate);
    }

    function getDefaultActionLabel() {
      return hasExistingBubbleData() ? DEFAULT_ACTION_PLACEHOLDER_LABEL : DEFAULT_CREATE_ACTION_LABEL;
    }

    function syncDefaultActionLabelFromData() {
      if (selectedActionId) return;
      const knownDefaults = ["", DEFAULT_CREATE_ACTION_LABEL, DEFAULT_ACTION_PLACEHOLDER_LABEL];
      if (!knownDefaults.includes(String(selectedActionName || ""))) return;
      selectedActionName = getDefaultActionLabel();
    }


    function parseActionOptionsFromInput(rawValue) {
      if (!rawValue) return [];
      let candidate = rawValue;
      if (typeof candidate === "string") {
        const trimmed = candidate.trim();
        if (!trimmed) return [];
        try {
          candidate = JSON.parse(trimmed);
        } catch (error) {
          return [];
        }
      }
      const list = Array.isArray(candidate?.options) ? candidate.options : [];
      return list
        .map((opt) => ({
          id: String(opt?.id || "").trim(),
          name: String(opt?.name || "").trim()
        }))
        .filter((opt) => opt.id && opt.name);
    }

    function getRawActionOptionsSource() {
      return (
        INITIAL_INPUTS?.actionoptions
        || INITIAL_INPUTS?.ACTIONOPTIONS
        || INITIAL_INPUTS?.COLUMN_JSON?.actionoptions
        || INITIAL_INPUTS?.column_json?.actionoptions
        || null
      );
    }

    function syncActionOptions() {
      const nextOptions = parseActionOptionsFromInput(getRawActionOptionsSource());
      actionOptions = nextOptions;
      if (!actionOptions.some((opt) => opt.id === selectedActionId)) {
        selectedActionId = "";
        selectedActionName = getDefaultActionLabel();
      }
      renderActionOptions();
      updateActionBarUi();
    }

    const rootElement = document.getElementById("bdf-root");
    const styleElement = document.querySelector("style[data-bdf-style]");
    let rootScope = rootElement;

    if (window.BDF_USE_SHADOW === true && rootElement && !rootElement.shadowRoot) {
      const shadow = rootElement.attachShadow({ mode: "open" });
      if (styleElement) {
        const shadowStyle = document.createElement("style");
        shadowStyle.textContent = styleElement.textContent.replace(/#bdf-root/g, ":host");
        shadow.append(shadowStyle);
      }
      while (rootElement.firstChild) {
        shadow.append(rootElement.firstChild);
      }
      rootScope = shadow;
    }

    const qs = (selector) => (rootScope && rootScope.querySelector ? rootScope.querySelector(selector) : null);
    const qsa = (selector) => (rootScope && rootScope.querySelectorAll ? rootScope.querySelectorAll(selector) : []);
    const byId = (id) => qs(`#${id}`);

    function notifyParentHeight() {
      if (window.parent === window) return;
      requestAnimationFrame(() => {
        const first = Math.max(
          document.documentElement ? document.documentElement.scrollHeight : 0,
          document.body ? document.body.scrollHeight : 0
        );
        requestAnimationFrame(() => {
          const second = Math.max(
            document.documentElement ? document.documentElement.scrollHeight : 0,
            document.body ? document.body.scrollHeight : 0
          );
          const height = Math.max(first, second, 200);
          window.parent.postMessage({ type: "BDF_HEIGHT", height }, "*");
        });
      });
    }

    function initParentHeightSync() {
      notifyParentHeight();
      window.addEventListener("resize", notifyParentHeight);
      if (rootElement && "MutationObserver" in window) {
        const mo = new MutationObserver(() => notifyParentHeight());
        mo.observe(rootElement, { childList: true, subtree: true, attributes: true, characterData: true });
      }
      setTimeout(notifyParentHeight, 60);
      setTimeout(notifyParentHeight, 320);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initParentHeightSync);
    } else {
      initParentHeightSync();
    }

    function retryEvery(selector, cb, timeoutMs = 3000, intervalMs = 50) {
      if (!rootScope || !rootScope.querySelector) return;
      const startedAt = Date.now();
      const tryRun = () => {
        const el = rootScope.querySelector(selector);
        if (el) {
          cb(el);
          return true;
        }
        return false;
      };
      if (tryRun()) return;
      const timer = setInterval(() => {
        if (tryRun() || Date.now() - startedAt >= timeoutMs) {
          clearInterval(timer);
        }
      }, intervalMs);
    }

    const safeOn = (target, eventName, handler, options = {}) => {
      const { timeoutMs = 3000, intervalMs = 50 } = options;
      if (typeof target === "string") {
        retryEvery(target, (el) => {
          el.addEventListener(eventName, handler);
        }, timeoutMs, intervalMs);
        return;
      }
      if (!target) return;
      target.addEventListener(eventName, handler);
    };

    function loadSampleSchema() {
      if (!schemaInput) return;
      schemaInput.value = JSON.stringify(defaultSchema, null, 2);
      if (currentDateTimeInput) currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
      if (localeInput) localeInput.value = defaultSchema.locale;
      if (timezoneInput) timezoneInput.value = defaultSchema.timezone;
      if (modeInput) modeInput.value = defaultSchema.mode;
      if (requiredPolicyInput) requiredPolicyInput.value = defaultSchema.requiredPolicy;
      if (showInlineHelpInput) showInlineHelpInput.checked = defaultSchema.showInlineHelp;
      if (autoFocusInvalidInput) autoFocusInvalidInput.checked = defaultSchema.autoFocusFirstInvalid;
    }

    function initLateIncomingDataSync() {
      let lastDataFlag = hasExistingBubbleData() ? "1" : "0";
      let lastOptionsJson = JSON.stringify(parseActionOptionsFromInput(getRawActionOptionsSource()));
      setInterval(() => {
        const nextDataFlag = hasExistingBubbleData() ? "1" : "0";
        const nextOptionsJson = JSON.stringify(parseActionOptionsFromInput(getRawActionOptionsSource()));
        if (nextDataFlag !== lastDataFlag) {
          lastDataFlag = nextDataFlag;
          syncDefaultActionLabelFromData();
          updateActionBarUi();
        }
        if (nextOptionsJson !== lastOptionsJson) {
          lastOptionsJson = nextOptionsJson;
          syncActionOptions();
        }
      }, 700);
    }

    function renderFormFromInputs() {
      const parsed = safeJsonParse(schemaInput?.value || "");
      if (!parsed || !parsed.fields) {
        setConsole("Schema parse edilemedi", "");
        return;
      }
      state.config = {
        ...parsed,
        currentDateTimeISO: currentDateTimeInput?.value || parsed.currentDateTimeISO,
        locale: localeInput?.value || parsed.locale || "tr-TR",
        timezone: timezoneInput?.value || parsed.timezone || "Europe/Istanbul",
        mode: modeInput?.value || parsed.mode || "create",
        requiredPolicy: requiredPolicyInput?.value || parsed.requiredPolicy || "strict",
        showInlineHelp: Boolean(showInlineHelpInput?.checked),
        autoFocusFirstInvalid: Boolean(autoFocusInvalidInput?.checked)
      };
      columnJson = {
        columns: (state.config.fields || []).map((field) => ({
          fieldName: field.label || field.key,
          label: field.label,
          type: field.type,
          required: field.required || normalizeStageType(field.stageType) === "mandatory",
          stageType: field.stageType || "optional",
          options: field.options || [],
          default: field.default,
          allowMultiple: field.allowMultiple || field.ui?.allowMultiple || false,
          ui: field.ui || {}
        })),
        currentDateTimeISO: state.config.currentDateTimeISO,
        locale: state.config.locale,
        timezone: state.config.timezone,
        mode: state.config.mode
      };
      if (columnWarning) columnWarning.style.display = "none";
      if (formContainer) formContainer.style.display = "block";
      renderForm(state.config);
      flushPendingSubmitAfterConfigReady();
    }

    const schemaInput = byId("schemaInput");
    const columnJsonInput = byId("columnJsonInput");
    const humanJsonInput = byId("humanJsonInput");
    const predictedJsonInput = byId("predictedJsonInput");
    const columnJsonError = byId("columnJsonError");
    const humanJsonError = byId("humanJsonError");
    const predictedJsonError = byId("predictedJsonError");
    const versionInput = byId("versionInput");
    const jsonInputsSection = byId("jsonInputsSection");
    const debugPanels = byId("debugPanels");
    const currentDateTimeInput = byId("currentDateTime");
    const localeInput = byId("localeInput");
    const timezoneInput = byId("timezoneInput");
    const modeInput = byId("modeInput");
    const requiredPolicyInput = byId("requiredPolicyInput");
    const showInlineHelpInput = byId("showInlineHelp");
    const autoFocusInvalidInput = byId("autoFocusInvalid");
    const formEl = byId("dynamicForm");
    const editModeRoot = byId("editModeRoot");
    const editSearchInput = byId("editSearchInput");
    const editSearchEmpty = byId("editSearchEmpty");
    const editProgressWrap = byId("editProgressWrap");
    const editProgressTrack = byId("editProgressTrack");
    const editProgressToggle = byId("editProgressToggle");
    const editModeLoading = byId("editModeLoading");
    const editModeLoadingText = byId("editModeLoadingText");
    const editQuickSection = byId("editQuickSection");
    const editQuickFields = byId("editQuickFields");
    const editStageLayout = byId("editStageLayout");
    const editStageTabs = byId("editStageTabs");
    const editStageHeading = byId("editStageHeading");
    const editStageChip = byId("editStageChip");
    const editStageStatus = byId("editStageStatus");
    const editStageFields = byId("editStageFields");
    const submitBtn = byId("submitBtn");
    const clearBtn = byId("clearBtn");
    const summaryBox = byId("summaryBox");
    const formContainer = byId("formContainer");
    const formActions = byId("formActions");
    const actionBar = byId("actionBar");
    const actionSplit = byId("actionSplit");
    const actionTriggerBtn = byId("actionTriggerBtn");
    const actionChevronBtn = byId("actionChevronBtn");
    const actionMenu = byId("actionMenu");
    const predictedActionBtn = byId("predictedActionBtn");
    const actionEmptyMsg = byId("actionEmptyMsg");
    const consoleEl = byId("eventConsole");
    const submitOutputsEl = byId("submitOutputs");
    const eventConsoleSection = byId("eventConsoleSection");
    const submitOutputsSection = byId("submitOutputsSection");
    const lightboxEl = byId("lightbox");
    const lightboxImage = byId("lightboxImage");
    const exportModal = byId("exportModal");
    const exportContent = byId("exportContent");
    const exportTabs = qsa("[data-export-tab]");
    const loadHumanJsonBtn = byId("loadHumanJson");
    const loadPredictedJsonBtn = byId("loadPredictedJson");
    const loadColumnJsonBtn = byId("loadColumnJson");
    const applyAiToEmptyBtn = byId("applyAiToEmpty");
    const overwriteAiToAllBtn = byId("overwriteAiToAll");
    const resetStoresBtn = byId("resetStores");
    const scenarioColumnOnlyBtn = byId("scenarioColumnOnly");
    const scenarioColumnHumanBtn = byId("scenarioColumnHuman");
    const scenarioColumnAiBtn = byId("scenarioColumnAi");
    const scenarioColumnAiHumanBtn = byId("scenarioColumnAiHuman");
    const scenarioConflictBtn = byId("scenarioConflict");
    const exportJsonBtn = byId("exportJson");
    const closeExportBtn = byId("closeExport");
    const aiFieldCountEl = byId("aiFieldCount");
    const humanFieldCountEl = byId("humanFieldCount");
    const columnWarning = byId("columnWarning");
    const debugToolbar = byId("debugToolbar");

    const initBdf = (root) => {
      if (!root || root.__bdfInited) return;
      root.__bdfInited = true;

      safeOn("#loadSample", "click", () => {
        loadSampleSchema();
      });

      safeOn("#renderForm", "click", () => {
        renderFormFromInputs();
      });

      safeOn("#clearConsole", "click", () => {
        if (consoleEl) consoleEl.textContent = "";
      });
    };

    initBdf(rootElement);

    if (columnJsonInput && MANUAL_COLUMN_JSON) {
      columnJsonInput.value = JSON.stringify(MANUAL_COLUMN_JSON, null, 2);
    }
    if (humanJsonInput && MANUAL_DATA_JSON) {
      humanJsonInput.value = JSON.stringify(MANUAL_DATA_JSON, null, 2);
    }
    if (predictedJsonInput && MANUAL_PREDICTED_JSON) {
      predictedJsonInput.value = JSON.stringify(MANUAL_PREDICTED_JSON, null, 2);
    }
    if (versionInput) {
      versionInput.checked = IS_VERSION_MODE;
    }

    const state = {
      config: null,
      values: {},
      validMap: {},
      touched: {},
      errors: {},
      autoSaveTimer: null,
      fileBuffers: {},
      fileStaging: {},
      fieldRefs: {},
      columnData: null
    };

    let editModeSearchTerm = "";
    let editModeDebounceTimer = null;
    let editModeStageOrder = [];
    let editModeStageMeta = [];
    let editSelectedStage = "";
    let editProcessActiveStageKey = "";
    let editProcessShowAll = false;
    let editModePayloadLoaded = false;
    let lastEditModePayloadSignature = "";
    let editModePayloadPollTimer = null;
    let editModeSlowPollTimer = null;
    let editModeStablePollCount = 0;
    let editCachedPayloadRawSignature = "";
    let editCachedPayloadParsed = { stageGroups: null, allFields: null };
    let editStageRenderSeq = 0;

    const defaultSchema = {
      fields: [
        {
          key: "fullName",
          label: "Ad Soyad",
          type: "text",
          required: true,
          placeholder: "Örn. Ayşe Yılmaz",
          helpText: "Kimlikteki ad-soyad",
          minLen: 3
        },
        {
          key: "email",
          label: "E-posta",
          type: "email",
          required: true,
          placeholder: "mail@example.com"
        },
        {
          key: "phone",
          label: "Telefon",
          type: "phone",
          required: true,
          placeholder: "05xx xxx xx xx",
          ui: { autoTrPrefix: true }
        },
        {
          key: "website",
          label: "Website",
          type: "url",
          placeholder: "https://",
          ui: { suggestHttps: true }
        },
        {
          key: "password",
          label: "Şifre",
          type: "password",
          required: true,
          minLen: 8
        },
        {
          key: "bio",
          label: "Açıklama",
          type: "textarea",
          placeholder: "Kısa notlar...",
          maxLen: 240
        },
        {
          key: "age",
          label: "Yaş",
          type: "integer",
          min: 18,
          max: 99
        },
        {
          key: "salary",
          label: "Maaş (₺)",
          type: "currency",
          ui: { currency: "₺", step: 0.01, thousandSeparator: true }
        },
        {
          key: "discount",
          label: "İndirim (%)",
          type: "percent",
          ui: { step: 0.1 }
        },
        {
          key: "subscribe",
          label: "KVKK Onayı",
          type: "boolean",
          required: true,
          helpText: "Zorunlu onay"
        },
        {
          key: "vehicleType",
          label: "Araç Tipi",
          type: "dropdown",
          options: [
            { value: "hususi", label: "Hususi", group: "Binek" },
            { value: "ticari", label: "Ticari", group: "Ticari" },
            { value: "kiralik", label: "Kiralık", group: "Ticari" }
          ],
          required: true
        },
        {
          key: "extras",
          label: "Ek Özellikler",
          type: "dropdown",
          allowMultiple: true,
          options: [
            { value: "camTavan", label: "Cam tavan" },
            { value: "navigasyon", label: "Navigasyon" },
            { value: "kamera", label: "Geri görüş kamera" },
            { value: "isik", label: "LED far" }
          ]
        },
        {
          key: "appointmentDate",
          label: "Randevu Tarihi",
          type: "date",
          required: true,
          default: "$TODAY",
          ui: { showCalendar: true, allowTyping: true, quickActions: true }
        },
        {
          key: "appointmentDateTime",
          label: "Randevu Datetime",
          type: "datetime",
          default: "$NOW",
          ui: { quickActions: true }
        },
        {
          key: "appointmentTime",
          label: "Uygun Saat",
          type: "time",
          default: "$CURRENT_TIME",
          ui: { quickActions: true }
        },
        {
          key: "duration",
          label: "Süre",
          type: "duration",
          ui: { durationFormat: "minutes" }
        },
        {
          key: "address",
          label: "Adres",
          type: "address",
          helpText: "Minimum sokak, ilçe, il ve posta kodu"
        },
        {
          key: "attachments",
          label: "Dosyalar",
          type: "multifile",
          ui: { accept: "image/*,application/pdf", maxFiles: 5, maxSizeMB: 10, showPreview: true }
        },
        {
          key: "profileImage",
          label: "Profil Fotoğrafı",
          type: "image",
          ui: { accept: "image/*", maxFiles: 1, maxSizeMB: 5, showPreview: true }
        },
        {
          key: "metadata",
          label: "JSON (advanced)",
          type: "json",
          placeholder: "{\"foo\":\"bar\"}"
        }
      ],
      currentDateTimeISO: "2026-02-09T12:34:56+03:00",
      locale: "tr-TR",
      timezone: "Europe/Istanbul",
      mode: "create",
      initialValues: {},
      requiredPolicy: "strict",
      showInlineHelp: true,
      autoFocusFirstInvalid: true
    };

    function parseJsonInput(value, errorEl) {
      const trimmed = value.trim();
      if (!trimmed) {
        if (errorEl) errorEl.textContent = "";
        return null;
      }
      try {
        const parsed = JSON.parse(trimmed);
        if (errorEl) errorEl.textContent = "";
        return parsed;
      } catch (error) {
        if (errorEl) errorEl.textContent = "JSON formatı hatalı.";
        return null;
      }
    }

    function syncManualJsonInputs() {
      MANUAL_COLUMN_JSON = parseJsonInput(columnJsonInput?.value || "", columnJsonError);
      MANUAL_DATA_JSON = parseJsonInput(humanJsonInput?.value || "", humanJsonError);
      MANUAL_PREDICTED_JSON = parseJsonInput(predictedJsonInput?.value || "", predictedJsonError);
      syncActionOptions();
    }

    function applyVersionVisibility() {
      const formOnly = IS_VERSION_MODE;
      const debugVisible = !formOnly && BDF.DEBUG_MODE;
      if (debugPanels) {
        debugPanels.style.display = debugVisible ? "block" : "none";
      }
      if (jsonInputsSection) {
        jsonInputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (eventConsoleSection) {
        eventConsoleSection.style.display = debugVisible ? "block" : "none";
      }
      if (submitOutputsSection) {
        submitOutputsSection.style.display = debugVisible ? "block" : "none";
      }
      if (debugToolbar) {
        debugToolbar.style.display = debugVisible ? "flex" : "none";
      }
      if (columnWarning) {
        columnWarning.style.display = debugVisible && !columnJson ? "block" : "none";
      }
      if (formActions) {
        formActions.style.display = "none";
      }
      if (rootElement) {
        rootElement.classList.toggle("editing-mode", IS_EDITING_MODE);
      }
      if (editModeRoot) {
        editModeRoot.style.display = IS_EDITING_MODE ? "grid" : "none";
      }
      if (IS_EDITING_MODE && !editModePayloadLoaded) {
        setEditModeLoading(true, "Edit verileri yükleniyor…");
      }
      if (actionBar) {
        actionBar.style.display = IS_EDITING_MODE ? "none" : "";
      }
      if (formEl) {
        formEl.style.display = IS_EDITING_MODE ? "none" : "grid";
      }
      if (!IS_EDITING_MODE) {
        if (editQuickSection) editQuickSection.style.display = "none";
        if (editStageLayout) editStageLayout.style.display = "none";
      }
      if (formContainer) {
        formContainer.style.display = "block";
        const formSection = formContainer.closest("section");
        if (formSection) {
          Array.from(formSection.children).forEach((child) => {
            if (child === formContainer) return;
            child.style.display = formOnly ? "none" : "";
          });
        }
      }
      if (formOnly) {
        closeLightbox();
        closeExportModal();
      }
    }

    const sampleColumnData = {
      columns: defaultSchema.fields.map((field) => ({
        key: field.key,
        label: field.label,
        type: field.type
      })),
      source: "sample-column-json"
    };

    function setConsole(message, payload) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      if (!consoleEl) return;
      const timestamp = new Date().toLocaleTimeString("tr-TR");
      consoleEl.textContent += `[${timestamp}] ${message}` + (payload ? `\n${payload}` : "") + "\n";
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    
    function getPredictedActionName() {
      const candidate =
        MANUAL_PREDICTED_JSON?.predictedAction
        || MANUAL_DATA_JSON?.predictedAction
        || INITIAL_INPUTS?.PREDICTED_JSON?.predictedAction
        || "";
      return typeof candidate === "string" ? candidate.trim() : "";
    }

    function closeActionMenu() {
      if (actionMenu) actionMenu.classList.remove("open");
    }

    function updateActionBarUi() {
      const hasOptions = Array.isArray(actionOptions) && actionOptions.length > 0;
      syncDefaultActionLabelFromData();
      const safeSelectedName = String(selectedActionName || getDefaultActionLabel()).trim() || getDefaultActionLabel();
      if (actionTriggerBtn) {
        actionTriggerBtn.disabled = false;
        actionTriggerBtn.textContent = safeSelectedName;
      }
      if (actionChevronBtn) {
        actionChevronBtn.disabled = !hasOptions;
        actionChevronBtn.style.display = hasOptions ? "inline-flex" : "none";
      }
      if (actionEmptyMsg) {
        actionEmptyMsg.style.display = "none";
      }

      const predictedActionName = getPredictedActionName();
      const matched = hasOptions
        ? actionOptions.find((opt) => String(opt?.name || "").trim() === predictedActionName)
        : null;
      if (predictedActionBtn) {
        if (!predictedActionName || !hasOptions) {
          predictedActionBtn.style.display = "none";
        } else {
          predictedActionBtn.style.display = "inline-flex";
          predictedActionBtn.textContent = matched
            ? `✨ Önerilen: ${predictedActionName}`
            : `✨ Önerilen: ${predictedActionName} (eşleşme yok)`;
          predictedActionBtn.disabled = !matched;
          predictedActionBtn.dataset.actionId = matched?.id || "";
          predictedActionBtn.dataset.actionName = matched?.name || predictedActionName;
        }
      }
    }

    function triggerSelectedAction() {
      triggeredActionUniqueId = selectedActionId || "";
      emit("onActionTrigger", {
        selectedActionId,
        selectedActionName,
        triggeredActionUniqueId
      });
      if (formEl) {
        formEl.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
      }
    }

    function selectActionAndTrigger(option) {
      if (!option) return;
      selectedActionId = String(option.id || "").trim();
      selectedActionName = String(option.name || getDefaultActionLabel()).trim() || getDefaultActionLabel();
      updateActionBarUi();
      closeActionMenu();
      triggerSelectedAction();
    }

    function renderActionOptions() {
      if (!actionMenu) return;
      actionMenu.innerHTML = "";
      const hasOptions = Array.isArray(actionOptions) && actionOptions.length > 0;
      const shouldShowCreateOption = !hasExistingBubbleData();
      const optionsToRender = hasOptions
        ? (shouldShowCreateOption
          ? [{ id: "", name: DEFAULT_CREATE_ACTION_LABEL, description: "Aksiyonsuz oluşturma" }, ...actionOptions]
          : [...actionOptions])
        : [];

      if (!hasOptions) {
        closeActionMenu();
        selectedActionId = "";
        selectedActionName = getDefaultActionLabel();
        updateActionBarUi();
        return;
      }

      optionsToRender.forEach((option) => {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "action-menu-item";
        if (!option.id) {
          item.textContent = `${option.name} (Aksiyonsuz oluşturma)`;
        } else {
          item.textContent = String(option.name || option.id || "Aksiyon");
        }
        item.addEventListener("click", () => {
          selectActionAndTrigger(option);
        });
        actionMenu.appendChild(item);
      });
      updateActionBarUi();
    }
function renderSubmitOutputs(payload) {
      if (IS_VERSION_MODE) return;
      if (!submitOutputsEl) {
        console.warn("submitOutputs panel not found");
        return;
      }
      const safePayload = payload || {};
      const listToText = (list) => (Array.isArray(list) ? list.join("\n") : String(list ?? ""));
      submitOutputsEl.textContent = [
        `output1: ${safePayload.output1 ?? ""}`,
        `output2: ${safePayload.output2 ?? ""}`,
        `output3: ${safePayload.output3 ?? ""}`,
        `output4: ${safePayload.output4 ?? ""}`,
        "outputlist1:",
        listToText(safePayload.outputlist1),
        "outputlist2:",
        listToText(safePayload.outputlist2),
        "outputlist3:",
        listToText(safePayload.outputlist3),
        "outputlist4:",
        listToText(safePayload.outputlist4)
      ].join("\n");
      console.info("submitOutputs rendered", safePayload);
    }

    function buildSubmitOutputsPayload({ autosave = false } = {}) {
      const endTimestamp = new Date().toISOString();
      const startTimestamp = taskStartTimestamp || endTimestamp;
      const baseOutput4 = buildOutput4String() || "";
      const hasBubbleData = hasExistingBubbleData();
      const actionType = hasBubbleData ? "Process" : "Create";
      const output4 = `${baseOutput4}${ACTION_OUTPUT_SPLITTER}${triggeredActionUniqueId || ""}${ACTION_OUTPUT_SPLITTER}${actionType}`;
      return {
        output1: startTimestamp,
        output2: endTimestamp,
        output3: readCurrentUniqueId(),
        output4: output4,
        outputlist1: buildKeyValueListFromSources(),
        outputlist2: buildAddedCustomFields(),
        outputlist3: buildDeletedFields(),
        outputlist4: buildModifiedFields()
      };
    }

    function emit(eventName, detail) {
      if (IS_VERSION_MODE || !BDF.DEBUG_MODE) return;
      setConsole(eventName, JSON.stringify(detail, null, 2));
    }

    function safeJsonParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return null;
      }
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function getCurrentDateTime(config) {
      return config.currentDateTimeISO || new Date().toISOString();
    }

    function getOffsetFromIso(iso) {
      const match = String(iso).match(/([+-]\d{2}:?\d{2}|Z)$/);
      if (!match) return "Z";
      if (match[1] === "Z") return "Z";
      const offset = match[1].includes(":") ? match[1] : `${match[1].slice(0, 3)}:${match[1].slice(3)}`;
      return offset;
    }

    function getDateFromIso(iso) {
      return String(iso).slice(0, 10);
    }

    function getTimeFromIso(iso) {
      return String(iso).slice(11, 16);
    }

    function normalizeDateInput(raw, config = state.config || {}) {
      if (!raw) return "";
      const trimmed = String(raw).trim();
      const now = getCurrentDateTime(config);
      if (trimmed === "$TODAY" || trimmed === "$NOW") {
        return getDateFromIso(now);
      }
      if (trimmed.includes("T")) {
        return trimmed.slice(0, 10);
      }
      if (trimmed.includes(" ")) {
        return trimmed.split(" ")[0];
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmed)) {
        const [d, m, y] = trimmed.split(".");
        return `${y}-${m}-${d}`;
      }
      if (/^\d{8}$/.test(trimmed)) {
        const d = trimmed.slice(0, 2);
        const m = trimmed.slice(2, 4);
        const y = trimmed.slice(4, 8);
        return `${y}-${m}-${d}`;
      }
      return trimmed;
    }

    function isValidDateString(value) {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return false;
      const [year, month, day] = value.split("-").map((part) => Number(part));
      if (year < 1000 || year > 9999) return false;
      const date = new Date(year, month - 1, day);
      return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
    }

    function isValidTimeString(value) {
      if (!/^\d{2}:\d{2}$/.test(value)) return false;
      const [hour, minute] = value.split(":").map((part) => Number(part));
      return hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59;
    }

    function areValuesDifferent(a, b) {
      if (isEmptyValue(a) && isEmptyValue(b)) return false;
      if (Array.isArray(a) || Array.isArray(b) || typeof a === "object" || typeof b === "object") {
        return JSON.stringify(a ?? null) !== JSON.stringify(b ?? null);
      }
      return String(a ?? "") !== String(b ?? "");
    }

    function formatValueForDisplay(value) {
      if (Array.isArray(value) || typeof value === "object") {
        return JSON.stringify(value, null, 2);
      }
      return String(value ?? "");
    }

    function normalizeTimeInput(raw) {
      if (!raw) return "";
      const cleaned = raw.replace(/\s/g, "");
      if (/^\d{1,2}$/.test(cleaned)) return `${cleaned.padStart(2, "0")}:00`;
      if (/^\d{3}$/.test(cleaned)) return `${cleaned.slice(0, 1).padStart(2, "0")}:${cleaned.slice(1)}`;
      if (/^\d{4}$/.test(cleaned)) return `${cleaned.slice(0, 2)}:${cleaned.slice(2)}`;
      if (/^\d{2}:\d{2}$/.test(cleaned)) return cleaned;
      return cleaned;
    }

    function normalizeDateTimeInput(raw, config) {
      if (!raw) return "";
      const trimmedRaw = String(raw).trim();
      const offset = getOffsetFromIso(getCurrentDateTime(config));
      if (trimmedRaw === "$NOW") {
        return normalizeDateTimeInput(getCurrentDateTime(config), config);
      }
      if (trimmedRaw === "$TODAY") {
        return `${getDateFromIso(getCurrentDateTime(config))}T00:00:00${offset}`;
      }
      const trimmed = trimmedRaw.replace(" ", "T");
      if (/^\d{2}\.\d{2}\.\d{4}$/.test(trimmedRaw)) {
        const [d, m, y] = trimmedRaw.split(".");
        return `${y}-${m}-${d}T00:00:00${offset}`;
      }
      if (/^\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}$/.test(trimmedRaw)) {
        const [datePart, timePart] = trimmedRaw.split(" ");
        const [d, m, y] = datePart.split(".");
        return `${y}-${m}-${d}T${timePart}:00${offset}`;
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
        return `${trimmed}T00:00:00${offset}`;
      }
      const match = trimmed.match(/^(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2})(:\d{2})?(Z|[+-]\d{2}:?\d{2})?$/);
      if (match) {
        const [, datePart, timePart, secondsPart, tzPart] = match;
        const seconds = secondsPart || ":00";
        const tz = tzPart ? (tzPart.includes(":") || tzPart === "Z" ? tzPart : `${tzPart.slice(0, 3)}:${tzPart.slice(3)}`) : offset;
        return `${datePart}T${timePart}${seconds}${tz}`;
      }
      return trimmed;
    }

    function formatDateDisplay(value) {
      if (!value) return "";
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const [y, m, d] = value.split("-");
        return `${d}.${m}.${y}`;
      }
      return value;
    }

    function formatDateTimeDisplay(value) {
      if (!value) return "";
      const normalized = value.includes("T") ? value : normalizeDateTimeInput(value, state.config || {});
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
        const datePart = normalized.slice(0, 10);
        const timePart = normalized.slice(11, 16);
        return `${formatDateDisplay(datePart)} ${timePart}`;
      }
      return value;
    }

    function createMandatoryBadge() {
      const badge = document.createElement("span");
      badge.className = "required-mark";
      badge.textContent = "*";
      badge.setAttribute("aria-hidden", "true");
      return badge;
    }

    function buildCalendarPopover(config, { initialDate = "", onSelect, onClose, quickActionLabel = "Bugün", onQuickAction }) {
      const popover = document.createElement("div");
      popover.className = "picker-popover";
      const header = document.createElement("div");
      header.className = "picker-header";
      const prevBtn = document.createElement("button");
      prevBtn.type = "button";
      prevBtn.className = "picker-nav";
      prevBtn.textContent = "‹";
      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.className = "picker-nav";
      nextBtn.textContent = "›";
      const title = document.createElement("span");
      header.append(prevBtn, title, nextBtn);

      const grid = document.createElement("div");
      grid.className = "picker-grid";

      const actions = document.createElement("div");
      actions.className = "picker-actions";
      const todayBtn = document.createElement("button");
      todayBtn.type = "button";
      todayBtn.className = "ghost";
      todayBtn.textContent = quickActionLabel;
      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.className = "ghost";
      closeBtn.textContent = "Kapat";
      actions.append(todayBtn, closeBtn);

      popover.append(header, grid, actions);

      const weekdayLabels = ["Pzt", "Sal", "Çar", "Per", "Cum", "Cmt", "Paz"];
      let selectedDate = initialDate;
      let viewDate = initialDate ? new Date(`${initialDate}T00:00:00`) : new Date(getCurrentDateTime(config));

      const selectDate = (dateValue, emitChange = true) => {
        selectedDate = dateValue;
        if (dateValue) {
          viewDate = new Date(`${dateValue}T00:00:00`);
        }
        render();
        if (emitChange) onSelect(dateValue);
      };

      const render = () => {
        grid.innerHTML = "";
        weekdayLabels.forEach((label) => {
          const weekday = document.createElement("div");
          weekday.className = "picker-weekday";
          weekday.textContent = label;
          grid.append(weekday);
        });
        const year = viewDate.getFullYear();
        const month = viewDate.getMonth();
        title.textContent = viewDate.toLocaleString("tr-TR", { month: "long", year: "numeric" });
        const firstDay = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const startDay = (firstDay.getDay() + 6) % 7;
        for (let i = 0; i < startDay; i += 1) {
          const empty = document.createElement("div");
          grid.append(empty);
        }
        const todayValue = getDateFromIso(getCurrentDateTime(config));
        for (let day = 1; day <= daysInMonth; day += 1) {
          const dateValue = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
          const button = document.createElement("button");
          button.type = "button";
          button.className = "picker-day";
          button.textContent = String(day);
          if (dateValue === todayValue) button.classList.add("is-today");
          if (dateValue === selectedDate) button.classList.add("is-selected");
          button.addEventListener("click", () => {
            selectDate(dateValue);
          });
          grid.append(button);
        }
      };

      const updateView = (direction) => {
        viewDate = new Date(viewDate.getFullYear(), viewDate.getMonth() + direction, 1);
        render();
      };

      prevBtn.addEventListener("click", () => updateView(-1));
      nextBtn.addEventListener("click", () => updateView(1));
      todayBtn.addEventListener("click", () => {
        if (onQuickAction) {
          onQuickAction({ selectDate });
          return;
        }
        const todayValue = getDateFromIso(getCurrentDateTime(config));
        selectDate(todayValue);
      });
      closeBtn.addEventListener("click", () => {
        popover.classList.remove("open");
        if (onClose) onClose();
      });

      render();

      return {
        element: popover,
        setSelectedDate(dateValue) {
          selectDate(dateValue, false);
        }
      };
    }

    function formatDateMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 8);
      if (digits.length <= 2) return digits;
      if (digits.length <= 4) return `${digits.slice(0, 2)}.${digits.slice(2)}`;
      return `${digits.slice(0, 2)}.${digits.slice(2, 4)}.${digits.slice(4)}`;
    }

    function formatTimeMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length <= 2) return digits;
      return `${digits.slice(0, 2)}:${digits.slice(2)}`;
    }

    function formatDateTimeMask(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 12);
      if (digits.length <= 8) {
        return formatDateMask(digits);
      }
      const dateDigits = digits.slice(0, 8);
      const timeDigits = digits.slice(8);
      const datePart = formatDateMask(dateDigits);
      const timePart = formatTimeMask(timeDigits);
      return `${datePart} ${timePart}`.trim();
    }

    function parseDateDisplay(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 8);
      if (digits.length !== 8) return "";
      const day = digits.slice(0, 2);
      const month = digits.slice(2, 4);
      const year = digits.slice(4, 8);
      return `${year}-${month}-${day}`;
    }

    function parseTimeDisplay(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length !== 4) return "";
      const hour = digits.slice(0, 2);
      const minute = digits.slice(2, 4);
      return `${hour}:${minute}`;
    }

    function parseDateTimeDisplay(value, config) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 12);
      if (digits.length !== 12) return "";
      const day = digits.slice(0, 2);
      const month = digits.slice(2, 4);
      const year = digits.slice(4, 8);
      const hour = digits.slice(8, 10);
      const minute = digits.slice(10, 12);
      const dateValue = `${year}-${month}-${day}`;
      const timeValue = `${hour}:${minute}`;
      if (!isValidDateString(dateValue) || !isValidTimeString(timeValue)) return "";
      const offset = getOffsetFromIso(getCurrentDateTime(config));
      return `${dateValue}T${timeValue}:00${offset}`;
    }

    function normalizeNumberInput(raw) {
      if (raw === null || raw === undefined || raw === "") return "";
      const normalized = String(raw).replace(/\./g, "").replace(",", ".");
      return normalized;
    }

    function formatNumberDisplay(value, options = {}) {
      if (value === "" || value === null || value === undefined || Number.isNaN(Number(value))) return "";
      const numeric = Number(value);
      const formatter = new Intl.NumberFormat("tr-TR", {
        minimumFractionDigits: options.minimumFractionDigits || 0,
        maximumFractionDigits: options.maximumFractionDigits || 2
      });
      return formatter.format(numeric);
    }


    function getDefaultValue(field, config) {
      if (!field.default) return "";
      const token = field.default;
      const now = getCurrentDateTime(config);
      if (token === "$NOW") return now;
      if (token === "$TODAY") return getDateFromIso(now);
      if (token === "$CURRENT_TIME") return getTimeFromIso(now);
      return token;
    }

    function getInitialValue(field, config) {
      const initialValues = config.initialValues || {};
      if (initialValues[field.key] !== undefined) return initialValues[field.key];
      if (config.mode === "create") {
        return getDefaultValue(field, config);
      }
      return "";
    }

    function isEmptyValue(value) {
      if (Array.isArray(value)) return value.length === 0;
      if (value === null || value === undefined) return true;
      if (typeof value === "string") return value.trim() === "";
      return false;
    }

    function normalizeKey(key) {
      if (key === null || key === undefined) return "";
      return String(key).trim();
    }

    function buildFieldKeyMap() {
      const map = new Map();
      (state.config?.fields || []).forEach((field) => {
        const aliases = [
          field.key,
          field.fieldName,
          field.label
        ];
        aliases.forEach((alias) => {
          const normalizedAlias = normalizeKey(alias);
          if (!normalizedAlias) return;
          if (!map.has(normalizedAlias)) {
            map.set(normalizedAlias, field.key);
          }
        });
      });
      return map;
    }

    function getFieldKeyFromJsonKey(jsonKey, keyMap) {
      if (!jsonKey) return null;
      const direct = keyMap.get(normalizeKey(jsonKey));
      if (direct) return direct;
      const normalizedTarget = normalizeKey(jsonKey).toLocaleLowerCase("tr-TR");
      for (const [candidate, fieldKey] of keyMap.entries()) {
        if (candidate.toLocaleLowerCase("tr-TR") === normalizedTarget) {
          return fieldKey;
        }
      }
      return null;
    }


    function markFieldAsChanged(fieldKey) {
      if (!fieldKey) return;
      changedFieldKeys.add(fieldKey);
      dirtyFields[fieldKey] = true;
      persistStartChangedTracking();
      if (hasSeenStartSignal && lastStartParamWasTrue) {
        if (!hasChangesSinceStartOpen) {
          logStartState("edit-detected", { fieldKey, changedKeyCount: changedFieldKeys.size, startOpenSequence });
        }
        hasChangesSinceStartOpen = true;
        persistStartFlowState();
      }
    }

    function clearChangedFieldKeys() {
      changedFieldKeys = new Set();
      dirtyFields = {};
    }


    function rememberChangedFieldValue(fieldKey, value) {
      if (!fieldKey) return;
      changedFieldValuesByKey.set(fieldKey, value);
      persistStartChangedTracking();
    }

    function clearChangedFieldValues() {
      changedFieldValuesByKey = new Map();
    }

    function clearChangedTracking() {
      clearChangedFieldKeys();
      clearChangedFieldValues();
      clearPersistedStartChangedTracking();
      persistStartFlowState();
    }

    function getRememberedChangedValue(fieldKey) {
      return changedFieldValuesByKey.get(fieldKey);
    }

    function getActiveSource(fieldKey) {
      const preferredSource = sourceByField[fieldKey];
      if (preferredSource === "human" || preferredSource === "ai") {
        return preferredSource;
      }
      if (!isEmptyValue(humanData[fieldKey])) return "human";
      if (!isEmptyValue(aiData[fieldKey])) return "ai";
      return "human";
    }

    function getStoreValue(fieldKey, source) {
      return source === "ai" ? aiData[fieldKey] : humanData[fieldKey];
    }

    function getEffectiveValue(fieldKey) {
      const preferredSource = sourceByField[fieldKey];
      if (preferredSource === "human") {
        return humanData[fieldKey] ?? "";
      }
      if (preferredSource === "ai") {
        return aiData[fieldKey] ?? "";
      }
      const humanValue = humanData[fieldKey];
      if (!isEmptyValue(humanValue)) return humanValue;
      const aiValue = aiData[fieldKey];
      if (!isEmptyValue(aiValue)) return aiValue;
      return "";
    }

    function ensureTaskStartTimestamp() {
      if (!taskStartTimestamp) {
        taskStartTimestamp = new Date().toISOString();
      }
    }

    function setHumanValue(fieldKey, value, field, displayValue) {
      ensureTaskStartTimestamp();
      humanData[fieldKey] = value;
      sourceByField[fieldKey] = "human";
      updateEffectiveState(fieldKey, field, displayValue);
      updateAiVisuals(fieldKey);
      updateToolbarStatus();
    }

    function updateEffectiveState(fieldKey, field, displayValue) {
      ensureTaskStartTimestamp();
      const effectiveValue = getEffectiveValue(fieldKey);
      state.values[fieldKey] = effectiveValue;
      let validationValue = effectiveValue;
      if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(effectiveValue)) {
        const stagedFiles = state.fileBuffers[fieldKey] || [];
        if (stagedFiles.length) {
          validationValue = ["__file_selected__"];
        }
      }
      const error = validateField(field, validationValue);
      state.errors[fieldKey] = error;
      state.validMap[fieldKey] = !error;
      emit("onFieldChange", {
        key: fieldKey,
        value: effectiveValue,
        displayValue: displayValue ?? effectiveValue,
        source: getActiveSource(fieldKey),
        isValid: !error
      });
      if (state.config) {
        updateSubmitState(state.config);
      }
      debounceFormChange();
    }

    function updateToolbarStatus() {
      const aiCount = Object.values(aiData).filter((value) => !isEmptyValue(value)).length;
      const humanCount = Object.entries(humanData).filter(([key, value]) => {
        return sourceByField[key] === "human" && !isEmptyValue(value);
      }).length;
      aiFieldCountEl.textContent = `AI alan sayısı: ${aiCount}`;
      humanFieldCountEl.textContent = `Human değiştirilen alan sayısı: ${humanCount}`;
    }

    const typeMetaMap = {
      text: { iconKey: "text", label: "Text" },
      textarea: { iconKey: "text", label: "Textarea" },
      email: { iconKey: "text", label: "Email" },
      phone: { iconKey: "text", label: "Phone" },
      url: { iconKey: "text", label: "URL" },
      integer: { iconKey: "hash", label: "Integer" },
      number: { iconKey: "hash", label: "Number" },
      decimal: { iconKey: "hash", label: "Decimal" },
      currency: { iconKey: "hash", label: "Currency" },
      percent: { iconKey: "hash", label: "Percent" },
      boolean: { iconKey: "check", label: "Boolean" },
      dropdown: { iconKey: "chevron", label: "Dropdown" },
      date: { iconKey: "calendar", label: "Date" },
      time: { iconKey: "clock", label: "Time" },
      datetime: { iconKey: "calendar", label: "Datetime" },
      file: { iconKey: "paperclip", label: "File" },
      image: { iconKey: "image", label: "Image" },
      multifile: { iconKey: "paperclip", label: "Multi file" }
    };

    const displayTypeMetaMap = {
      "text (long)": { iconKey: "text", label: "Text (long)" },
      "multiline text": { iconKey: "text", label: "Multiline text" },
      "e-mail": { iconKey: "text", label: "E-mail" },
      "image&pdf": { iconKey: "paperclip", label: "Image&Pdf" },
      reference: { iconKey: "text", label: "Reference" },
      embed: { iconKey: "text", label: "Embed" },
      user: { iconKey: "text", label: "User" },
      "sys.cf": { iconKey: "text", label: "Sys.cf" },
      "action.cf": { iconKey: "text", label: "Action.cf" }
    };

    function renderIcon(iconKey) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("fill", "none");
      svg.setAttribute("stroke", "currentColor");
      svg.setAttribute("stroke-width", "1.8");
      svg.setAttribute("stroke-linecap", "round");
      svg.setAttribute("stroke-linejoin", "round");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");

      const setPath = (d) => {
        path.setAttribute("d", d);
        svg.appendChild(path);
      };

      switch (iconKey) {
        case "calendar":
          setPath("M7 3v4M17 3v4M4 9h16M5 7h14a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1z");
          break;
        case "chevron":
          setPath("M6 9l6 6 6-6");
          break;
        case "hash":
          setPath("M8 3L6 21M18 3l-2 18M4 8h16M3 16h16");
          break;
        case "paperclip":
          setPath("M16 4l-7 7a4 4 0 0 0 6 6l6-6a3 3 0 1 0-4.5-4.5l-6.5 6.5");
          break;
        case "clock":
          circle.setAttribute("cx", "12");
          circle.setAttribute("cy", "12");
          circle.setAttribute("r", "9");
          svg.appendChild(circle);
          setPath("M12 7v5l3 3");
          break;
        case "check":
          setPath("M5 12l4 4 10-10");
          break;
        case "image":
          setPath("M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1z");
          const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          dot.setAttribute("cx", "8");
          dot.setAttribute("cy", "9");
          dot.setAttribute("r", "1.5");
          svg.appendChild(dot);
          const mountain = document.createElementNS("http://www.w3.org/2000/svg", "path");
          mountain.setAttribute("d", "M4 17l5-5 3 3 4-4 4 4");
          mountain.setAttribute("stroke", "currentColor");
          mountain.setAttribute("stroke-width", "1.8");
          mountain.setAttribute("stroke-linecap", "round");
          mountain.setAttribute("stroke-linejoin", "round");
          mountain.setAttribute("fill", "none");
          svg.appendChild(mountain);
          break;
        case "text":
        default:
          setPath("M5 6h14M12 6v12");
          break;
      }
      return svg;
    }

    function getTypeMeta(field) {
      const displayKey = String(field.displayType || "").toLowerCase();
      return displayTypeMetaMap[displayKey] || typeMetaMap[field.type] || { iconKey: "text", label: field.type || "text" };
    }

    function normalizeStageType(stageType) {
      if (!stageType) return "";
      return String(stageType).trim().toLowerCase();
    }

    function isInnerStageType(stageType) {
      return normalizeStageType(stageType) === "innerstage";
    }

    function isFieldRequired(field) {
      return Boolean(field.required) || normalizeStageType(field.stageType) === "mandatory";
    }

    function getMergedValidationValue(field) {
      return getEffectiveValue(field.key);
    }

    function isImageLike(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith("image/")) return true;
      if (file.url && String(file.url).startsWith("data:image/")) return true;
      if (file.url) {
        return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(file.url);
      }
      return false;
    }

    function isDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:");
    }

    function isPdfDataUrl(value) {
      return typeof value === "string" && value.startsWith("data:application/pdf");
    }

    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        if (!file) {
          resolve("");
          return;
        }
        const reader = new FileReader();
        reader.onload = () => resolve(typeof reader.result === "string" ? reader.result : "");
        reader.onerror = () => reject(reader.error || new Error("file read error"));
        reader.readAsDataURL(file);
      });
    }

    function isCompressibleImageType(contentType) {
      const type = String(contentType || "").toLowerCase();
      return ["image/jpeg", "image/jpg", "image/png", "image/webp"].includes(type);
    }

    function loadImageBitmapOrElement(file) {
      return new Promise(async (resolve, reject) => {
        try {
          if (typeof createImageBitmap === "function") {
            try {
              const bmp = await createImageBitmap(file, { imageOrientation: "from-image" });
              resolve({ image: bmp, width: bmp.width, height: bmp.height, close: () => bmp.close?.() });
              return;
            } catch (_) {
              const bmp = await createImageBitmap(file);
              resolve({ image: bmp, width: bmp.width, height: bmp.height, close: () => bmp.close?.() });
              return;
            }
          }
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({ image: img, width: img.naturalWidth || img.width, height: img.naturalHeight || img.height, close: () => {} });
          };
          img.onerror = (err) => {
            URL.revokeObjectURL(url);
            reject(err || new Error("image load failed"));
          };
          img.src = url;
        } catch (error) {
          reject(error);
        }
      });
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob || null), type, quality);
      });
    }

    async function maybeCompressImageFile(file) {
      if (!file || !isCompressibleImageType(file.type)) return file;
      if (file.size < 400 * 1024) return file;

      const loaded = await loadImageBitmapOrElement(file);
      const originalWidth = loaded.width || 0;
      const originalHeight = loaded.height || 0;
      if (originalWidth <= 1200 && originalHeight <= 1200) {
        loaded.close?.();
        return file;
      }

      const maxWidth = 1800;
      const maxHeight = 1800;
      const scale = Math.min(1, maxWidth / originalWidth, maxHeight / originalHeight);
      const targetWidth = Math.max(1, Math.round(originalWidth * scale));
      const targetHeight = Math.max(1, Math.round(originalHeight * scale));

      const canvas = document.createElement("canvas");
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      const ctx = canvas.getContext("2d", { alpha: file.type === "image/png" });
      if (!ctx) {
        loaded.close?.();
        return file;
      }
      ctx.drawImage(loaded.image, 0, 0, targetWidth, targetHeight);
      loaded.close?.();

      const type = String(file.type || "").toLowerCase();
      const outputType = type === "image/jpg" ? "image/jpeg" : type;
      const quality = outputType === "image/jpeg" || outputType === "image/webp" ? 0.82 : undefined;
      const compressedBlob = await canvasToBlob(canvas, outputType, quality);
      if (!compressedBlob || !compressedBlob.size) return file;
      if (compressedBlob.size >= file.size) return file;

      return new File([compressedBlob], file.name, {
        type: outputType,
        lastModified: file.lastModified || Date.now()
      });
    }

    function isLikelyBase64(value) {
      if (typeof value !== "string") return false;
      if (value.length < 60) return false;
      if (value.includes("://")) return false;
      if (value.startsWith("data:")) return false;
      return /^[A-Za-z0-9+/=\r\n]+$/.test(value);
    }

    function normalizeFileValueForPreview(field, value) {
      if (!value || typeof value !== "string") return value;
      if (field.type === "image" && isLikelyBase64(value)) {
        return `data:image/*;base64,${value}`;
      }
      return value;
    }

    function parseInitialFiles(initialValue, allowMultiple, field) {
      if (!initialValue) return [];
      let values = Array.isArray(initialValue) ? initialValue : [initialValue];
      if (!allowMultiple && values.length > 1) {
        values = [values[0]];
      }
      values = values.map((value) => normalizeFileValueForPreview(field, value));
      return values
        .filter((val) => typeof val === "string")
        .map((url) => ({
          url,
          name: isDataUrl(url) ? (isPdfDataUrl(url) ? "dosya.pdf" : "gorsel") : url.split("/").pop() || "dosya",
          size: 0,
          type: isImageLike({ url }) ? "image/*" : isPdfDataUrl(url) ? "application/pdf" : "",
          lastModified: null,
          preview: url
        }));
    }

    function resolveTokenValue(rawValue, field, config) {
      if (rawValue === "$TODAY") {
        return getDateFromIso(getCurrentDateTime(config));
      }
      if (rawValue === "$NOW") {
        return getCurrentDateTime(config);
      }
      if (rawValue === "$CURRENT_TIME") {
        return getTimeFromIso(getCurrentDateTime(config));
      }
      return rawValue;
    }

    function normalizeJsonValueForField(field, value, config) {
      if (value === null || value === undefined) return "";
      let resolved = resolveTokenValue(value, field, config);
      if (field.type === "date") {
        resolved = normalizeDateInput(String(resolved), config);
        return resolved;
      }
      if (field.type === "time") {
        resolved = normalizeTimeInput(String(resolved));
        return resolved;
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(resolved), config);
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        return normalizeNumberInput(resolved);
      }
      if (field.type === "boolean") {
        if (typeof resolved === "string") {
          return resolved.toLowerCase() === "true";
        }
        return Boolean(resolved);
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        if (Array.isArray(resolved)) return resolved;
        if (typeof resolved === "string") return resolved.split(",").map((val) => val.trim()).filter(Boolean);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(resolved)) return resolved.filter((val) => typeof val === "string");
        if (typeof resolved === "string") return resolved;
        return "";
      }
      return resolved;
    }

    function normalizeMultiValue(value) {
      if (Array.isArray(value)) {
        return Array.from(new Set(value.map((entry) => String(entry)))).sort();
      }
      if (typeof value === "string") {
        const parts = value.split(",").map((entry) => entry.trim()).filter(Boolean);
        return Array.from(new Set(parts)).sort();
      }
      return [];
    }

    function normalizeValueForComparison(field, value, config) {
      if (isEmptyValue(value)) return "";
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
        const numeric = Number(normalizeNumberInput(value));
        return Number.isNaN(numeric) ? "" : numeric;
      }
      if (field.type === "date") {
        return normalizeDateInput(String(value), config);
      }
      if (field.type === "datetime") {
        return normalizeDateTimeInput(String(value), config);
      }
      if (field.type === "time") {
        return normalizeTimeInput(String(value));
      }
      if (field.type === "dropdown" && field.allowMultiple) {
        return normalizeMultiValue(value);
      }
      if (["file", "image", "multifile"].includes(field.type)) {
        if (Array.isArray(value)) {
          return Array.from(new Set(value.filter((entry) => typeof entry === "string"))).sort();
        }
        return typeof value === "string" ? value : "";
      }
      if (field.type === "boolean") {
        return Boolean(value);
      }
      return value;
    }

    function updateAiVisuals(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const aiValue = aiData[fieldKey];
      const hasAi = !isEmptyValue(aiValue);
      const activeSource = getActiveSource(fieldKey);
      const humanValue = humanData[fieldKey];
      const hasHuman = !isEmptyValue(humanValue);
      const hasConflict = hasAi && hasHuman && areValuesDifferent(humanValue, aiValue);
      ref.aiBadge.style.display = hasAi ? "inline-flex" : "none";
      ref.aiBadge.classList.toggle("is-active", activeSource === "ai");
      ref.aiBadge.classList.toggle("is-passive", activeSource !== "ai" && hasAi);
      ref.control.classList.toggle("ai-active", activeSource === "ai" && hasAi);
      ref.aiPill.style.display = activeSource === "ai" && hasAi ? "inline-flex" : "none";
      if (ref.applyAiBtn) {
        ref.applyAiBtn.style.display = !hasHuman && hasAi ? "inline-flex" : "none";
      }
      if (ref.revertAiBtn) {
        ref.revertAiBtn.style.display = hasHuman && hasAi && activeSource !== "ai" ? "inline-flex" : "none";
      }
      if (ref.conflictChip) {
        ref.conflictChip.style.display = hasConflict ? "inline-flex" : "none";
      }
      if (ref.conflictPopover) {
        if (hasConflict) {
          ref.conflictPopover.querySelector("[data-conflict-human]").textContent = formatValueForDisplay(humanValue);
          ref.conflictPopover.querySelector("[data-conflict-ai]").textContent = formatValueForDisplay(aiValue);
        } else {
          ref.conflictPopover.classList.remove("open");
        }
      }
    }

    function updateFieldDisplayValue(fieldKey) {
      const ref = state.fieldRefs[fieldKey];
      if (!ref) return;
      const value = getEffectiveValue(fieldKey);
      if (ref.setValue) {
        ref.setValue(value);
      }
      updateAiVisuals(fieldKey);
      updateEffectiveState(fieldKey, ref.field);
    }

    function refreshAllFields() {
      Object.keys(state.fieldRefs).forEach((fieldKey) => {
        updateFieldDisplayValue(fieldKey);
      });
      if (IS_EDITING_MODE) {
        runEditModeFilterRender();
        if (formEl) formEl.style.display = "none";
      }
      updateToolbarStatus();
      if (state.config) {
        updateSubmitState(state.config);
      }
    }

    function loadJsonSafeToForm(kind, jsonObj) {
      if (!jsonObj || !state.config) return;
      const keyMap = buildFieldKeyMap();
      console.info("loadJsonSafeToForm:start", { kind, keys: Object.keys(jsonObj || {}) });
      Object.entries(jsonObj).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) {
          console.warn(`Eşleşmeyen JSON key: ${jsonKey}`);
          setConsole("Eşleşmeyen JSON key", jsonKey);
          return;
        }
        const field = state.config.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        const normalized = normalizeJsonValueForField(field, rawValue, state.config);
        if (kind === "ai") {
          aiData[fieldKey] = normalized;
        } else {
          humanData[fieldKey] = normalized;
          sourceByField[fieldKey] = "human";
        }
      });
      refreshAllFields();
      if (state.config) {
        updateSubmitState(state.config);
      }
      console.info("loadJsonSafeToForm:done", { kind, values: buildExportJson() });
    }

    function applyScenario({ name, column, human, ai }) {
      emit("debug:scenario", { name, column, human, ai });
      applyColumnJson(column);
      humanData = {};
      aiData = {};
      sourceByField = {};
      if (human) {
        loadJsonSafeToForm("human", human);
      }
      if (ai) {
        loadJsonSafeToForm("ai", ai);
      }
      initializeSourceByFieldFromAi();
      refreshAllFields();
      if (ai && human) {
        openExportModal("export");
      } else if (ai) {
        openExportModal("ai");
      } else if (human) {
        openExportModal("human");
      } else {
        openExportModal("column");
      }
    }

    function initializeSourceByFieldFromAi() {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        sourceByField[field.key] = !isEmptyValue(aiValue) ? "ai" : "human";
      });
    }

    function normalizeAllowMultiple(value) {
      if (typeof value === "string") {
        return ["yes", "true", "1"].includes(value.trim().toLowerCase());
      }
      return Boolean(value);
    }

    function normalizeColumnType(rawType, allowMultipleValue) {
      const raw = String(rawType || "").trim();
      const normalizedRaw = raw.toLowerCase();
      let allowMultiple = normalizeAllowMultiple(allowMultipleValue);
      if (["single_select", "multi_select", "dropdown"].includes(normalizedRaw)) {
        if (normalizedRaw === "multi_select") {
          allowMultiple = true;
        }
        return { type: "dropdown", allowMultiple, displayType: raw || "dropdown" };
      }
      if (normalizedRaw === "checkbox") {
        return { type: "boolean", allowMultiple, displayType: raw || "checkbox" };
      }
      if (normalizedRaw === "text (long)" || normalizedRaw === "multiline text") {
        return { type: "textarea", allowMultiple, displayType: raw || "text (long)" };
      }
      if (normalizedRaw === "e-mail") {
        return { type: "email", allowMultiple, displayType: raw || "e-mail" };
      }
      if (normalizedRaw === "image&pdf") {
        return { type: allowMultiple ? "multifile" : "file", allowMultiple, displayType: raw || "image&pdf" };
      }
      if (["reference", "embed", "user", "sys.cf", "action.cf"].includes(normalizedRaw)) {
        return { type: "text", allowMultiple, displayType: raw || normalizedRaw };
      }
      if (normalizedRaw === "phone") {
        return { type: "phone", allowMultiple, displayType: raw || "phone" };
      }
      if (normalizedRaw === "number") {
        return { type: "number", allowMultiple, displayType: raw || "number" };
      }
      if (normalizedRaw === "date") {
        return { type: "date", allowMultiple, displayType: raw || "date" };
      }
      if (normalizedRaw === "text") {
        return { type: "text", allowMultiple, displayType: raw || "text" };
      }
      return { type: raw || "text", allowMultiple, displayType: raw || "text" };
    }

    function buildConfigFromColumnJson(columnData) {
      if (!columnData) return null;
      const columns = columnData.columns || [];
      const fields = columns.reduce((acc, column, index) => {
        const fieldName = column.id || `field_${index + 1}`;
        const normalized = normalizeColumnType(column.type, column.multiple);
        const stageType = column.stageType || "optional";
        if (isInnerStageType(stageType)) {
          return acc;
        }
        acc.push({
          key: fieldName,
          fieldName,
          label: column.header || fieldName,
          type: normalized.type,
          displayType: normalized.displayType,
          required: normalizeStageType(stageType) === "mandatory" || Boolean(column.required),
          stageType,
          allowMultiple: Boolean(column.multiple),
          readOnly: Boolean(column.readOnly),
          options: Array.isArray(column.source) ? column.source.map((value) => ({ value, label: value })) : [],
          default: column.default,
          ui: column.ui || {}
        });
        return acc;
      }, []);
      return {
        fields,
        currentDateTimeISO: columnData.currentDateTimeISO || defaultSchema.currentDateTimeISO,
        locale: columnData.locale || "tr-TR",
        timezone: columnData.timezone || "Europe/Istanbul",
        mode: columnData.mode || "create",
        requiredPolicy: defaultSchema.requiredPolicy,
        showInlineHelp: defaultSchema.showInlineHelp,
        autoFocusFirstInvalid: defaultSchema.autoFocusFirstInvalid
      };
    }

    function captureInitialSnapshot() {
      if (initialSnapshot || !state.config) return;
      initialSnapshot = buildBaselineSnapshot(MANUAL_DATA_JSON);
    }

    function applyColumnJson(columnData) {
      columnJson = columnData;
      if (!columnJson) {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
        return;
      }
      columnWarning.style.display = "none";
      formContainer.style.display = "block";
      state.config = buildConfigFromColumnJson(columnJson);
      if (!state.config) return;
      renderForm(state.config);
      flushPendingSubmitAfterConfigReady();
    }

    function buildExportJson() {
      const payload = {};
      (state.config?.fields || []).forEach((field) => {
        const value = getEffectiveValue(field.key);
        const jsonKey = field.key;
        payload[jsonKey] = normalizeValueForComparison(field, value, state.config);
      });
      return payload;
    }

    function buildBaselineSnapshot(baselineData) {
      const baseline = baselineData || {};
      const snapshot = {};
      const keyMap = buildFieldKeyMap();
      Object.entries(baseline || {}).forEach(([jsonKey, rawValue]) => {
        const fieldKey = getFieldKeyFromJsonKey(jsonKey, keyMap);
        if (!fieldKey) return;
        const field = state.config?.fields.find((f) => f.key === fieldKey);
        if (!field) return;
        snapshot[fieldKey] = normalizeValueForComparison(field, rawValue, state.config);
      });

      (state.config?.fields || []).forEach((field) => {
        if (snapshot[field.key] !== undefined) return;
        const initialValue = getInitialValue(field, state.config || {});
        snapshot[field.key] = normalizeValueForComparison(field, initialValue, state.config);
      });

      return snapshot;
    }

    function getCurrentValueForField(field) {
      return getEffectiveValue(field.key);
    }

    function getCurrentNormalizedValue(field) {
      return normalizeValueForComparison(field, getCurrentValueForField(field), state.config);
    }

    function buildKeyValueListFromSources() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!changedFieldKeys.has(field.key)) return;
        const jsonKey = field.key;
        const rememberedValue = getRememberedChangedValue(field.key);
        const currentValue = rememberedValue !== undefined ? rememberedValue : getCurrentNormalizedValue(field);
        const baselineValue = base[jsonKey] ?? "";
        if (!areValuesDifferent(baselineValue, currentValue)) return;
        const safeValue = isEmptyValue(currentValue) ? "" : currentValue;
        entries.push(`"${jsonKey}": ${JSON.stringify(safeValue)}`);
      });
      traceAutosave("buildKeyValueListFromSources", { entriesCount: entries.length, entries });
      return entries;
    }

    function buildAddedCustomFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!changedFieldKeys.has(field.key)) return;
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        const isFileField = ["file", "image", "multifile"].includes(String(field.type || "").toLowerCase());

        if (isFileField) {
          const initialUrls = getFileFieldUrlsFromValue(initialValue);
          const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
          const currentUrls = currentFiles
            .map((file) => (file && typeof file.url === "string" ? file.url : ""))
            .filter(Boolean);
          const hasNewFiles = currentFiles.some((file) => Boolean(file && file.raw));
          const hasAnyCurrentFileAction = currentUrls.length > 0 || hasNewFiles;
          if (initialUrls.length === 0 && hasAnyCurrentFileAction) {
            entries.push(field.label || jsonKey);
          }
          return;
        }

        if (!isEmptyValue(currentValue) && isEmptyValue(initialValue)) {
          entries.push(field.label || jsonKey);
        }
      });
      return entries;
    }

    function buildDeletedFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!changedFieldKeys.has(field.key)) return;
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        if (!isEmptyValue(initialValue) && isEmptyValue(currentValue)) {
          entries.push(jsonKey);
        }
      });
      return entries;
    }

    function buildModifiedFields() {
      const entries = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!changedFieldKeys.has(field.key)) return;
        const jsonKey = field.key;
        const initialValue = base[jsonKey];
        const currentValue = getCurrentNormalizedValue(field);
        const isFileField = ["file", "image", "multifile"].includes(String(field.type || "").toLowerCase());

        if (isFileField) {
          const initialUrls = Array.from(new Set(getFileFieldUrlsFromValue(initialValue))).sort();
          const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
          const currentUrls = Array.from(new Set(
            currentFiles
              .map((file) => (file && typeof file.url === "string" ? file.url : ""))
              .filter(Boolean)
          )).sort();
          const hasNewFiles = currentFiles.some((file) => Boolean(file && file.raw));
          const hasUrlChange = JSON.stringify(initialUrls) !== JSON.stringify(currentUrls);
          if (hasUrlChange || hasNewFiles) {
            entries.push(jsonKey);
          }
          return;
        }

        if (isEmptyValue(initialValue) || isEmptyValue(currentValue)) return;
        if (areValuesDifferent(initialValue, currentValue)) {
          entries.push(jsonKey);
        }
      });
      return entries;
    }

    function toStringArray(value) {
      if (Array.isArray(value)) return value.filter((item) => typeof item === "string");
      if (typeof value === "string" && value) return [value];
      return [];
    }

    function getFileFieldUrlsFromValue(value) {
      return toStringArray(value).filter((entry) => typeof entry === "string" && /^(https?:\/\/|\/|data:)/i.test(entry));
    }

    function stripDataUrlPrefix(value) {
      if (typeof value !== "string") return "";
      const marker = ";base64,";
      const idx = value.indexOf(marker);
      if (idx >= 0) return value.slice(idx + marker.length);
      return value;
    }

    function buildOutput4String() {
      const items = [];
      const base = initialSnapshot || {};
      (state.config?.fields || []).forEach((field) => {
        if (!["file", "multifile", "image"].includes(String(field.type || "").toLowerCase())) return;
        if (!changedFieldKeys.has(field.key)) return;
        const customFieldName = String(field.label || field.fieldName || field.key || "").trim();
        if (!customFieldName) return;

        const initialUrls = getFileFieldUrlsFromValue(base[field.key]);
        const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
        const keptFromCurrent = currentFiles
          .map((file) => (file && typeof file.url === "string" ? file.url : ""))
          .filter(Boolean);
        const keptSet = new Set(keptFromCurrent);
        const removedSet = new Set(initialUrls.filter((url) => !keptSet.has(url)));
        removedSet.forEach((url) => {
          if (keptSet.has(url)) removedSet.delete(url);
        });

        const newFiles = currentFiles
          .filter((file) => file && file.raw && typeof file.base64 === "string" && file.base64)
          .map((file) => ({
            filename: String(file.name || file.raw?.name || "dosya"),
            contentType: String(file.type || file.raw?.type || "application/octet-stream"),
            base64: stripDataUrlPrefix(file.base64)
          }));

        const keptUrls = Array.from(keptSet);
        const removedUrls = Array.from(removedSet);
        const initialSorted = Array.from(new Set(initialUrls)).sort();
        const keptSorted = Array.from(new Set(keptUrls)).sort();
        const hasUrlChange = JSON.stringify(initialSorted) !== JSON.stringify(keptSorted);
        const hasFileOperation = hasUrlChange || removedUrls.length > 0 || newFiles.length > 0;
        if (!hasFileOperation) return;

        items.push({
          customFieldName,
          keptUrls,
          removedUrls,
          newFiles
        });
      });

      if (!items.length) return null;
      return JSON.stringify({
        version: 1,
        items
      });
    }

    function getActivityType() {
      const hasPredictedData = Object.values(aiData).some((value) => !isEmptyValue(value));
      const hasAiUsage = (state.config?.fields || []).some((field) => {
        return getActiveSource(field.key) === "ai" && !isEmptyValue(aiData[field.key]);
      });
      return hasPredictedData && hasAiUsage ? "Stage complated/HITL" : "Stage complated";
    }

    function validateField(field, value) {
      if (isFieldRequired(field) && isEmptyValue(value)) {
        if (field.type === "boolean") {
          return "Zorunlu onay gerekir.";
        }
        return "Bu alan zorunlu.";
      }
      if (field.type === "email" && value) {
        if (!String(value).includes("@")) return "Geçerli bir e-posta girin.";
      }
      if (field.type === "phone" && value) {
        if (!/\d{10,}/.test(String(value).replace(/\D/g, ""))) return "Telefon formatı hatalı.";
      }
      if (field.type === "url" && value) {
        if (!/^https?:\/\//.test(String(value))) return "URL http(s):// ile başlamalı.";
      }
      if (["integer", "decimal", "currency", "percent", "number"].includes(field.type) && value !== "") {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) return "Geçerli bir sayı girin.";
        if (field.min !== undefined && numeric < field.min) return `Minimum ${field.min}`;
        if (field.max !== undefined && numeric > field.max) return `Maksimum ${field.max}`;
        if (field.type === "percent" && (numeric < 0 || numeric > 100)) return "0-100 arası girin.";
      }
      if (["text", "textarea", "password", "email", "url"].includes(field.type) && value) {
        if (field.minLen && String(value).length < field.minLen) return `En az ${field.minLen} karakter.`;
        if (field.maxLen && String(value).length > field.maxLen) return `En fazla ${field.maxLen} karakter.`;
        if (field.pattern) {
          const regex = new RegExp(field.pattern);
          if (!regex.test(String(value))) return field.validate?.find((r) => r.name === "regex")?.message || "Format hatası.";
        }
      }
      if (["date", "datetime", "time"].includes(field.type) && value) {
        if (field.type === "date") {
          const normalized = normalizeDateInput(String(value), state.config || {});
          if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
            return "Tarih formatı gg.aa.yyyy veya yyyy-mm-dd olmalı.";
          }
          if (!isValidDateString(normalized)) {
            return "Geçerli bir tarih girin.";
          }
        }
        if (field.type === "time" && !isValidTimeString(String(value))) return "Saat formatı HH:mm olmalı.";
        if (field.type === "datetime" && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(String(value))) return "Tarih ve saat gerekli.";
      }
      return "";
    }

    function setFieldValue(key, value, field, displayValue) {
      setHumanValue(key, value, field, displayValue);
      markFieldAsChanged(key);
      rememberChangedFieldValue(key, normalizeValueForComparison(field, getEffectiveValue(key), state.config));
      isFormDirty = computeDirtyState();
    }

    function parseDataJsonSource(rawValue) {
      if (rawValue === null || rawValue === undefined) return null;
      if (typeof rawValue === "string") {
        const trimmed = rawValue.trim();
        if (!trimmed) return null;
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          return null;
        }
      }
      if (typeof rawValue === "object") return rawValue;
      return null;
    }

    function extractUniqueIdFromObject(candidate) {
      if (!candidate || Array.isArray(candidate) || typeof candidate !== "object") return "";
      const uniqueIdRaw = candidate.uniqueid ?? candidate.uniquieid ?? candidate.uniqueId ?? candidate.UniqueId;
      if (uniqueIdRaw !== null && uniqueIdRaw !== undefined) {
        return String(uniqueIdRaw).trim();
      }
      if (candidate.data && typeof candidate.data === "object") {
        const nested = candidate.data.uniqueid ?? candidate.data.uniquieid ?? candidate.data.uniqueId ?? candidate.data.UniqueId;
        if (nested !== null && nested !== undefined) {
          return String(nested).trim();
        }
      }
      return "";
    }

    function extractUniqueIdFromString(rawValue) {
      const parsed = parseDataJsonSource(rawValue);
      const parsedUniqueId = extractUniqueIdFromObject(parsed);
      if (parsedUniqueId) return parsedUniqueId;
      const text = String(rawValue || "");
      const match = text.match(/(?:"|')(?:uniqueid|uniquieid|uniqueId|UniqueId)(?:"|')\s*:\s*(?:"|')([^"']+)(?:"|')/i);
      return match ? String(match[1] || "").trim() : "";
    }

    function extractUniqueId(rawValue) {
      if (typeof rawValue === "string") return extractUniqueIdFromString(rawValue);
      return extractUniqueIdFromObject(rawValue);
    }

    function extractBubbleDataObject(rawValue) {
      const parsed = parseDataJsonSource(rawValue);
      if (!parsed || typeof parsed !== "object") return null;
      if (Array.isArray(parsed)) return null;
      if (parsed.data && typeof parsed.data === "object" && !Array.isArray(parsed.data)) {
        return parsed.data;
      }
      return parsed;
    }

    function readCurrentBubbleDataObject() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.BUBBLE_DATA_JSON,
        inputs.bubble_data_json,
        window.BUBBLE_DATA_JSON,
        MANUAL_DATA_JSON
      ];
      for (const candidate of candidates) {
        const obj = extractBubbleDataObject(candidate);
        if (obj) return obj;
      }
      return null;
    }


    function safeStringify(value) {
      try {
        return JSON.stringify(value);
      } catch (error) {
        return "";
      }
    }

    function readCurrentBubbleDataSignature() {
      const dataObj = readCurrentBubbleDataObject();
      if (!dataObj || typeof dataObj !== "object") return "";
      return safeStringify(dataObj);
    }


    function readCurrentColumnJsonObject() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.COLUMN_JSON,
        inputs.column_json,
        window.BUBBLE_COLUMN_JSON,
        MANUAL_COLUMN_JSON
      ];
      for (const candidate of candidates) {
        const parsed = parseDataJsonSource(candidate);
        if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) continue;
        if (Array.isArray(parsed.columns)) return parsed;
      }
      return null;
    }


    function applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, uniqueId, incomingColumnJson) {
      traceAutosave("applyIncomingBubbleDataAsCurrentItem:start", {
        uniqueId,
        hasIncomingBubbleData: Boolean(incomingBubbleData),
        incomingBubbleDataKeys: incomingBubbleData && typeof incomingBubbleData === "object" ? Object.keys(incomingBubbleData) : [],
        hasIncomingColumns: Boolean(incomingColumnJson && Array.isArray(incomingColumnJson.columns)),
        incomingColumnCount: Array.isArray(incomingColumnJson?.columns) ? incomingColumnJson.columns.length : 0
      });
      const hasIncomingColumns = Boolean(incomingColumnJson && Array.isArray(incomingColumnJson.columns));
      if (hasIncomingColumns) {
        MANUAL_COLUMN_JSON = incomingColumnJson;
        applyColumnJson(incomingColumnJson);
      }

      if (incomingBubbleData && state.config) {
        MANUAL_DATA_JSON = incomingBubbleData;
        humanData = {};
        aiData = {};
        sourceByField = {};
        state.fileBuffers = {};
        state.fileStaging = {};
        loadJsonSafeToForm("human", incomingBubbleData);
        initializeSourceByFieldFromAi();
        refreshAllFields();
        initialSnapshot = buildBaselineSnapshot(incomingBubbleData);
      }
      clearChangedTracking();
      isFormDirty = false;
      taskStartTimestamp = null;
      hasPendingUniqueIdSubmit = false;
      if (uniqueId) {
        lastObservedUniqueId = uniqueId;
        persistObservedUniqueId(uniqueId);
      }
      lastObservedDataSignature = readCurrentBubbleDataSignature();
      traceAutosave("applyIncomingBubbleDataAsCurrentItem:done", { uniqueId, dataSignatureLen: lastObservedDataSignature.length });
    }

    function flushPendingIncomingAfterSubmit() {
      traceAutosave("flushPendingIncomingAfterSubmit:start");
      if (!pendingIncomingUniqueId) {
        traceAutosave("flushPendingIncomingAfterSubmit:skip-no-pending");
        return;
      }
      const incomingBubbleData = pendingIncomingBubbleData;
      const uniqueId = pendingIncomingUniqueId;
      const dataSignature = pendingIncomingDataSignature;
      pendingIncomingBubbleData = null;
      pendingIncomingUniqueId = "";
      pendingIncomingDataSignature = "";

      const currentUniqueId = readCurrentUniqueId();
      const isSameItemNow = Boolean(currentUniqueId) && currentUniqueId === uniqueId;
      if (isSameItemNow && isFormDirty) {
        traceAutosave("flushPendingIncomingAfterSubmit:skip-overwrite-dirty", { uniqueId });
        lastObservedUniqueId = uniqueId;
        persistObservedUniqueId(uniqueId);
        return;
      }

      traceAutosave("flushPendingIncomingAfterSubmit:apply", { uniqueId, dataSignatureLen: dataSignature.length });
      applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, uniqueId, readCurrentColumnJsonObject());
    }

    function persistObservedUniqueId(uniqueId) {
      if (!uniqueId) return;
      try {
        window.sessionStorage.setItem(UNIQUE_ID_STORAGE_KEY, uniqueId);
      } catch (error) {
        // ignore storage access issues
      }
    }

    function readPersistedObservedUniqueId() {
      try {
        return String(window.sessionStorage.getItem(UNIQUE_ID_STORAGE_KEY) || "").trim();
      } catch (error) {
        return "";
      }
    }

    function readPersistedStartFlowState() {
      try {
        const raw = window.sessionStorage.getItem(START_FLOW_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        return {
          lastStartParamWasTrue: Boolean(parsed.lastStartParamWasTrue),
          hasChangesSinceStartOpen: Boolean(parsed.hasChangesSinceStartOpen),
          startOpenSequence: Number(parsed.startOpenSequence) || 0,
          time: parsed.time || ""
        };
      } catch (error) {
        return null;
      }
    }

    function persistStartFlowState() {
      try {
        window.sessionStorage.setItem(START_FLOW_STORAGE_KEY, JSON.stringify({
          lastStartParamWasTrue,
          hasChangesSinceStartOpen,
          startOpenSequence,
          time: new Date().toISOString()
        }));
      } catch (error) {
        // ignore storage access issues
      }
    }

    function persistStartChangedTracking() {
      try {
        window.sessionStorage.setItem(START_CHANGED_TRACKING_STORAGE_KEY, JSON.stringify({
          changedKeys: Array.from(changedFieldKeys || []),
          changedValues: Array.from((changedFieldValuesByKey || new Map()).entries()),
          time: new Date().toISOString()
        }));
      } catch (error) {
        // ignore storage access issues
      }
    }

    function clearPersistedStartChangedTracking() {
      try {
        window.sessionStorage.removeItem(START_CHANGED_TRACKING_STORAGE_KEY);
      } catch (error) {
        // ignore storage access issues
      }
    }

    function readPersistedStartChangedTracking() {
      try {
        const raw = window.sessionStorage.getItem(START_CHANGED_TRACKING_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const keys = Array.isArray(parsed.changedKeys) ? parsed.changedKeys.filter(Boolean) : [];
        const changedValues = new Map(Array.isArray(parsed.changedValues) ? parsed.changedValues : []);
        return { keys, changedValues, time: parsed.time || "" };
      } catch (error) {
        return null;
      }
    }

    function readCurrentUniqueId() {
      const inputs = window.BUBBLE_INPUTS || {};
      const candidates = [
        inputs.BUBBLE_DATA_JSON,
        inputs.bubble_data_json,
        window.BUBBLE_DATA_JSON,
        MANUAL_DATA_JSON
      ];
      for (const candidate of candidates) {
        const uniqueId = extractUniqueId(candidate);
        if (uniqueId) return uniqueId;
      }
      return "";
    }


    function normalizeStartSignalValue(rawValue) {
      if (rawValue === undefined || rawValue === null) return null;
      if (typeof rawValue === "boolean") return rawValue;
      if (typeof rawValue === "number") return rawValue === 1;
      const normalized = String(rawValue).trim().toLowerCase();
      if (["true", "1", "yes", "open", "opened"].includes(normalized)) return true;
      if (["false", "0", "no", "close", "closed"].includes(normalized)) return false;
      return null;
    }

    function safeReadBubbleInputsFrom(target) {
      try {
        return target && target.BUBBLE_INPUTS && typeof target.BUBBLE_INPUTS === "object"
          ? target.BUBBLE_INPUTS
          : null;
      } catch (error) {
        return null;
      }
    }

    function readStartSignalSnapshot() {
      const keyCandidates = ["start", "START", "startParam", "start_flag", "startFlag", "start_mode", "startMode"];
      const inputsScopes = [
        { scope: "window", inputs: safeReadBubbleInputsFrom(window) },
        { scope: "parent", inputs: safeReadBubbleInputsFrom(window.parent) },
        { scope: "top", inputs: safeReadBubbleInputsFrom(window.top) }
      ];
      const observedRawValues = {};

      for (const { scope, inputs } of inputsScopes) {
        if (!inputs) continue;
        for (const key of keyCandidates) {
          if (!Object.prototype.hasOwnProperty.call(inputs, key)) continue;
          const rawValue = inputs[key];
          observedRawValues[`${scope}.${key}`] = rawValue;
          const parsed = normalizeStartSignalValue(rawValue);
          if (parsed !== null) {
            return { value: parsed, source: `${scope}.BUBBLE_INPUTS.${key}`, rawValue, observedRawValues };
          }
        }
      }

      const searchTargets = [
        { source: "window.location.search", query: window.location.search },
        { source: "window.location.hash", query: window.location.hash && window.location.hash.includes("?") ? window.location.hash.split("?")[1] : "" }
      ];

      for (const target of searchTargets) {
        try {
          if (!target.query) continue;
          const queryValue = new URLSearchParams(target.query).get("start");
          observedRawValues[target.source] = queryValue;
          const parsed = normalizeStartSignalValue(queryValue);
          if (parsed !== null) {
            return { value: parsed, source: `${target.source}:start`, rawValue: queryValue, observedRawValues };
          }
        } catch (error) {
          observedRawValues[`${target.source}:error`] = String(error?.message || error || "parse_error");
        }
      }

      return { value: null, source: "unresolved", rawValue: null, observedRawValues };
    }

    function readStartSignalValue() {
      return readStartSignalSnapshot().value;
    }

    function traceAutosave(label, payload = {}) {
      const snapshot = {
        label,
        time: new Date().toISOString(),
        lastObservedUniqueId,
        currentUniqueId: readCurrentUniqueId(),
        pendingIncomingUniqueId,
        pendingIncomingDataSignatureLen: pendingIncomingDataSignature.length,
        hasPendingUniqueIdSubmit,
        lastObservedDataSignatureLen: lastObservedDataSignature.length,
        isFormDirty,
        isFormSaving,
        changedKeys: Array.from(changedFieldKeys || []),
        startSignal: readStartSignalValue(),
        lastStartParamWasTrue,
        hasSeenStartSignal,
        ...payload
      };
      console.info(`[BDF_AUTOSAVE_TRACE] ${JSON.stringify(snapshot)}`);
      if (!IS_VERSION_MODE && BDF.DEBUG_MODE) {
        setConsole(`trace:${label}`, JSON.stringify(snapshot, null, 2));
      }
    }


    function logStartState(label, extra = {}) {
      const startSnapshot = readStartSignalSnapshot();
      const snapshot = {
        label,
        startSignal: startSnapshot.value,
        startSignalSource: startSnapshot.source,
        startSignalRawValue: startSnapshot.rawValue,
        lastStartParamWasTrue,
        hasSeenStartSignal,
        isFormDirty,
        isFormSaving,
        changedKeys: Array.from(changedFieldKeys || []),
        observedStartValues: startSnapshot.observedRawValues,
        ...extra
      };
      console.info(`[BDF_START_FLOW] ${JSON.stringify(snapshot)}`);
      if (!IS_VERSION_MODE && BDF.DEBUG_MODE) {
        setConsole(`start:${label}`, JSON.stringify(snapshot, null, 2));
      }
    }

    function flushPendingSubmitAfterConfigReady() {
      if (!pendingSubmitUntilConfigReady) return;
      if (!state.config || !Array.isArray(state.config.fields)) return;
      const pending = pendingSubmitUntilConfigReady;
      pendingSubmitUntilConfigReady = null;
      logStartState("flush-pending-submit-after-config", {
        trigger: pending.trigger,
        autosave: pending.autosave,
        forceSubmit: pending.forceSubmit,
        requestedAt: pending.requestedAt
      });
      setTimeout(() => {
        runSubmitFlow({
          autosave: pending.autosave,
          forceSubmit: pending.forceSubmit,
          trigger: `${pending.trigger}:after-config-ready`
        });
      }, 0);
    }

    function getSubmitFn() {
      return (
        (typeof window.bubble_fn_submit === "function" && window.bubble_fn_submit) ||
        (window.parent && typeof window.parent.bubble_fn_submit === "function" && window.parent.bubble_fn_submit) ||
        (window.top && typeof window.top.bubble_fn_submit === "function" && window.top.bubble_fn_submit)
      );
    }

    function computeDirtyState() {
      if (!state.config) return false;
      return (
        buildKeyValueListFromSources().length > 0
        || buildAddedCustomFields().length > 0
        || buildDeletedFields().length > 0
        || buildModifiedFields().length > 0
      );
    }

    function handleBeforeUnload(event) {
      const shouldSubmitOnUnload = hasSeenStartSignal && lastStartParamWasTrue && (hasChangesSinceStartOpen || isFormDirty || changedFieldKeys.size > 0) && !isFormSaving;
      logStartState("beforeunload", {
        shouldSubmitOnUnload,
        hasChangesSinceStartOpen,
        changedKeyCount: changedFieldKeys.size
      });
      if (shouldSubmitOnUnload) {
        runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "beforeunload" });
      }
      persistStartFlowState();
      if (!isFormDirty) return undefined;
      if (!isFormSaving) {
        runSubmitFlow({ autosave: false, forceSubmit: true, trigger: "beforeunload-dirty-fallback" });
      }
      const warningMessage = "Kaydedilmemiş değişiklikler olabilir.";
      event.preventDefault();
      event.returnValue = warningMessage;
      return warningMessage;
    }

    function runSubmitFlow({ autosave = false, forceSubmit = false, trigger = "unknown" } = {}) {
      traceAutosave("runSubmitFlow:start", { autosave, forceSubmit, trigger });
      if (!state.config || !Array.isArray(state.config.fields)) {
        pendingSubmitUntilConfigReady = {
          autosave,
          forceSubmit,
          trigger,
          requestedAt: new Date().toISOString()
        };
        logStartState("submit-skipped-no-config", {
          trigger,
          autosave,
          forceSubmit,
          hasConfig: Boolean(state.config),
          queuedForConfigReady: true
        });
        isFormSaving = false;
        return;
      }
      if (isFormSaving && !forceSubmit) {
        console.info("submit skipped: saving lock active", { autosave });
        return;
      }

      isFormSaving = true;
      if (autosave) {
        triggeredActionUniqueId = "";
      }

      ensureTaskStartTimestamp();
      validateAll();
      const firstInvalidKey = focusFirstInvalid();
      const invalidCount = Object.values(state.validMap).filter((val) => !val).length;
      if (invalidCount > 0) {
        summaryBox.style.display = "block";
        summaryBox.textContent = `${invalidCount} alan eksik veya hatalı.`;
      } else {
        summaryBox.style.display = "none";
      }

      const exportPayload = buildExportJson();
      const submitOutputsPayload = buildSubmitOutputsPayload({ autosave });
      traceAutosave("runSubmitFlow:payload-built", {
        trigger,
        output1: submitOutputsPayload.output1,
        output2: submitOutputsPayload.output2,
        output3: submitOutputsPayload.output3,
        output4: submitOutputsPayload.output4,
        outputlist1Count: Array.isArray(submitOutputsPayload.outputlist1) ? submitOutputsPayload.outputlist1.length : -1,
        outputlist2Count: Array.isArray(submitOutputsPayload.outputlist2) ? submitOutputsPayload.outputlist2.length : -1,
        outputlist3Count: Array.isArray(submitOutputsPayload.outputlist3) ? submitOutputsPayload.outputlist3.length : -1,
        outputlist4Count: Array.isArray(submitOutputsPayload.outputlist4) ? submitOutputsPayload.outputlist4.length : -1
      });
      console.info("submitOutputs payload", submitOutputsPayload);
      console.info("submitOutputs:panel", { exists: Boolean(submitOutputsEl), autosave });
      setConsole("debug:submit-outputs", JSON.stringify(submitOutputsPayload, null, 2));
      renderSubmitOutputs(submitOutputsPayload);

      emit("onSubmitAttempt", {
        values: exportPayload,
        isFormValid: invalidCount === 0,
        firstInvalidKey,
        output1: submitOutputsPayload.output1,
        output2: submitOutputsPayload.output2,
        output3: submitOutputsPayload.output3,
        output4: submitOutputsPayload.output4,
        outputlist1: submitOutputsPayload.outputlist1,
        outputlist2: submitOutputsPayload.outputlist2,
        outputlist3: submitOutputsPayload.outputlist3,
        outputlist4: submitOutputsPayload.outputlist4
      });

      const fn = getSubmitFn();
      if (!fn) {
        isFormSaving = false;
        isFormDirty = true;
        flushPendingIncomingAfterSubmit();
        console.warn("bubble_fn_submit bulunamadı (window/parent/top)");
        return;
      }

      const payload = submitOutputsPayload;
      try {
        const maybePromise = fn(payload);
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise
            .then(() => {
              isFormSaving = false;
              isFormDirty = false;
              if (shouldResetAfterSubmit({ autosave })) {
                resetFormAfterSuccessfulSubmit();
              }
              flushPendingIncomingAfterSubmit();
            })
            .catch((error) => {
              isFormSaving = false;
              isFormDirty = true;
              flushPendingIncomingAfterSubmit();
              console.error("submit failed", error);
            });
          return;
        }
        isFormSaving = false;
        isFormDirty = false;
        if (shouldResetAfterSubmit({ autosave })) {
          resetFormAfterSuccessfulSubmit();
        }
        flushPendingIncomingAfterSubmit();
      } catch (error) {
        isFormSaving = false;
        isFormDirty = true;
        flushPendingIncomingAfterSubmit();
        console.error("submit failed", error);
      }

      hasPendingUniqueIdSubmit = false;
    }

    function shouldResetAfterSubmit({ autosave }) {
      if (autosave) return false;
      const mode = String(state.config?.mode || "").trim().toLowerCase();
      return mode === "create";
    }

    function resetFormAfterSuccessfulSubmit() {
      resetAllStores();
      summaryBox.style.display = "none";
    }

    function maybeRunAutosaveOnStartClose() {
      const now = Date.now();
      if (!isFormDirty) return;
      if (isFormSaving) return;
      if (now - lastAutosaveAt < AUTOSAVE_DEBOUNCE_MS) return;
      lastAutosaveAt = now;
      runSubmitFlow({ autosave: true });
    }

    function evaluateUniqueIdTransition() {
      const nextUniqueId = readCurrentUniqueId();
      const nextDataSignature = readCurrentBubbleDataSignature();
      const uniqueIdChanged = Boolean(nextUniqueId) && nextUniqueId !== lastObservedUniqueId;
      const dataChanged = Boolean(nextDataSignature) && nextDataSignature !== lastObservedDataSignature;

      if (!nextUniqueId && !nextDataSignature) return;

      if (!lastObservedUniqueId && nextUniqueId) {
        traceAutosave("evaluateUniqueIdTransition:init-observed", { nextUniqueId });
        lastObservedUniqueId = nextUniqueId;
        persistObservedUniqueId(nextUniqueId);
      }
      if (!lastObservedDataSignature && nextDataSignature) {
        lastObservedDataSignature = nextDataSignature;
      }

      if (!uniqueIdChanged && !dataChanged) {
        return;
      }

      const incomingBubbleData = readCurrentBubbleDataObject();
      const incomingColumnJson = readCurrentColumnJsonObject();

      if (isFormSaving) {
        pendingIncomingBubbleData = incomingBubbleData;
        pendingIncomingUniqueId = nextUniqueId || lastObservedUniqueId;
        pendingIncomingDataSignature = nextDataSignature;
        traceAutosave("evaluateUniqueIdTransition:queued-while-saving", { nextUniqueId, dataChanged, uniqueIdChanged });
        return;
      }

      if (isFormDirty) {
        pendingIncomingBubbleData = incomingBubbleData;
        pendingIncomingUniqueId = nextUniqueId || lastObservedUniqueId;
        pendingIncomingDataSignature = nextDataSignature;
        hasPendingUniqueIdSubmit = true;
        traceAutosave("evaluateUniqueIdTransition:dirty-submit-current-first", {
          nextUniqueId,
          dataChanged,
          uniqueIdChanged,
          pendingIncomingBubbleDataKeys: incomingBubbleData && typeof incomingBubbleData === "object" ? Object.keys(incomingBubbleData) : []
        });
        maybeRunAutosaveOnStartClose();
        runSubmitFlow({ autosave: false, forceSubmit: true });
        if (incomingColumnJson && Array.isArray(incomingColumnJson.columns)) {
          MANUAL_COLUMN_JSON = incomingColumnJson;
        }
        return;
      }

      traceAutosave("evaluateUniqueIdTransition:apply-direct", { nextUniqueId, dataChanged, uniqueIdChanged });
      applyIncomingBubbleDataAsCurrentItem(incomingBubbleData, nextUniqueId || lastObservedUniqueId, incomingColumnJson);
    }

    function evaluateStartSignalTransition() {
      const startSignal = readStartSignalValue();
      if (startSignal === null) return;

      logStartState("tick", {
        startSignal,
        changedKeyCount: changedFieldKeys.size,
        hasChangesSinceStartOpen,
        shouldSubmitIfClose: Boolean(lastStartParamWasTrue && !startSignal && (hasChangesSinceStartOpen || isFormDirty || changedFieldKeys.size > 0) && !isFormSaving)
      });

      const signalText = String(Boolean(startSignal));
      if (lastStartLoggedState !== signalText) {
        lastStartLoggedState = signalText;
        logStartState("signal-change", { startSignal });
      }

      hasSeenStartSignal = true;
      if (!lastStartParamWasTrue && startSignal) {
        lastStartParamWasTrue = true;
        startOpenSequence += 1;
        hasChangesSinceStartOpen = false;
        logStartState("open", { startSignal, startOpenSequence, changedKeyCount: changedFieldKeys.size });
        persistStartFlowState();
        return;
      }

      if (lastStartParamWasTrue && !startSignal) {
        const hasDirtyIndicators = hasChangesSinceStartOpen || isFormDirty || changedFieldKeys.size > 0;
        const shouldSubmit = hasDirtyIndicators && !isFormSaving;
        logStartState("close", {
          startSignal,
          shouldSubmit,
          hasDirtyIndicators,
          hasChangesSinceStartOpen,
          isFormDirty,
          changedKeyCount: changedFieldKeys.size,
          startOpenSequence
        });
        lastStartParamWasTrue = false;
        if (shouldSubmit) {
          logStartState("close-trigger-submit", {
            mode: "autosave",
            trigger: "start-close",
            startOpenSequence,
            changedKeyCount: changedFieldKeys.size
          });
          hasChangesSinceStartOpen = false;
          persistStartFlowState();
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "start-close" });
        } else {
          logStartState("close-skip-submit", {
            reason: isFormSaving ? "saving-lock" : "no-detected-change",
            hasChangesSinceStartOpen,
            isFormDirty,
            changedKeyCount: changedFieldKeys.size,
            startOpenSequence
          });
        }
        persistStartFlowState();
        return;
      }

      lastStartParamWasTrue = Boolean(startSignal);
      persistStartFlowState();
    }

    function initAutosaveStartWatcher() {
      const persistedStartFlowState = readPersistedStartFlowState();
      const persistedChangedTracking = readPersistedStartChangedTracking();
      const currentDataSignature = readCurrentBubbleDataSignature();
      const startSignal = readStartSignalValue();
      if (persistedChangedTracking && Array.isArray(persistedChangedTracking.keys) && persistedChangedTracking.keys.length) {
        changedFieldKeys = new Set(persistedChangedTracking.keys);
        changedFieldValuesByKey = persistedChangedTracking.changedValues instanceof Map
          ? persistedChangedTracking.changedValues
          : new Map();
        logStartState("hydrate-persisted-changed-tracking", {
          changedKeyCount: changedFieldKeys.size,
          persistedAt: persistedChangedTracking.time || ""
        });
      }
      if (persistedStartFlowState) {
        startOpenSequence = Math.max(startOpenSequence, persistedStartFlowState.startOpenSequence || 0);
      }
      if (startSignal !== null) {
        hasSeenStartSignal = true;
        lastStartParamWasTrue = Boolean(startSignal);
        hasChangesSinceStartOpen = lastStartParamWasTrue
          ? Boolean(persistedStartFlowState?.hasChangesSinceStartOpen)
          : false;
        logStartState("seed", { startSignal, startOpenSequence });

        const wasOpenBeforeRemount = Boolean(persistedStartFlowState?.lastStartParamWasTrue);
        const hadChangesBeforeRemount = Boolean(persistedStartFlowState?.hasChangesSinceStartOpen);
        const shouldSubmitRemountClose = wasOpenBeforeRemount && !startSignal && hadChangesBeforeRemount && !isFormSaving;
        if (shouldSubmitRemountClose) {
          hasChangesSinceStartOpen = false;
          lastStartParamWasTrue = false;
          persistStartFlowState();
          if (changedFieldKeys.size === 0 && persistedChangedTracking?.keys?.length) {
            changedFieldKeys = new Set(persistedChangedTracking.keys);
          }
          logStartState("remount-close-trigger-submit", {
            persistedStartFlowState,
            changedKeyCount: changedFieldKeys.size,
            trigger: "start-close-remount"
          });
          runSubmitFlow({ autosave: true, forceSubmit: true, trigger: "start-close-remount" });
        }
        persistStartFlowState();
      }
      if (currentDataSignature) {
        lastObservedDataSignature = currentDataSignature;
      }

      if (window.history && typeof window.history.pushState === "function") {
        const originalPushState = window.history.pushState.bind(window.history);
        window.history.pushState = function pushStatePatched(...args) {
          const result = originalPushState(...args);
          evaluateStartSignalTransition();
          return result;
        };
      }

      if (window.history && typeof window.history.replaceState === "function") {
        const originalReplaceState = window.history.replaceState.bind(window.history);
        window.history.replaceState = function replaceStatePatched(...args) {
          const result = originalReplaceState(...args);
          evaluateStartSignalTransition();
          return result;
        };
      }

      window.addEventListener("popstate", evaluateStartSignalTransition);
      window.addEventListener("hashchange", evaluateStartSignalTransition);
      window.addEventListener("beforeunload", handleBeforeUnload);
      setInterval(evaluateStartSignalTransition, 300);
    }

    function debounceFormChange() {
      if (state.autoSaveTimer) {
        clearTimeout(state.autoSaveTimer);
      }
      state.autoSaveTimer = setTimeout(() => {
        emit("onFormChange", {
          values: buildExportJson(),
          validMap: state.validMap,
          isFormValid: Object.values(state.validMap).every(Boolean)
        });
        if (IS_EDITING_MODE) {
          maybeRunAutosaveOnStartClose();
        }
      }, 500);
    }

    function setEditModeLoading(isLoading, message = "") {
      if (!editModeLoading) return;
      editModeLoading.style.display = isLoading ? "grid" : "none";
      if (editQuickSection) editQuickSection.style.display = isLoading ? "none" : "block";
      if (editStageLayout) editStageLayout.style.display = isLoading ? "none" : "grid";
      if (editProgressWrap) editProgressWrap.style.display = isLoading ? "none" : editProgressWrap.style.display;
      if (editModeLoadingText && message) {
        editModeLoadingText.textContent = message;
      }
    }

    function parseIncomingJson(rawValue) {
      if (rawValue === null || rawValue === undefined) return null;
      if (typeof rawValue === "string") {
        const trimmed = rawValue.trim();
        if (!trimmed) return null;
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          return null;
        }
      }
      return rawValue;
    }

    function readEditModePayloadSources() {
      const source = window.BUBBLE_INPUTS || {};
      const stageRaw = source.editSchemaJson ?? source.editUiSchema ?? source.EDITING_STAGE_GROUPS_JSON ?? source.editingStageGroups ?? source.editing_stage_groups ?? null;
      const allRaw = source.EDITING_ALL_FIELDS_JSON ?? source.editingAllFields ?? source.editing_all_fields ?? null;
      const rawSignature = `${typeof stageRaw}:${String(stageRaw ?? "").slice(0, 50000)}||${typeof allRaw}:${String(allRaw ?? "").slice(0, 50000)}`;
      if (rawSignature === editCachedPayloadRawSignature) {
        return editCachedPayloadParsed;
      }
      const parsed = {
        stageGroups: parseIncomingJson(stageRaw),
        allFields: parseIncomingJson(allRaw)
      };
      editCachedPayloadRawSignature = rawSignature;
      editCachedPayloadParsed = parsed;
      return parsed;
    }

    function buildEditPayloadSignature(payload) {
      try {
        const stage = payload?.stageGroups || [];
        const all = payload?.allFields || [];
        return `${JSON.stringify(stage).length}:${JSON.stringify(all).length}`;
      } catch (error) {
        return `${Date.now()}`;
      }
    }

    function getStageKey(name, order, fallbackIndex = 0) {
      const normalizedName = String(name || "").trim();
      if (normalizedName) return `name:${normalizedName.toLocaleLowerCase("tr-TR")}`;
      const orderNumber = Number(order);
      if (Number.isFinite(orderNumber)) return `order:${orderNumber}`;
      return `fallback:${fallbackIndex}`;
    }

    function getStageLabel(name, order, fallbackIndex = 0) {
      const normalizedName = String(name || "").trim();
      if (normalizedName) return normalizedName;
      const orderNumber = Number(order);
      if (Number.isFinite(orderNumber)) return `Stage ${orderNumber}`;
      return `Stage ${fallbackIndex + 1}`;
    }

    function normalizeEditFieldItem(item, index, stageName = "", stageKey = "") {
      const raw = item && typeof item === "object" ? item : { value: item };
      const key = String(raw.id || raw.key || raw.fieldName || raw.name || raw.header || raw.label || `field_${index + 1}`).trim();
      const label = String(raw.header || raw.label || raw.fieldName || raw.name || key).trim() || key;
      const normalized = normalizeColumnType(raw.type || "text", raw.multiple || raw.allowMultiple);
      const type = String(normalized.type || raw.type || "text").toLowerCase();
      const value = raw.value ?? raw.currentValue ?? raw.fieldValue ?? raw.default ?? "";
      const sourceOptions = Array.isArray(raw.source) ? raw.source : [];
      const options = Array.isArray(raw.options) ? raw.options : sourceOptions;
      return {
        key,
        fieldName: key,
        label,
        type,
        displayType: normalized.displayType || raw.type || "text",
        required: normalizeStageType(raw.stageType || "optional") === "mandatory" || Boolean(raw.required),
        stageType: raw.stageType || "optional",
        allowMultiple: Boolean(raw.multiple || raw.allowMultiple),
        readOnly: Boolean(raw.readOnly),
        options: options.map((opt) => {
          if (typeof opt === "object" && opt) {
            const value = String(opt.value ?? opt.id ?? opt.label ?? "").trim();
            const label = String(opt.label ?? opt.value ?? opt.id ?? "").trim();
            return { value, label };
          }
          const text = String(opt ?? "").trim();
          return { value: text, label: text };
        }).filter((opt) => opt.value),
        default: raw.default ?? "",
        ui: raw.ui || {},
        _stageName: stageName,
        _stageKey: stageKey,
        _initialValue: value
      };
    }

    function buildConfigFromEditPayload(payload) {
      const stageGroups = Array.isArray(payload?.stageGroups) ? payload.stageGroups : [];
      const allFields = Array.isArray(payload?.allFields) ? payload.allFields : [];
      const list = [];
      editModeStageOrder = [];
      editModeStageMeta = [];

      if (stageGroups.length) {
        const sortedGroups = [...stageGroups].sort((a, b) => Number(a?.stage?.order || 0) - Number(b?.stage?.order || 0));
        sortedGroups.forEach((group, groupIndex) => {
          const stageName = String(group?.stage?.name || "").trim();
          const stageOrder = Number(group?.stage?.order);
          const stageKey = getStageKey(stageName, stageOrder, groupIndex);
          const stageLabel = getStageLabel(stageName, stageOrder, groupIndex);
          const fields = Array.isArray(group?.fields) ? group.fields : [];
          if (!fields.length) return;
          const normalizedFields = [];
          fields.forEach((field, index) => {
            if (isInnerStageType(field?.stageType)) return;
            normalizedFields.push(normalizeEditFieldItem(field, index, stageLabel, stageKey));
          });
          if (!normalizedFields.length) return;
          editModeStageOrder.push(stageKey);
          editModeStageMeta.push({ key: stageKey, name: stageName, order: Number.isFinite(stageOrder) ? stageOrder : null, label: stageLabel });
          normalizedFields.forEach((field) => list.push(field));
        });
      }

      if (allFields.length) {
        const map = new Map(list.map((field) => [field.key, field]));
        allFields.forEach((field, index) => {
          if (isInnerStageType(field?.stageType)) return;
          const normalized = normalizeEditFieldItem(field, index, "Ungrouped", "Ungrouped");
          if (!map.has(normalized.key)) {
            list.push(normalized);
            map.set(normalized.key, normalized);
          } else {
            const existing = map.get(normalized.key);
            if (isEmptyValue(existing?._initialValue) && !isEmptyValue(normalized._initialValue)) {
              existing._initialValue = normalized._initialValue;
            }
          }
        });
      }
      if (!list.length) return null;

      const initialValues = {};
      list.forEach((field) => {
        initialValues[field.key] = field._initialValue;
      });

      return {
        fields: list.map((field) => {
          const next = {
            ...field,
            editStageName: field._stageName || "Ungrouped",
            editStageKey: field._stageKey || "Ungrouped"
          };
          delete next._initialValue;
          return next;
        }),
        currentDateTimeISO: defaultSchema.currentDateTimeISO,
        locale: "tr-TR",
        timezone: "Europe/Istanbul",
        mode: "edit",
        initialValues,
        requiredPolicy: "soft",
        showInlineHelp: false,
        autoFocusFirstInvalid: false
      };
    }

    function hydrateEditHumanDataFromBubble(config) {
      const sourceObj = readCurrentBubbleDataObject() || {};
      const fields = Array.isArray(config?.fields) ? config.fields : [];
      if (!fields.length) return;
      const indexMap = new Map();
      fields.forEach((field) => {
        const aliases = [field.key, field.fieldName, field.label]
          .map((v) => String(v || "").trim())
          .filter(Boolean);
        aliases.forEach((alias) => {
          if (!indexMap.has(alias)) indexMap.set(alias, field.key);
          const lower = alias.toLocaleLowerCase("tr-TR");
          if (!indexMap.has(lower)) indexMap.set(lower, field.key);
        });
      });

      Object.entries(sourceObj).forEach(([rawKey, rawValue]) => {
        const key = String(rawKey || "").trim();
        if (!key) return;
        const direct = indexMap.get(key) || indexMap.get(key.toLocaleLowerCase("tr-TR"));
        if (!direct) return;
        humanData[direct] = rawValue;
        sourceByField[direct] = "human";
      });
    }

    function applyEditModePayloadIfReady() {
      if (!IS_EDITING_MODE) return false;
      const payload = readEditModePayloadSources();
      const hasStage = Array.isArray(payload?.stageGroups) && payload.stageGroups.length > 0;
      const hasAll = Array.isArray(payload?.allFields) && payload.allFields.length > 0;
      if (!hasStage && !hasAll) {
        editModeStablePollCount = 0;
        setEditModeLoading(true, "Edit verileri bekleniyor…");
        return false;
      }

      const signature = buildEditPayloadSignature(payload);
      if (editModePayloadLoaded && signature === lastEditModePayloadSignature) {
        editModeStablePollCount += 1;
        setEditModeLoading(false);
        return true;
      }

      const config = buildConfigFromEditPayload(payload);
      if (!config) {
        editModeStablePollCount = 0;
        setEditModeLoading(true, "Edit verisi çözümlenemedi…");
        return false;
      }

      humanData = { ...(humanData || {}), ...(config.initialValues || {}) };
      hydrateEditHumanDataFromBubble(config);
      Object.keys(config.initialValues || {}).forEach((key) => {
        if (!sourceByField[key]) sourceByField[key] = "human";
      });
      state.config = config;
      columnJson = {
        columns: config.fields.map((field) => ({
          fieldName: field.fieldName || field.key,
          header: field.label,
          type: field.type,
          stageType: field.stageType || "optional",
          required: Boolean(field.required),
          multiple: Boolean(field.allowMultiple),
          ui: field.ui || {}
        })),
        mode: "edit",
        currentDateTimeISO: config.currentDateTimeISO,
        locale: config.locale,
        timezone: config.timezone
      };
      lastEditModePayloadSignature = signature;
      editModePayloadLoaded = true;
      editModeStablePollCount = 0;
      editProcessShowAll = false;
      setEditModeLoading(false);
      renderForm(config);
      flushPendingSubmitAfterConfigReady();
      return true;
    }

    function ensureEditModePayloadPolling() {
      if (!IS_EDITING_MODE) return;
      const startFastPolling = () => {
        if (editModeSlowPollTimer) {
          clearInterval(editModeSlowPollTimer);
          editModeSlowPollTimer = null;
        }
        if (editModePayloadPollTimer) return;
        editModePayloadPollTimer = setInterval(() => {
          applyEditModePayloadIfReady();
          if (editModeStablePollCount >= 8) {
            clearInterval(editModePayloadPollTimer);
            editModePayloadPollTimer = null;
            editModeSlowPollTimer = setInterval(() => {
              const before = lastEditModePayloadSignature;
              const applied = applyEditModePayloadIfReady();
              const changed = before !== lastEditModePayloadSignature;
              if (!applied || changed) {
                if (editModeSlowPollTimer) {
                  clearInterval(editModeSlowPollTimer);
                  editModeSlowPollTimer = null;
                }
                startFastPolling();
              }
            }, 2500);
          }
        }, 300);
      };
      if (editModePayloadPollTimer || editModeSlowPollTimer) return;
      startFastPolling();
    }

    function resolveActiveProcessStageKey(stageMeta) {
      const dataObj = readCurrentBubbleDataObject() || {};
      const rawStage = dataObj.stage;
      if (rawStage === null || rawStage === undefined || rawStage === "") return "";
      const stageText = String(rawStage).trim();
      const stageTextLower = stageText.toLocaleLowerCase("tr-TR");

      const byName = stageMeta.find((item) => String(item.name || "").trim().toLocaleLowerCase("tr-TR") === stageTextLower);
      if (byName) return byName.key;

      const numericValue = Number(rawStage);
      if (Number.isFinite(numericValue)) {
        const byOrder = stageMeta.find((item) => Number(item.order) === numericValue);
        if (byOrder) return byOrder.key;
      }
      return "unknown";
    }

    function getProcessStageStatus(stageIndex, activeIndex) {
      if (activeIndex < 0) return "upcoming";
      if (stageIndex < activeIndex) return "completed";
      if (stageIndex === activeIndex) return "active";
      return "upcoming";
    }

    function getStageDisplayLabel(stageMetaByKey, stageKey, fallbackIndex = 0) {
      if (String(stageKey) === "Ungrouped") return "Unassigned";
      const meta = stageMetaByKey.get(stageKey) || null;
      const label = String(meta?.label || meta?.name || "").trim();
      if (label) return label;
      const order = Number(meta?.order);
      if (Number.isFinite(order)) return `Stage ${order}`;
      return `Stage ${fallbackIndex + 1}`;
    }

    function isQuickEntryEligible(field) {
      const type = String(field?.type || field?.displayType || "").toLocaleLowerCase("tr-TR").trim();
      const blocked = ["file", "image", "multifile", "multiline", "textarea", "text (long)", "dropdown", "checkbox", "radio", "switch", "toggle"];
      if (blocked.some((item) => type.includes(item))) return false;
      return true;
    }

    function fuzzySimilarityScore(haystack, needle) {
      if (!needle) return 0;
      let matches = 0;
      let cursor = 0;
      for (let i = 0; i < haystack.length && cursor < needle.length; i += 1) {
        if (haystack[i] === needle[cursor]) {
          matches += 1;
          cursor += 1;
        }
      }
      if (!matches) return 0;
      return matches / needle.length;
    }

    function quickFieldSearchScore(field, term) {
      if (!term) return 0;
      const id = String(field.key || field.fieldName || "").toLocaleLowerCase("tr-TR");
      const label = String(field.label || "").toLocaleLowerCase("tr-TR");
      const targets = [id, label];
      let best = 0;
      targets.forEach((target) => {
        if (!target) return;
        if (target.startsWith(term)) best = Math.max(best, 300 + (term.length / Math.max(target.length, 1)));
        else if (target.includes(term)) best = Math.max(best, 200 + (term.length / Math.max(target.length, 1)));
        else best = Math.max(best, 100 * fuzzySimilarityScore(target, term));
      });
      return best;
    }

    function renderEditProgress(stageMeta) {
      if (!editProgressWrap || !editProgressTrack) return;
      editProgressTrack.innerHTML = "";
      if (!stageMeta.length) {
        editProgressWrap.style.display = "none";
        return;
      }

      const activeKey = resolveActiveProcessStageKey(stageMeta);
      editProcessActiveStageKey = activeKey;
      if (!activeKey) {
        editProgressWrap.style.display = "none";
        return;
      }

      const activeIndex = stageMeta.findIndex((item) => item.key === activeKey);
      const visibleStages = (editProcessShowAll || activeIndex < 0)
        ? stageMeta
        : stageMeta.slice(0, activeIndex + 1);

      visibleStages.forEach((stage, index) => {
        const realIndex = stageMeta.findIndex((item) => item.key === stage.key);
        const status = getProcessStageStatus(realIndex, activeIndex);
        const step = document.createElement("div");
        step.className = `edit-progress-step ${status}`;
        const dot = document.createElement("span");
        dot.className = "edit-progress-step-dot";
        dot.textContent = status === "completed" ? "✓" : String(realIndex + 1);
        const label = document.createElement("span");
        label.textContent = stage.label;
        step.append(dot, label);
        editProgressTrack.appendChild(step);
        if (index < visibleStages.length - 1) {
          const sep = document.createElement("span");
          sep.className = "edit-progress-sep";
          sep.textContent = "—";
          editProgressTrack.appendChild(sep);
        }
      });

      if (editProgressToggle) {
        if (activeIndex >= 0 && stageMeta.length > activeIndex + 1) {
          editProgressToggle.style.display = "inline-flex";
          editProgressToggle.textContent = editProcessShowAll ? "Daha az göster" : "Tüm süreç";
        } else {
          editProgressToggle.style.display = "none";
        }
      }

      editProgressWrap.style.display = "grid";
    }

    function renderSelectedStageFieldsProgressively({ stageKey, selectedFields, wrappersByKey, retryCount = 0 }) {
      editStageRenderSeq += 1;
      const renderSeq = editStageRenderSeq;
      if (editStageStatus) {
        editStageStatus.textContent = selectedFields.length ? "İçerik yükleniyor…" : "Bu aşamada gösterilecek alan yok.";
      }
      if (editStageFields) {
        editStageFields.innerHTML = selectedFields.length
          ? '<div class="edit-stage-fields-skeleton"><div class="line"></div><div class="line"></div><div class="line"></div></div>'
          : '';
      }
      let cursor = 0;
      const chunkSize = 4;
      const total = selectedFields.length;
      let appended = 0;
      const pump = () => {
        if (renderSeq !== editStageRenderSeq) return;
        if (stageKey !== editSelectedStage) return;
        if (!editStageFields) return;
        if (cursor === 0) editStageFields.innerHTML = "";
        const limit = Math.min(cursor + chunkSize, total);
        for (let i = cursor; i < limit; i += 1) {
          const wrapper = wrappersByKey.get(selectedFields[i].key);
          if (wrapper) {
            editStageFields.appendChild(wrapper);
            appended += 1;
          }
        }
        cursor = limit;
        if (cursor < total) {
          requestAnimationFrame(pump);
          return;
        }
        if (editStageStatus) {
          editStageStatus.textContent = total ? `${appended}/${total} alan listelendi.` : "Bu aşamada gösterilecek alan yok.";
        }
        if (appended < total && retryCount < 3) {
          setTimeout(() => {
            if (stageKey !== editSelectedStage) return;
            renderSelectedStageFieldsProgressively({ stageKey, selectedFields, wrappersByKey, retryCount: retryCount + 1 });
          }, 180);
        }
      };
      requestAnimationFrame(pump);
    }

    function runEditModeFilterRender() {
      if (!IS_EDITING_MODE || !state.config) return;
      const term = String(editModeSearchTerm || "").trim().toLocaleLowerCase("tr-TR");
      const fields = Array.isArray(state.config.fields) ? state.config.fields : [];
      const stageMap = new Map();
      fields.forEach((field) => {
        const stageKey = String(field.editStageKey || "Ungrouped");
        if (!stageMap.has(stageKey)) stageMap.set(stageKey, []);
        stageMap.get(stageKey).push(field);
      });

      const stageLabelByKey = new Map((editModeStageMeta || []).map((stage) => [stage.key, stage]));
      const stageKeys = [];
      if (stageMap.has("Ungrouped")) stageKeys.push("Ungrouped");
      (editModeStageOrder || []).forEach((stageKey) => {
        if (stageKeys.includes(stageKey)) return;
        if (stageMap.has(stageKey)) stageKeys.push(stageKey);
      });
      Array.from(stageMap.keys()).forEach((stageKey) => {
        if (stageKeys.includes(stageKey)) return;
        stageKeys.push(stageKey);
      });

      const filteredCountByStage = new Map();
      stageKeys.forEach((stageKey) => {
        const count = (stageMap.get(stageKey) || []).length;
        filteredCountByStage.set(stageKey, count);
      });

      const firstWithFields = stageKeys.find((stageKey) => (filteredCountByStage.get(stageKey) || 0) > 0);
      if (!editSelectedStage || !stageKeys.includes(editSelectedStage)) {
        editSelectedStage = firstWithFields || stageKeys[0] || "";
      }
      if (editStageLayout) {
        editStageLayout.style.display = stageKeys.length ? "grid" : "none";
      }

      const wrappersByKey = new Map();
      Object.keys(state.fieldRefs || {}).forEach((fieldKey) => {
        const wrapper = state.fieldRefs?.[fieldKey]?.wrapper;
        if (wrapper) wrappersByKey.set(fieldKey, wrapper);
      });
      const wrapperPool = [
        ...Array.from(formEl.querySelectorAll('.field-wrapper')),
        ...(editModeRoot ? Array.from(editModeRoot.querySelectorAll('.field-wrapper')) : [])
      ];
      wrapperPool.forEach((wrapper) => {
        const key = wrapper.dataset.fieldKey || "";
        if (key && !wrappersByKey.has(key)) wrappersByKey.set(key, wrapper);
      });

      if (editQuickFields) editQuickFields.innerHTML = "";
      if (editStageTabs) editStageTabs.innerHTML = "";
      if (editStageHeading) {
        editStageHeading.textContent = getStageDisplayLabel(stageLabelByKey, editSelectedStage, 0);
      }

      const unassignedFields = (stageMap.get("Ungrouped") || []).filter((field) => isQuickEntryEligible(field));
      const quickCandidates = term
        ? unassignedFields
          .map((field, index) => ({ field, index, score: quickFieldSearchScore(field, term) }))
          .filter((item) => item.score > 0)
          .sort((a, b) => (b.score - a.score) || (a.index - b.index))
          .map((item) => item.field)
        : unassignedFields;
      const quickItems = [];
      for (const field of quickCandidates) {
        if (quickItems.some((x) => x.key === field.key)) continue;
        quickItems.push(field);
        if (quickItems.length >= 5) break;
      }

      if (editSearchEmpty) {
        editSearchEmpty.style.display = "none";
        editSearchEmpty.textContent = "";
      }
      if (editQuickFields) {
        if (!quickItems.length) {
          editQuickFields.innerHTML = '<div class="edit-quick-empty">Uygun alan bulunamadı</div>';
        } else {
          editQuickFields.innerHTML = "";
          quickItems.forEach((field) => {
            const wrapper = wrappersByKey.get(field.key);
            if (wrapper) editQuickFields.appendChild(wrapper);
          });
        }
      }

      const activeProcessIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === editProcessActiveStageKey);
      stageKeys.forEach((stageKey, visibleIndex) => {
        const stageMetaIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === stageKey);
        const status = getProcessStageStatus(stageMetaIndex, activeProcessIndex);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `edit-stage-tab ${status}`;
        const count = filteredCountByStage.get(stageKey) || 0;
        btn.textContent = `${getStageDisplayLabel(stageLabelByKey, stageKey, visibleIndex)} (${count})`;
        if (stageKey === editSelectedStage) btn.classList.add('active');
        if (stageKey === editProcessActiveStageKey) btn.dataset.activeProcess = "1";
        btn.addEventListener('click', () => {
          editSelectedStage = stageKey;
          runEditModeFilterRender();
        });
        if (editStageTabs) editStageTabs.appendChild(btn);
      });

      const quickKeys = new Set(quickItems.map((field) => field.key));
      const selectedFields = (stageMap.get(editSelectedStage) || []).filter((field) => {
        if (String(editSelectedStage) !== "Ungrouped") return true;
        return !quickKeys.has(field.key);
      });
      const selectedStageMetaIndex = (editModeStageMeta || []).findIndex((stage) => stage.key === editSelectedStage);
      const activeProcessIndexForSelected = (editModeStageMeta || []).findIndex((stage) => stage.key === editProcessActiveStageKey);
      const selectedStageStatus = getProcessStageStatus(selectedStageMetaIndex, activeProcessIndexForSelected);
      if (editStageChip) {
        editStageChip.className = `edit-stage-chip ${selectedStageStatus}`;
        const statusLabel = selectedStageStatus === "active" ? "Current" : (selectedStageStatus === "completed" ? "Completed" : "Pending");
        editStageChip.textContent = statusLabel;
      }
      renderSelectedStageFieldsProgressively({ stageKey: editSelectedStage, selectedFields, wrappersByKey });

      renderEditProgress(editModeStageMeta || []);
      const activeTab = editStageTabs?.querySelector('[data-active-process="1"]');
      if (activeTab) activeTab.scrollIntoView({ block: 'nearest' });
    }



    function renderForm(config) {
      formEl.innerHTML = "";
      state.values = {};
      state.validMap = {};
      state.errors = {};
      state.touched = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.fieldRefs = {};
      summaryBox.style.display = "none";

      if (IS_EDITING_MODE) {
        if (actionBar) actionBar.style.display = "none";
        if (formEl) formEl.style.display = "none";
      } else {
        if (actionBar) actionBar.style.display = "";
        if (formEl) formEl.style.display = "grid";
      }

      let previousGroup = null;
      config.fields.forEach((field, index) => {

        const wrapper = document.createElement("div");
        wrapper.className = "field-wrapper";
        wrapper.dataset.fieldKey = field.key;

        const normalizedType = String(field.type || "").toLowerCase();
        const fieldLabelLower = String(field.label || field.key || "").toLowerCase();
        const isAmountField = ["integer", "number", "currency", "percent", "duration"].includes(normalizedType)
          || /(tutar|bedel|ücret|ucret|fiyat|amount|price)/i.test(fieldLabelLower);
        const isDateField = ["date", "datetime", "time"].includes(normalizedType)
          || /(tarih|date|saat|time)/i.test(fieldLabelLower);
        const isFileField = ["file", "multifile", "image"].includes(normalizedType);
        const currentGroup = isDateField ? "date" : (isAmountField ? "amount" : "other");
        if (currentGroup === "date" && previousGroup === "amount") {
          wrapper.classList.add("group-break-date");
        }
        previousGroup = currentGroup;

        const row = document.createElement("div");
        row.className = "field-row";
        if (isAmountField) row.classList.add("is-amount-field");
        if (isDateField) row.classList.add("is-date-field");
        if (isFileField) row.classList.add("is-file-field");

        const labelColumn = document.createElement("div");
        labelColumn.className = "field-label";

        const labelTop = document.createElement("div");
        labelTop.className = "label-top";

        const typeMeta = getTypeMeta(field);
        const typeIcon = document.createElement("span");
        typeIcon.className = "type-icon";
        typeIcon.append(renderIcon(typeMeta.iconKey));
        typeIcon.title = typeMeta.label;

        const label = document.createElement("label");
        label.className = "label-text";
        label.htmlFor = `field-${field.key}`;
        label.textContent = field.label;

        labelTop.append(typeIcon, label);

        const labelMeta = document.createElement("div");
        labelMeta.className = "label-meta";

        if (field.required) {
          labelTop.append(createMandatoryBadge());
        }

        const aiBadge = document.createElement("button");
        aiBadge.type = "button";
        aiBadge.className = "ai-badge";
        aiBadge.title = "AI önerisi var. Tıkla: İnsan moduna geç / AI moduna dön";
        aiBadge.innerHTML = `<img src="https://upload.wikimedia.org/wikipedia/commons/0/04/ChatGPT_logo.svg" alt="ChatGPT logo" /><span>ChatGPT</span>`;
        aiBadge.addEventListener("click", () => {
          const currentSource = getActiveSource(field.key);
          const hasAi = !isEmptyValue(aiData[field.key]);
          if (!hasAi) return;
          const nextSource = currentSource === "ai" ? "human" : "ai";
          sourceByField[field.key] = nextSource;
          updateFieldDisplayValue(field.key);
          emit("onPredictedToggle", {
            key: field.key,
            mode: nextSource
          });
        });
        labelMeta.append(aiBadge);

        const applyAiBtn = document.createElement("button");
        applyAiBtn.type = "button";
        applyAiBtn.className = "pill";
        applyAiBtn.textContent = "AI'den doldur";
        applyAiBtn.style.display = "none";
        applyAiBtn.addEventListener("click", () => {
          const aiValue = aiData[field.key];
          if (isEmptyValue(aiValue)) return;
          humanData[field.key] = aiValue;
          sourceByField[field.key] = "human";
          markFieldAsChanged(field.key);
          rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(applyAiBtn);

        const revertAiBtn = document.createElement("button");
        revertAiBtn.type = "button";
        revertAiBtn.className = "pill";
        revertAiBtn.textContent = "AI'ye dön";
        revertAiBtn.style.display = "none";
        revertAiBtn.addEventListener("click", () => {
          if (isEmptyValue(aiData[field.key])) return;
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
        });
        labelMeta.append(revertAiBtn);

        const conflictWrap = document.createElement("div");
        conflictWrap.style.position = "relative";
        const conflictChip = document.createElement("button");
        conflictChip.type = "button";
        conflictChip.className = "conflict-chip";
        conflictChip.textContent = "Çakışma";
        conflictChip.style.display = "none";
        const conflictPopover = document.createElement("div");
        conflictPopover.className = "conflict-popover";
        conflictPopover.innerHTML = `
          <strong>AI vs Human</strong>
          <div><small>Human</small><pre data-conflict-human></pre></div>
          <div><small>AI</small><pre data-conflict-ai></pre></div>
          <div class="conflict-actions">
            <button type="button" class="secondary" data-apply-human>Human uygula</button>
            <button type="button" class="secondary" data-apply-ai>AI uygula</button>
          </div>
        `;
        conflictChip.addEventListener("click", () => {
          conflictPopover.classList.toggle("open");
        });
        const applyHumanBtn = conflictPopover.querySelector("[data-apply-human]");
        const applyAiBtnInPopover = conflictPopover.querySelector("[data-apply-ai]");
        safeOn(applyHumanBtn, "click", () => {
          sourceByField[field.key] = "human";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        safeOn(applyAiBtnInPopover, "click", () => {
          sourceByField[field.key] = "ai";
          updateFieldDisplayValue(field.key);
          conflictPopover.classList.remove("open");
        });
        conflictWrap.append(conflictChip, conflictPopover);
        labelMeta.append(conflictWrap);

        labelColumn.append(labelTop);
        if (labelMeta.childElementCount) {
          labelColumn.append(labelMeta);
        }

        const control = document.createElement("div");
        control.className = "field-control";
        const stageClass = normalizeStageType(field.stageType);
        if (stageClass) {
          control.classList.add(`stage-${stageClass}`);
        }
        const aiPill = document.createElement("span");
        aiPill.className = "ai-pill";
        aiPill.textContent = "AI";
        aiPill.style.display = "none";
        control.append(aiPill);

        let inputEl = null;
        let extraControls = null;
        let inlineActions = null;
        let setValue = null;

        const initialValue = getInitialValue(field, config);
        if (humanData[field.key] === undefined) {
          humanData[field.key] = initialValue;
        }
        if (!sourceByField[field.key]) {
          sourceByField[field.key] = "human";
        }
        if (isEmptyValue(humanData[field.key]) && !isEmptyValue(aiData[field.key])) {
          sourceByField[field.key] = "ai";
        }
        const effectiveInitial = getEffectiveValue(field.key);
        state.values[field.key] = effectiveInitial;
        state.validMap[field.key] = !validateField(field, effectiveInitial);

        if (["text", "email", "phone", "url", "password", "integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
          inputEl = document.createElement("input");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "Empty";
          if (field.type === "password") inputEl.type = "password";
          if (field.type === "email") inputEl.type = "email";
          if (field.type === "url") inputEl.type = "url";
          if (field.type === "phone") inputEl.type = "tel";
          if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) inputEl.inputMode = field.type === "integer" ? "numeric" : "decimal";

          setValue = (value) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const formatted = field.type === "integer"
                ? formatNumberDisplay(value, { maximumFractionDigits: 0 })
                : formatNumberDisplay(value, { maximumFractionDigits: 2 });
              inputEl.value = formatted || (value ?? "");
              return;
            }
            inputEl.value = value ?? "";
          };
          setValue(effectiveInitial);

          inputEl.addEventListener("input", (event) => {
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const raw = event.target.value;
              setFieldValue(field.key, normalizeNumberInput(raw), field, raw);
            } else {
              setFieldValue(field.key, event.target.value, field);
            }
          });

          inputEl.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            let value = event.target.value;
            if (field.type === "email" && value) {
              value = value.toLowerCase();
              event.target.value = value;
            }
            if (field.type === "phone" && value && field.ui?.autoTrPrefix) {
              const digits = value.replace(/\D/g, "");
              if (digits.startsWith("0")) {
                value = `+90${digits.slice(1)}`;
                event.target.value = value;
              }
            }
            if (["integer", "decimal", "currency", "percent", "number"].includes(field.type)) {
              const normalized = normalizeNumberInput(value);
              const formatted = field.type === "integer" ? formatNumberDisplay(normalized, { maximumFractionDigits: 0 }) : formatNumberDisplay(normalized, { maximumFractionDigits: 2 });
              event.target.value = formatted || value;
              setFieldValue(field.key, normalized, field, formatted);
            } else {
              setFieldValue(field.key, value, field);
            }
            updateError(control, field);
          });

        } else if (field.type === "textarea" || field.type === "json") {
          inputEl = document.createElement("textarea");
          inputEl.className = "field-input";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.placeholder = field.placeholder || "Empty";
          inputEl.value = effectiveInitial || "";
          setValue = (value) => {
            inputEl.value = value ?? "";
          };

          inputEl.addEventListener("input", (event) => {
            setFieldValue(field.key, event.target.value, field);
          });
          inputEl.addEventListener("blur", () => {
            updateError(control, field);
          });
        } else if (field.type === "boolean") {
          control.classList.add("toggle");
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = `field-${field.key}`;
          inputEl.setAttribute("aria-describedby", `error-${field.key}`);
          inputEl.setAttribute("aria-label", field.label);
          inputEl.checked = Boolean(effectiveInitial);
          setValue = (value) => {
            inputEl.checked = Boolean(value);
          };
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = "Evet";
          control.append(inputEl, toggleLabel);
          inputEl.addEventListener("change", () => {
            setFieldValue(field.key, inputEl.checked, field);
            updateError(control, field);
          });
        } else if (field.type === "dropdown" && !field.allowMultiple) {
          const select = document.createElement("select");
          select.className = "field-input";
          select.id = `field-${field.key}`;
          select.setAttribute("aria-describedby", `error-${field.key}`);

          const buildOptions = () => {
            select.innerHTML = "";
            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "Empty";
            select.append(emptyOption);
            const groups = {};
            (field.options || []).forEach((opt) => {
              if (opt.group) {
                if (!groups[opt.group]) groups[opt.group] = [];
                groups[opt.group].push(opt);
              } else {
                groups.__default = groups.__default || [];
                groups.__default.push(opt);
              }
            });

            Object.entries(groups).forEach(([groupName, opts]) => {
              if (groupName === "__default") {
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  select.append(option);
                });
              } else {
                const group = document.createElement("optgroup");
                group.label = groupName;
                opts.forEach((opt) => {
                  const option = document.createElement("option");
                  option.value = opt.value;
                  option.textContent = opt.label;
                  if (opt.disabled) option.disabled = true;
                  group.append(option);
                });
                select.append(group);
              }
            });
          };

          buildOptions();
          select.value = effectiveInitial || "";
          setValue = (value) => {
            select.value = value ?? "";
          };

          select.addEventListener("change", () => {
            setFieldValue(field.key, select.value, field);
            updateError(control, field);
          });

          control.append(select);
        } else if (field.type === "dropdown" && field.allowMultiple) {
          const optionsWrapper = document.createElement("div");
          optionsWrapper.className = "grid";

          const chips = document.createElement("div");
          chips.className = "chip-row";

          let selectedValues = Array.isArray(effectiveInitial) ? effectiveInitial : [];

          const renderOptions = () => {
            optionsWrapper.innerHTML = "";
            (field.options || []).forEach((opt) => {
              const optionRow = document.createElement("label");
              optionRow.className = "inline-row";
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.checked = selectedValues.includes(opt.value);
              checkbox.disabled = opt.disabled || false;
              const text = document.createElement("span");
              text.textContent = opt.label;
              optionRow.append(checkbox, text);
              checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                  selectedValues = [...new Set([...selectedValues, opt.value])];
                } else {
                  selectedValues = selectedValues.filter((val) => val !== opt.value);
                }
                renderChips();
                setFieldValue(field.key, selectedValues, field);
                updateError(control, field);
              });
              optionsWrapper.append(optionRow);
            });
          };

          const renderChips = () => {
            chips.innerHTML = "";
            selectedValues.forEach((val) => {
              const opt = (field.options || []).find((o) => o.value === val);
              const chip = document.createElement("span");
              chip.className = "chip";
              chip.textContent = opt ? opt.label : val;
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.textContent = "×";
              removeBtn.addEventListener("click", () => {
                selectedValues = selectedValues.filter((v) => v !== val);
                renderChips();
                renderOptions();
                setFieldValue(field.key, selectedValues, field);
              });
              chip.append(removeBtn);
              chips.append(chip);
            });
          };

          renderOptions();
          renderChips();
          setValue = (value) => {
            selectedValues = Array.isArray(value) ? value : [];
            renderOptions();
            renderChips();
          };
          control.append(chips, optionsWrapper);
          updateEffectiveState(field.key, field);
        } else if (field.type === "date") {
          const dateInput = document.createElement("input");
          dateInput.type = "text";
          dateInput.className = "field-input is-date-input";
          dateInput.id = `field-${field.key}`;
          dateInput.setAttribute("aria-describedby", `error-${field.key}`);
          dateInput.placeholder = field.placeholder || "GG.AA.YYYY";
          dateInput.inputMode = "numeric";
          inputEl = dateInput;

          const normalizedInitial = effectiveInitial ? normalizeDateInput(effectiveInitial, config) : "";
          const initialDisplay = normalizedInitial && isValidDateString(normalizedInitial)
            ? formatDateDisplay(normalizedInitial)
            : (typeof effectiveInitial === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(effectiveInitial) ? effectiveInitial : "");
          dateInput.value = initialDisplay;

          setValue = (value) => {
            const normalized = value ? normalizeDateInput(String(value), config) : "";
            dateInput.value = normalized && isValidDateString(normalized) ? formatDateDisplay(normalized) : "";
          };

          const calendar = buildCalendarPopover(config, {
            initialDate: normalizedInitial && isValidDateString(normalizedInitial) ? normalizedInitial : "",
            onSelect: (dateValue) => {
              const displayValue = formatDateDisplay(dateValue);
              dateInput.value = displayValue;
              setFieldValue(field.key, dateValue, field, displayValue);
              updateError(control, field);
              closePopover();
            },
            onClose: () => {
              dateInput.focus();
            }
          });

          const iconBtn = document.createElement("button");
          iconBtn.type = "button";
          iconBtn.className = "field-icon-button";
          iconBtn.setAttribute("aria-label", "Takvim aç");
          iconBtn.textContent = "📅";

          control.classList.add("has-icon");
          control.append(dateInput, iconBtn, calendar.element);

          const handleOutside = (event) => {
            if (!control.contains(event.target)) {
              closePopover();
            }
          };

          const openPopover = () => {
            calendar.element.classList.add("open");
            document.addEventListener("click", handleOutside);
          };

          const closePopover = () => {
            calendar.element.classList.remove("open");
            document.removeEventListener("click", handleOutside);
          };

          iconBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            if (calendar.element.classList.contains("open")) {
              closePopover();
            } else {
              openPopover();
            }
          });

          const syncDate = (raw) => {
            if (!raw) {
              dateInput.value = "";
              setFieldValue(field.key, "", field, "");
              updateError(control, field);
              calendar.setSelectedDate("");
              return;
            }
            const normalized = normalizeDateInput(raw, config);
            if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
              const displayValue = formatDateDisplay(normalized);
              dateInput.value = displayValue;
              if (isValidDateString(normalized)) {
                setFieldValue(field.key, normalized, field, displayValue);
                calendar.setSelectedDate(normalized);
              } else {
                setFieldValue(field.key, "", field, displayValue);
                calendar.setSelectedDate("");
              }
              updateError(control, field);
              return;
            }
            const masked = formatDateMask(raw);
            dateInput.value = masked;
            const parsed = parseDateDisplay(masked);
            if (parsed && isValidDateString(parsed)) {
              setFieldValue(field.key, parsed, field, masked);
              calendar.setSelectedDate(parsed);
            } else {
              setFieldValue(field.key, "", field, masked);
              calendar.setSelectedDate("");
            }
            updateError(control, field);
          };

          dateInput.addEventListener("input", (event) => syncDate(event.target.value));
          dateInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncDate(event.target.value);
          });
        } else if (field.type === "datetime") {
          const datetimeInput = document.createElement("input");
          datetimeInput.type = "text";
          datetimeInput.className = "field-input is-date-input";
          datetimeInput.id = `field-${field.key}`;
          datetimeInput.setAttribute("aria-describedby", `error-${field.key}`);
          datetimeInput.placeholder = field.placeholder || "GG.AA.YYYY SS:DD";
          datetimeInput.inputMode = "numeric";
          inputEl = datetimeInput;

          const normalizedInitial = effectiveInitial ? normalizeDateTimeInput(effectiveInitial, config) : "";
          const dateValue = normalizedInitial ? getDateFromIso(normalizedInitial) : "";
          const timeValue = normalizedInitial ? getTimeFromIso(normalizedInitial) : "";
          datetimeInput.value = dateValue && timeValue ? formatDateTimeDisplay(normalizedInitial) : "";

          let selectedDate = dateValue;
          let selectedTime = timeValue;

          setValue = (value) => {
            if (!value) {
              datetimeInput.value = "";
              return;
            }
            const normalized = normalizeDateTimeInput(String(value), config);
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
              datetimeInput.value = formatDateTimeDisplay(normalized);
              selectedDate = getDateFromIso(normalized);
              selectedTime = getTimeFromIso(normalized);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
            } else {
              datetimeInput.value = "";
            }
          };

          const calendar = buildCalendarPopover(config, {
            initialDate: selectedDate,
            quickActionLabel: "Şimdi",
            onQuickAction: ({ selectDate }) => {
              const now = getCurrentDateTime(config);
              const nowDate = getDateFromIso(now);
              const nowTime = getTimeFromIso(now);
              selectedDate = nowDate;
              selectedTime = nowTime;
              selectDate(nowDate);
              setTimeSelects(nowTime);
              const displayValue = `${formatDateDisplay(nowDate)} ${nowTime}`;
              datetimeInput.value = displayValue;
              const normalized = normalizeDateTimeInput(`${nowDate}T${nowTime}`, config);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
              closePopover();
            },
            onSelect: (dateValue) => {
              selectedDate = dateValue;
              const nextTime = selectedTime || getTimeFromIso(getCurrentDateTime(config));
              const displayValue = `${formatDateDisplay(dateValue)} ${nextTime}`;
              datetimeInput.value = displayValue;
              const normalized = normalizeDateTimeInput(`${dateValue}T${nextTime}`, config);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
            },
            onClose: () => {
              datetimeInput.focus();
            }
          });

          const timeRow = document.createElement("div");
          timeRow.className = "picker-time";
          const hourSelect = document.createElement("select");
          hourSelect.className = "field-input";
          const minuteSelect = document.createElement("select");
          minuteSelect.className = "field-input";

          const buildTimeOptions = (select, max) => {
            select.innerHTML = "";
            for (let i = 0; i <= max; i += 1) {
              const option = document.createElement("option");
              option.value = String(i).padStart(2, "0");
              option.textContent = option.value;
              select.append(option);
            }
          };

          buildTimeOptions(hourSelect, 23);
          buildTimeOptions(minuteSelect, 59);

          const setTimeSelects = (timeValue) => {
            if (!timeValue || !isValidTimeString(timeValue)) return;
            const [hour, minute] = timeValue.split(":");
            hourSelect.value = hour;
            minuteSelect.value = minute;
          };

          if (selectedTime) {
            setTimeSelects(selectedTime);
          }

          const updateTime = () => {
            selectedTime = `${hourSelect.value}:${minuteSelect.value}`;
            if (!selectedDate) return;
            const displayValue = `${formatDateDisplay(selectedDate)} ${selectedTime}`;
            datetimeInput.value = displayValue;
            const normalized = normalizeDateTimeInput(`${selectedDate}T${selectedTime}`, config);
            setFieldValue(field.key, normalized, field, displayValue);
            updateError(control, field);
          };

          hourSelect.addEventListener("change", updateTime);
          minuteSelect.addEventListener("change", updateTime);

          timeRow.append(hourSelect, minuteSelect);
          calendar.element.insertBefore(timeRow, calendar.element.lastElementChild);

          const iconBtn = document.createElement("button");
          iconBtn.type = "button";
          iconBtn.className = "field-icon-button";
          iconBtn.setAttribute("aria-label", "Takvim ve saat seç");
          iconBtn.textContent = "🗓️";

          control.classList.add("has-icon");
          control.append(datetimeInput, iconBtn, calendar.element);

          const handleOutside = (event) => {
            if (!control.contains(event.target)) {
              closePopover();
            }
          };

          const openPopover = () => {
            calendar.element.classList.add("open");
            document.addEventListener("click", handleOutside);
          };

          const closePopover = () => {
            calendar.element.classList.remove("open");
            document.removeEventListener("click", handleOutside);
          };

          iconBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            if (calendar.element.classList.contains("open")) {
              closePopover();
            } else {
              openPopover();
            }
          });

          const syncDatetime = (raw) => {
            if (!raw) {
              datetimeInput.value = "";
              setFieldValue(field.key, "", field, "");
              updateError(control, field);
              return;
            }
            const normalized = normalizeDateTimeInput(raw, config);
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(normalized)) {
              const displayValue = formatDateTimeDisplay(normalized);
              datetimeInput.value = displayValue;
              selectedDate = getDateFromIso(normalized);
              selectedTime = getTimeFromIso(normalized);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
              setFieldValue(field.key, normalized, field, displayValue);
              updateError(control, field);
              return;
            }
            const masked = formatDateTimeMask(raw);
            datetimeInput.value = masked;
            const parsed = parseDateTimeDisplay(masked, config);
            if (parsed) {
              selectedDate = getDateFromIso(parsed);
              selectedTime = getTimeFromIso(parsed);
              calendar.setSelectedDate(selectedDate);
              setTimeSelects(selectedTime);
              setFieldValue(field.key, parsed, field, masked);
            } else {
              setFieldValue(field.key, "", field, masked);
            }
            updateError(control, field);
          };

          datetimeInput.addEventListener("input", (event) => syncDatetime(event.target.value));
          datetimeInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncDatetime(event.target.value);
          });
        } else if (field.type === "time") {
          const timeInput = document.createElement("input");
          timeInput.type = "text";
          timeInput.className = "field-input";
          timeInput.id = `field-${field.key}`;
          timeInput.setAttribute("aria-describedby", `error-${field.key}`);
          timeInput.placeholder = field.placeholder || "SS:DD";
          timeInput.inputMode = "numeric";
          inputEl = timeInput;

          setValue = (value) => {
            timeInput.value = value ? formatTimeMask(String(value)) : "";
          };
          setValue(effectiveInitial);

          const syncTime = (raw) => {
            const masked = formatTimeMask(raw);
            timeInput.value = masked;
            const parsed = parseTimeDisplay(masked);
            if (parsed && isValidTimeString(parsed)) {
              setFieldValue(field.key, parsed, field, masked);
            } else {
              setFieldValue(field.key, "", field, masked);
            }
            updateError(control, field);
          };

          timeInput.addEventListener("input", (event) => syncTime(event.target.value));
          timeInput.addEventListener("blur", (event) => {
            state.touched[field.key] = true;
            syncTime(event.target.value);
          });

          if (field.ui?.quickActions) {
            const actions = document.createElement("div");
            actions.className = "field-actions";
            const nowBtn = document.createElement("button");
            nowBtn.type = "button";
            nowBtn.className = "ghost";
            nowBtn.textContent = "Şu an";
            nowBtn.addEventListener("click", () => {
              const now = getCurrentDateTime(config);
              const timeValue = getTimeFromIso(now);
              timeInput.value = timeValue;
              setFieldValue(field.key, timeValue, field, timeValue);
              updateError(control, field);
            });
            actions.append(nowBtn);
            inlineActions = actions;
          }
        } else if (field.type === "duration") {
          const durationInput = document.createElement("input");
          durationInput.className = "field-input";
          durationInput.setAttribute("aria-describedby", `error-${field.key}`);
          durationInput.placeholder = "hh:mm";
          durationInput.value = effectiveInitial || "";
          setValue = (value) => {
            durationInput.value = value ?? "";
          };
          durationInput.addEventListener("blur", () => {
            const normalized = normalizeTimeInput(durationInput.value);
            durationInput.value = normalized;
            const [h, m] = normalized.split(":");
            const minutes = (Number(h || 0) * 60) + Number(m || 0);
            if (field.ui?.durationFormat === "iso") {
              setFieldValue(field.key, `PT${Number(h || 0)}H${Number(m || 0)}M`, field, normalized);
            } else {
              setFieldValue(field.key, minutes, field, normalized);
            }
            updateError(control, field);
          });
          durationInput.addEventListener("input", () => {
            setFieldValue(field.key, durationInput.value, field);
          });
          inputEl = durationInput;
        } else if (field.type === "address") {
          const street = document.createElement("input");
          const district = document.createElement("input");
          const city = document.createElement("input");
          const postal = document.createElement("input");
          const country = document.createElement("input");
          [street, district, city, postal, country].forEach((input) => {
            input.className = "field-input";
          });
          street.placeholder = "Sokak / Mahalle";
          district.placeholder = "İlçe";
          city.placeholder = "İl";
          postal.placeholder = "Posta Kodu";
          country.placeholder = "Ülke";
          const grid = document.createElement("div");
          grid.className = "grid two";
          grid.append(street, district, city, postal, country);
          setValue = (value) => {
            const normalized = value && typeof value === "object" ? value : {};
            street.value = normalized.street || "";
            district.value = normalized.district || "";
            city.value = normalized.city || "";
            postal.value = normalized.postalCode || "";
            country.value = normalized.country || "";
          };
          setValue(effectiveInitial);
          const updateAddress = () => {
            const value = {
              street: street.value,
              district: district.value,
              city: city.value,
              postalCode: postal.value,
              country: country.value
            };
            setFieldValue(field.key, value, field);
            updateError(control, field);
          };
          [street, district, city, postal, country].forEach((input) => {
            input.addEventListener("input", updateAddress);
            input.addEventListener("blur", updateAddress);
          });
          inputEl = grid;
        } else if (["file", "multifile", "image"].includes(field.type)) {
          control.classList.add("file-field-control");
          const drop = document.createElement("div");
          drop.className = "file-drop";
          drop.textContent = "Dosya sürükleyin veya seçin";

          const allowMultiple = field.type === "multifile" || field.allowMultiple === true;

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "field-input";
          fileInput.id = `field-${field.key}`;
          fileInput.setAttribute("aria-describedby", `error-${field.key}`);
          const accept = field.ui?.accept || "";
          if (accept) fileInput.accept = accept;
          fileInput.multiple = allowMultiple;

          const list = document.createElement("div");
          list.className = "file-list";

          const renderFiles = () => {
            list.innerHTML = "";
            const files = state.fileBuffers[field.key] || [];
            const isImageGrid = field.type === "image" && (fileInput.multiple || files.length > 1);
            list.className = isImageGrid ? "file-grid" : "file-list";

            files.forEach((file, idx) => {
              const isImage = field.type === "image" || isImageLike(file);
              const row = document.createElement("div");
              row.className = isImageGrid ? "file-card" : "file-item";
              const meta = document.createElement("div");
              meta.className = "file-meta";
              meta.innerHTML = `<strong>${file.name}</strong><span>${Math.round(file.size / 1024)} KB</span>`;

              if (isImage) {
                const thumbWrap = document.createElement("div");
                thumbWrap.className = "file-thumb-wrap";
                const thumb = document.createElement("img");
                thumb.className = isImageGrid ? "file-thumb large" : "file-thumb";
                thumb.src = file.preview || file.url || "";
                thumb.alt = file.name || "görsel";
                const overlay = document.createElement("div");
                overlay.className = "file-thumb-overlay";
                overlay.textContent = "🔍";
                thumbWrap.append(thumb, overlay);
                thumbWrap.addEventListener("click", () => openLightbox(file.preview || file.url || ""));
                if (isImageGrid) {
                  row.append(thumbWrap);
                } else {
                  const left = document.createElement("div");
                  left.className = "inline-row";
                  left.append(thumbWrap, meta);
                  row.append(left);
                }
              } else {
                const left = document.createElement("div");
                left.className = "inline-row";
                const icon = document.createElement("div");
                icon.className = "file-icon";
                icon.textContent = "📄";
                left.append(icon, meta);
                if (file.url && (isPdfDataUrl(file.url) || file.url.startsWith("http"))) {
                  const previewBtn = document.createElement("button");
                  previewBtn.type = "button";
                  previewBtn.className = "preview-btn";
                  previewBtn.textContent = "Önizle";
                  previewBtn.addEventListener("click", () => openFilePreview(file.url));
                  left.append(previewBtn);
                }
                row.append(left);
              }

              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "file-remove";
              removeBtn.textContent = "×";
              removeBtn.addEventListener("click", () => {
                state.fileBuffers[field.key] = files.filter((_, fileIdx) => fileIdx !== idx);
                renderFiles();
                if (file.url) {
                  const currentValue = getEffectiveValue(field.key);
                  const values = Array.isArray(currentValue) ? currentValue : currentValue ? [currentValue] : [];
                  const filtered = values.filter((val) => val !== file.url);
                  if (allowMultiple) {
                    humanData[field.key] = filtered;
                  } else {
                    humanData[field.key] = filtered[0] || "";
                  }
                } else {
                  humanData[field.key] = "";
                }
                const filePayload = (state.fileBuffers[field.key] || []).map((f) => ({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  lastModified: f.lastModified
                }));
                state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((f) => f.raw).filter(Boolean);
                sourceByField[field.key] = "human";
                markFieldAsChanged(field.key);
                rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
                updateEffectiveState(field.key, field);
                updateAiVisuals(field.key);
                emit("onFileSelected", {
                  key: field.key,
                  files: filePayload,
                  rawFiles: (state.fileBuffers[field.key] || []).map((f) => f.raw)
                });
              });

              if (isImageGrid) {
                row.append(meta, removeBtn);
              } else {
                row.append(removeBtn);
              }

              list.append(row);
            });
          };

          const handleFiles = async (fileList) => {
            const files = Array.from(fileList);
            const maxFiles = field.ui?.maxFiles || (allowMultiple ? 10 : 1);
            const maxSizeMB = field.ui?.maxSizeMB || 25;
            const errors = [];
            const accepted = [];

            const matchesAccept = (file) => {
              if (!accept) return true;
              const acceptRules = accept
                .split(",")
                .map((rule) => rule.trim().toLowerCase())
                .filter(Boolean);
              if (!acceptRules.length) return true;
              const fileType = String(file.type || "").toLowerCase();
              const fileName = String(file.name || "").toLowerCase();
              return acceptRules.some((rule) => {
                if (rule === "*/*") return true;
                if (rule.endsWith("/*")) {
                  return fileType.startsWith(rule.slice(0, -1));
                }
                if (rule.startsWith(".")) {
                  return fileName.endsWith(rule);
                }
                return fileType === rule;
              });
            };

            for (const file of files) {
              if (accepted.length >= maxFiles) continue;
              if (file.size > maxSizeMB * 1024 * 1024) {
                errors.push(`${file.name}: Dosya çok büyük.`);
                continue;
              }
              if (!matchesAccept(file)) {
                errors.push(`${file.name}: Tür desteklenmiyor.`);
                continue;
              }

              let processedFile = file;
              try {
                processedFile = await maybeCompressImageFile(file);
              } catch (error) {
                console.warn("image compression skipped", error);
              }

              const shouldPreview = field.type === "image" || processedFile.type.startsWith("image/");
              let base64Data = "";
              try {
                base64Data = stripDataUrlPrefix(await readFileAsDataUrl(processedFile));
              } catch (error) {
                console.warn("base64 read failed", error);
              }
              accepted.push({
                raw: processedFile,
                name: processedFile.name || file.name,
                size: processedFile.size,
                type: processedFile.type || file.type,
                lastModified: processedFile.lastModified || file.lastModified,
                base64: base64Data,
                preview: shouldPreview ? URL.createObjectURL(processedFile) : ""
              });
            }

            if (errors.length) {
              setFieldValue(field.key, "", field);
              state.errors[field.key] = errors.join(" ");
            }

            const currentFiles = Array.isArray(state.fileBuffers[field.key]) ? state.fileBuffers[field.key] : [];
            if (field.type === "multifile" || fileInput.multiple) {
              state.fileBuffers[field.key] = [...currentFiles, ...accepted].slice(0, maxFiles);
            } else {
              state.fileBuffers[field.key] = accepted.slice(0, 1);
            }
            renderFiles();

            const filePayload = (state.fileBuffers[field.key] || []).map((file) => ({
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified
            }));
            state.fileStaging[field.key] = (state.fileBuffers[field.key] || []).map((file) => file.raw).filter(Boolean);
            humanData[field.key] = "";
            sourceByField[field.key] = "human";
            markFieldAsChanged(field.key);
            rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
            updateEffectiveState(field.key, field);
            updateAiVisuals(field.key);
            console.log("Pending file selected", {
              field: field.key,
              files: filePayload
            });
            emit("onFileSelected", {
              key: field.key,
              files: filePayload,
              rawFiles: (state.fileBuffers[field.key] || []).map((file) => file.raw)
            });
          };

          const setDropActive = (active) => {
            drop.style.borderColor = active ? varPrimary() : "";
          };

          const isInteractiveFileActionTarget = (eventTarget) => {
            return Boolean(eventTarget && eventTarget.closest && eventTarget.closest("button, a, input, .file-thumb-wrap"));
          };

          control.addEventListener("dragover", (event) => {
            event.preventDefault();
            setDropActive(true);
          });
          control.addEventListener("dragleave", (event) => {
            if (event.relatedTarget && control.contains(event.relatedTarget)) {
              return;
            }
            setDropActive(false);
          });
          control.addEventListener("drop", (event) => {
            event.preventDefault();
            handleFiles(event.dataTransfer.files);
            setDropActive(false);
          });

          fileInput.addEventListener("change", (event) => {
            handleFiles(event.target.files);
            event.target.value = "";
          });

          control.addEventListener("click", (event) => {
            if (isInteractiveFileActionTarget(event.target)) return;
            fileInput.click();
          });

          control.append(drop, fileInput, list);
          setValue = (value) => {
            const initialFiles = parseInitialFiles(value, allowMultiple, field);
            if (initialFiles.length) {
              state.fileBuffers[field.key] = initialFiles;
            } else if (!state.fileStaging[field.key]?.length) {
              state.fileBuffers[field.key] = [];
            }
            renderFiles();
          };
          setValue(effectiveInitial);
          updateEffectiveState(field.key, field);
        }

        if (inputEl) {
          if (!control.contains(inputEl)) {
            control.append(inputEl);
          }
          if (inlineActions) {
            control.append(inlineActions);
          }
        }

        if (field.helpText && config.showInlineHelp) {
          const help = document.createElement("div");
          help.className = "helper-text";
          help.textContent = field.helpText;
          labelColumn.append(help);
        }

        const errorText = document.createElement("div");
        errorText.className = "error-text";
        errorText.dataset.errorFor = field.key;

        const controlStack = document.createElement("div");
        controlStack.className = "control-stack";
        controlStack.append(control);
        if (extraControls) {
          controlStack.append(extraControls);
        }
        controlStack.append(errorText);

        state.fieldRefs[field.key] = {
          field,
          wrapper,
          control,
          inputEl,
          setValue,
          aiBadge,
          aiPill,
          applyAiBtn,
          revertAiBtn,
          conflictChip,
          conflictPopover
        };
        updateAiVisuals(field.key);

        row.append(labelColumn, controlStack);
        wrapper.append(row);
        formEl.append(wrapper);

        if (index === 0 && config.autoFocusFirstInvalid) {
          setTimeout(() => {
            const focusTarget = wrapper.querySelector("input, textarea, select");
            if (focusTarget) focusTarget.focus();
          }, 0);
        }
      });
      if (IS_EDITING_MODE) {
        runEditModeFilterRender();
      }
      updateToolbarStatus();
      updateSubmitState(config);
      captureInitialSnapshot();
    }

    function varPrimary() {
      return getComputedStyle(document.documentElement).getPropertyValue("--primary");
    }

    function openLightbox(src) {
      if (IS_VERSION_MODE || !src || !lightboxEl || !lightboxImage) return;
      lightboxImage.src = src;
      lightboxEl.classList.add("open");
      lightboxEl.setAttribute("aria-hidden", "false");
    }

    function openFilePreview(url) {
      if (!url) return;
      window.open(url, "_blank", "noopener");
    }

    function closeLightbox() {
      if (!lightboxEl || !lightboxImage) return;
      lightboxEl.classList.remove("open");
      lightboxEl.setAttribute("aria-hidden", "true");
      lightboxImage.src = "";
    }

    function openExportModal(kind = "export") {
      if (IS_VERSION_MODE || !exportModal) return;
      exportModal.classList.add("open");
      exportModal.setAttribute("aria-hidden", "false");
      setExportTab(kind);
    }

    function closeExportModal() {
      if (!exportModal || !exportContent) return;
      exportModal.classList.remove("open");
      exportModal.setAttribute("aria-hidden", "true");
      exportContent.value = "";
    }

    function setExportTab(kind) {
      exportTabs.forEach((tab) => {
        tab.classList.toggle("active", tab.dataset.exportTab === kind);
      });
      if (kind === "human") {
        exportContent.value = JSON.stringify(humanData, null, 2);
        return;
      }
      if (kind === "ai") {
        exportContent.value = JSON.stringify(aiData, null, 2);
        return;
      }
      if (kind === "column") {
        exportContent.value = JSON.stringify(columnJson || {}, null, 2);
        return;
      }
      exportContent.value = JSON.stringify(buildExportJson(), null, 2);
    }

    safeOn("#lightbox", "click", (event) => {
      if (event.target === qs("#lightbox")) {
        closeLightbox();
      }
    });

    safeOn("#lightbox .lightbox-close", "click", closeLightbox);
    safeOn("#closeExport", "click", closeExportModal);
    safeOn("#exportModal", "click", (event) => {
      if (event.target === qs("#exportModal")) {
        closeExportModal();
      }
    });
    exportTabs.forEach((tab) => {
      safeOn(tab, "click", () => {
        setExportTab(tab.dataset.exportTab);
      });
    });

    function updateError(control, field) {
      const errorText = formEl.querySelector(`[data-error-for="${CSS.escape(field.key)}"]`);
      if (!errorText) {
        console.warn("error element missing", { fieldKey: field.key, field });
        return;
      }
      const error = state.errors[field.key] || "";
      errorText.textContent = error;
      if (error) {
        control.classList.add("invalid");
      } else {
        control.classList.remove("invalid");
      }
      updateSubmitState(state.config);
    }

    function updateSubmitState(config) {
      console.info(`[updateSubmitState:start] ${JSON.stringify({ fieldCount: (config.fields || []).length })}`);
      const isValid = (config.fields || []).every((field) => {
        let validationValue = getMergedValidationValue(field);
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(validationValue)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        if (isFieldRequired(field)) {
          const fieldOk = !isEmptyValue(validationValue);
          if (!fieldOk) {
            console.info(`[updateSubmitState:missing] ${JSON.stringify({ fieldKey: field.key, label: field.label })}`);
          }
          return fieldOk;
        }
        return true;
      });
      if (config.requiredPolicy === "strict") {
        submitBtn.disabled = !isValid;
        submitBtn.title = isValid ? "" : "Zorunlu alanları doldurun";
      } else {
        submitBtn.disabled = false;
        submitBtn.title = "";
      }
      console.info(`[updateSubmitState:done] ${JSON.stringify({ isValid, requiredPolicy: config.requiredPolicy })}`);
    }

    function focusFirstInvalid() {
      const firstInvalid = Object.keys(state.validMap).find((key) => !state.validMap[key]);
      if (!firstInvalid) return null;
      const target = qs(`#field-${CSS.escape(firstInvalid)}`) || qs(`[data-field='${firstInvalid}']`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "center" });
        if (target.focus) target.focus();
      }
      return firstInvalid;
    }

    function validateAll() {
      state.config.fields.forEach((field) => {
        let value = getEffectiveValue(field.key);
        if (field.type === "date" && typeof value === "string" && /^\d{2}\.\d{2}\.\d{4}$/.test(value)) {
          value = normalizeDateInput(value, state.config || {});
        }
        if (field.type === "time" && typeof value === "string" && !/^\d{2}:\d{2}$/.test(value)) {
          value = parseTimeDisplay(value) || value;
        }
        state.values[field.key] = value;
        let validationValue = value;
        if (["file", "image", "multifile"].includes(field.type) && isEmptyValue(value)) {
          const stagedFiles = state.fileBuffers[field.key] || [];
          if (stagedFiles.length) {
            validationValue = ["__file_selected__"];
          }
        }
        state.errors[field.key] = validateField(field, validationValue);
        state.validMap[field.key] = !state.errors[field.key];
        const control = qs(`#error-${field.key}`)?.parentElement?.querySelector(".field-control");
        if (control) updateError(control, field);
      });
    }

    function applyAiValuesToHuman({ overwrite }) {
      if (!state.config) return;
      state.config.fields.forEach((field) => {
        const aiValue = aiData[field.key];
        if (isEmptyValue(aiValue)) return;
        if (!overwrite && !isEmptyValue(humanData[field.key])) return;
        humanData[field.key] = aiValue;
        sourceByField[field.key] = "human";
        markFieldAsChanged(field.key);
        rememberChangedFieldValue(field.key, normalizeValueForComparison(field, getEffectiveValue(field.key), state.config));
      });
      refreshAllFields();
    }

    function resetAllStores() {
      humanData = {};
      aiData = {};
      sourceByField = {};
      state.fileBuffers = {};
      state.fileStaging = {};
      state.values = {};
      state.validMap = {};
      state.errors = {};
      taskStartTimestamp = null;
      selectedActionId = "";
      selectedActionName = getDefaultActionLabel();
      triggeredActionUniqueId = "";
      isFormDirty = false;
      isFormSaving = false;
      clearChangedTracking();
      updateActionBarUi();
      if (columnJson) {
        applyColumnJson(columnJson);
      } else {
        columnWarning.style.display = "block";
        formEl.innerHTML = "";
        formContainer.style.display = "none";
      }
    }

    BDF.submit = () => {
      if (!formEl) return;
      formEl.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
    };

    BDF.reset = () => {
      resetAllStores();
    };

    window.BDF_submit = () => {
      if (!formEl) return;
      runSubmitFlow({ autosave: false });
    };

    if (!BDF.__listenersBound) {
      BDF.__listenersBound = true;

      initAutosaveStartWatcher();

      if (actionChevronBtn) {
        actionChevronBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!actionOptions.length) return;
          actionMenu.classList.toggle("open");
        });
      }

      if (actionTriggerBtn) {
        actionTriggerBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!actionOptions.length) {
            selectedActionId = "";
            selectedActionName = getDefaultActionLabel();
            triggerSelectedAction();
            return;
          }
          triggerSelectedAction();
        });
      }

      if (predictedActionBtn) {
        predictedActionBtn.addEventListener("click", (event) => {
          event.preventDefault();
          const actionId = predictedActionBtn.dataset.actionId || "";
          const actionName = predictedActionBtn.dataset.actionName || "";
          if (!actionId) return;
          selectActionAndTrigger({ id: actionId, name: actionName });
        });
      }

      document.addEventListener("click", (event) => {
        if (!actionSplit || !actionMenu) return;
        if (actionSplit.contains(event.target)) return;
        closeActionMenu();
      });


      if (editSearchInput) {
        editSearchInput.addEventListener("input", (event) => {
          const nextTerm = String(event?.target?.value || "");
          if (editModeDebounceTimer) clearTimeout(editModeDebounceTimer);
          editModeDebounceTimer = setTimeout(() => {
            editModeSearchTerm = nextTerm;
            runEditModeFilterRender();
          }, 200);
        });
      }

      if (editProgressToggle) {
        editProgressToggle.addEventListener("click", () => {
          editProcessShowAll = !editProcessShowAll;
          runEditModeFilterRender();
        });
      }

      safeOn("#dynamicForm", "submit", (event) => {
        event.preventDefault();
        runSubmitFlow({ autosave: false });
      });

      safeOn("#submitBtn", "click", () => {
        console.info("submit button clicked");
        const submitOutputsPayload = buildSubmitOutputsPayload();
        renderSubmitOutputs(submitOutputsPayload);
      });

      safeOn("#dynamicForm", "keydown", (event) => {
      if (event.key === "Escape") {
        if (event.target && event.target.blur) event.target.blur();
        return;
      }
      if (event.key !== "Enter") return;
      if (event.target?.tagName === "TEXTAREA") return;
      if (event.target?.type === "button") return;
      event.preventDefault();
      const focusables = Array.from(formEl.querySelectorAll("input, select, textarea")).filter((el) => !el.disabled && el.type !== "hidden");
      const currentIndex = focusables.indexOf(event.target);
      const next = focusables[currentIndex + 1];
      if (next) {
        next.focus();
      } else {
        submitBtn.click();
      }
      });

      safeOn("#clearBtn", "click", () => {
        emit("onClear", {});
        resetAllStores();
      });

      ["#columnJsonInput", "#humanJsonInput", "#predictedJsonInput"].forEach((selector) => {
        safeOn(selector, "input", () => {
          syncManualJsonInputs();
        });
      });

      safeOn("#loadHumanJson", "click", () => {
        syncManualJsonInputs();
        initialSnapshot = null;
        if (state.config) {
          initialSnapshot = buildBaselineSnapshot(MANUAL_DATA_JSON);
        }
        const payload = MANUAL_DATA_JSON || SAMPLE_DATA_JSON;
        if (!payload) {
          humanData = {};
          refreshAllFields();
          updateActionBarUi();
          return;
        }
        emit("debug:human-json", payload);
        loadJsonSafeToForm("human", payload);
        clearChangedTracking();
        isFormDirty = computeDirtyState();
        updateActionBarUi();
        openExportModal("human");
      });

      safeOn("#loadPredictedJson", "click", () => {
      syncManualJsonInputs();
      const payload = MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON;
      if (!payload) {
        aiData = {};
        initializeSourceByFieldFromAi();
        refreshAllFields();
        return;
      }
      emit("debug:predicted-json", payload);
      loadJsonSafeToForm("ai", payload);
      updateActionBarUi();
      initializeSourceByFieldFromAi();
      refreshAllFields();
      openExportModal("ai");
      });

      safeOn("#loadColumnJson", "click", () => {
      syncManualJsonInputs();
      columnJson = MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON;
      applyColumnJson(columnJson);
      emit("debug:column-json", columnJson);
      openExportModal("column");
      });

      safeOn("#applyAiToEmpty", "click", () => {
        applyAiValuesToHuman({ overwrite: false });
      });

      safeOn("#overwriteAiToAll", "click", () => {
        const confirmed = window.confirm("AI tüm alanları overwrite edecek. Devam edilsin mi?");
        if (!confirmed) return;
        applyAiValuesToHuman({ overwrite: true });
      });

      safeOn("#resetStores", "click", () => {
        resetAllStores();
      });

      safeOn("#exportJson", "click", () => {
        openExportModal("export");
      });

      if (scenarioColumnOnlyBtn) {
        safeOn("#scenarioColumnOnly", "click", () => {
          applyScenario({
            name: "column-only",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON
          });
        });
      }

      if (scenarioColumnHumanBtn) {
        safeOn("#scenarioColumnHuman", "click", () => {
          applyScenario({
            name: "column-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON
          });
        });
      }

      if (scenarioColumnAiBtn) {
        safeOn("#scenarioColumnAi", "click", () => {
          applyScenario({
            name: "column-ai",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioColumnAiHumanBtn) {
        safeOn("#scenarioColumnAiHuman", "click", () => {
          applyScenario({
            name: "column-ai-human",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: MANUAL_DATA_JSON || SAMPLE_DATA_JSON,
            ai: MANUAL_PREDICTED_JSON || SAMPLE_PREDICTED_JSON
          });
        });
      }

      if (scenarioConflictBtn) {
        safeOn("#scenarioConflict", "click", () => {
          applyScenario({
            name: "conflict",
            column: MANUAL_COLUMN_JSON || SAMPLE_COLUMN_JSON,
            human: {
              "Kusur Oranı": "40",
              "Hasar Onarım Tutarı": "120000"
            },
            ai: {
              "Kusur Oranı": "80",
              "Hasar Onarım Tutarı": "145000"
            }
          });
        });
      }

    }

    if (currentDateTimeInput) currentDateTimeInput.value = defaultSchema.currentDateTimeISO;
    if (schemaInput) schemaInput.value = JSON.stringify(defaultSchema, null, 2);
    syncManualJsonInputs();
    if (MANUAL_COLUMN_JSON) {
      columnJson = MANUAL_COLUMN_JSON;
    }
    applyVersionVisibility();
    syncActionOptions();
    initLateIncomingDataSync();
    if (IS_EDITING_MODE) {
      const payloadAppliedNow = applyEditModePayloadIfReady();
      if (!payloadAppliedNow) {
        formContainer.style.display = "block";
        if (formEl) formEl.innerHTML = "";
      }
      ensureEditModePayloadPolling();
    } else if (columnJson) {
      applyColumnJson(columnJson);
      setTimeout(() => {
        if (MANUAL_DATA_JSON) {
          loadJsonSafeToForm("human", MANUAL_DATA_JSON);
        }
        if (MANUAL_PREDICTED_JSON) {
          loadJsonSafeToForm("ai", MANUAL_PREDICTED_JSON);
          initializeSourceByFieldFromAi();
          refreshAllFields();
        }
      }, 0);
    } else {
      formEl.innerHTML = "";
      formContainer.style.display = "none";
    }
    })();
  </script>
</body>
</html>
