<!-- BUBBLE DATA CONFIGURATION - Bubble'dan dinamik doldurulacak -->
<script type="application/json" id="gaia-last-response">
{{last_response_json}}
</script>
<!-- Optional workspace context (Bubble'dan doldur) -->
<script type="application/json" id="gaia-context">
{{gaia_workspace_context}}
</script>

<!-- BUBBLE DATA CONFIGURATION END -->

<div class="gaia-shell">
  <div id="gaia-launcher" class="gaia-launcher" aria-expanded="false">
    <div id="gaia-launcher-bubble" class="gaia-launcher-bubble" role="button" tabindex="0" aria-label="Open assistant">
      <button id="gaia-launcher-minimize" class="gaia-launcher-minimize" type="button" aria-label="Minimize greeting">×</button>
      <div id="gaia-launcher-preview" class="gaia-launcher-preview">I can scope your automation—want me to draft it?</div>
    </div>
    <button id="gaia-launcher-button" class="gaia-launcher-button" type="button" aria-label="Open chat">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M4 6.75C4 5.23 5.23 4 6.75 4h10.5C18.77 4 20 5.23 20 6.75v6.5c0 1.52-1.23 2.75-2.75 2.75H9.5l-3.7 3.7a.75.75 0 0 1-1.28-.53V16.5c-1.3-.35-2.25-1.53-2.25-2.97v-6.78Z"/>
      </svg>
      <span id="gaia-launcher-unread" class="gaia-launcher-unread">New</span>
    </button>
  </div>

  <div id="gaia-chat-wrapper" class="gaia-chat-wrapper is-hidden">
    <div class="gaia-chat-container">
      <div class="gaia-chat-header">
        <div>
          <div class="gaia-chat-title">Gaia Assistant</div>
          <div class="gaia-chat-subtitle">Automation design copilot</div>
        </div>
      <div class="gaia-chat-actions">
          <button id="gaia-reset" class="gaia-icon-btn" type="button" aria-label="Reset chat" title="Reset chat">⟲</button>
          <button id="gaia-close" class="gaia-icon-btn" type="button" aria-label="Minimize assistant" title="Minimize assistant">×</button>
        </div>
      </div>

      <div id="gaia-chat-messages" class="gaia-chat-messages"></div>

      <div class="gaia-chat-input-row">
        <div class="gaia-chat-input-wrap">
          <span class="gaia-chat-input-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M6.75 4h10.5C18.77 4 20 5.23 20 6.75v6.5C20 14.77 18.77 16 17.25 16H9.5l-3.7 3.7a.75.75 0 0 1-1.28-.53V16.5C3.2 16.15 2.25 14.97 2.25 13.53v-6.78C2.25 5.23 3.48 4 5 4h1.75Z"/>
            </svg>
          </span>
          <textarea id="gaia-chat-input" class="gaia-chat-input" rows="1" placeholder="Type your message..."></textarea>
          <button id="gaia-chat-send" class="gaia-chat-input-action" type="button" aria-label="Send message" title="Send message">
            <span class="gaia-chat-input-icon gaia-chat-input-icon--right" aria-hidden="true">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3.4 20.2a.8.8 0 0 1-1.1-.9L4.1 12 2.3 4.7a.8.8 0 0 1 1.1-.9l17.5 7.3a.8.8 0 0 1 0 1.5L3.4 20.2Zm2.2-9 1.2 4.8 10.3-4.3-10.3-4.3-1.2 4.8Z"/>
              </svg>
            </span>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
.gaia-shell {
  position: fixed;
  right: 24px;
  bottom: 24px;
  width: auto;
  max-width: calc(100vw - 32px);
  max-height: calc(100vh - 32px);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  pointer-events: none;
}

.gaia-launcher {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
  color: #0f172a;
  user-select: none;
  pointer-events: auto;
}

.gaia-launcher.is-hidden {
  display: none;
}

.gaia-launcher.only-icon .gaia-launcher-bubble {
  display: none;
}

.gaia-launcher-preview {
  font-size: 12px;
  color: #0f172a;
  line-height: 1.4;
}

.gaia-launcher.is-typing .gaia-launcher-preview::after {
  content: " •••";
  letter-spacing: 2px;
  opacity: 0.7;
  animation: gaia-launcher-typing 1.2s infinite;
}

@keyframes gaia-launcher-typing {
  0%,
  100% {
    opacity: 0.35;
  }
  50% {
    opacity: 0.9;
  }
}

.gaia-launcher-unread {
  font-size: 11px;
  font-weight: 800;
  padding: 4px 8px;
  border-radius: 999px;
  background: #16a34a;
  color: #ffffff;
  box-shadow: 0 8px 18px rgba(22, 163, 74, 0.25);
  display: none;
  position: absolute;
  top: -6px;
  right: -6px;
}

.gaia-launcher.has-unread .gaia-launcher-unread {
  display: inline-block;
}

.gaia-launcher-button {
  position: relative;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: none;
  background: linear-gradient(135deg, #2563eb, #4f46e5);
  color: #ffffff;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 14px 28px rgba(79, 70, 229, 0.3);
  transition: transform 0.12s ease, box-shadow 0.2s ease, filter 0.2s ease;
}

.gaia-launcher-button svg {
  width: 22px;
  height: 22px;
  fill: currentColor;
}

.gaia-launcher-button:hover {
  filter: brightness(1.03);
  box-shadow: 0 16px 32px rgba(79, 70, 229, 0.35);
}

.gaia-launcher-button:active {
  transform: translateY(1px);
}

.gaia-launcher-bubble {
  position: relative;
  max-width: 360px;
  padding: 14px 16px 12px 16px;
  border-radius: 14px;
  border: 1px solid rgba(148, 163, 184, 0.6);
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(6px);
  box-shadow: 0 16px 30px rgba(15, 23, 42, 0.12);
  cursor: pointer;
}

.gaia-launcher-minimize {
  position: absolute;
  top: -12px;
  right: -12px;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: none;
  background: #ffffff;
  color: #0f172a;
  font-size: 14px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 8px 16px rgba(15, 23, 42, 0.2);
}

.gaia-launcher-minimize:hover {
  background: #f1f5f9;
}

.gaia-chat-wrapper {
  margin-top: 12px;
  pointer-events: auto;
}

.gaia-chat-wrapper.is-hidden {
  display: none;
}

.gaia-chat-container {
  box-sizing: border-box;
  width: 100%;
  max-width: 680px;
  height: min(580px, calc(100vh - 120px));
  margin: 0;
  padding: 16px 16px 12px;
  background: radial-gradient(circle at 15% 15%, rgba(37, 99, 235, 0.08), transparent 40%),
              radial-gradient(circle at 85% 10%, rgba(99, 102, 241, 0.06), transparent 35%),
              #f8fafc;
  border-radius: 20px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 20px 50px rgba(15, 23, 42, 0.12);
  backdrop-filter: blur(6px);
  font-family: "Inter", "SF Pro Text", system-ui, -apple-system, sans-serif;
  color: #0f172a;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow: hidden;
}

.gaia-chat-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding-bottom: 8px;
  border-bottom: 1px solid #e2e8f0;
}

.gaia-chat-actions {
  display: flex;
  gap: 8px;
  align-items: center;
}

.gaia-icon-btn {
  border: none;
  background: #f1f5f9;
  color: #0f172a;
  border-radius: 10px;
  width: 36px;
  height: 36px;
  font-size: 18px;
  line-height: 1;
  cursor: pointer;
  transition: background 0.2s ease, transform 0.12s ease, box-shadow 0.2s ease;
  box-shadow: 0 10px 20px rgba(15, 23, 42, 0.12);
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.gaia-icon-btn svg {
  width: 22px;
  height: 22px;
  fill: currentColor;
}

.gaia-icon-btn:hover {
  background: #e2e8f0;
}

.gaia-icon-btn:active {
  transform: translateY(1px);
  box-shadow: 0 6px 12px rgba(15, 23, 42, 0.12);
}

.gaia-chat-title {
  font-size: 16px;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: 0.2px;
}

.gaia-chat-subtitle {
  font-size: 12px;
  color: #64748b;
  margin-top: 4px;
}

.gaia-chat-messages {
  flex: 1;
  min-height: 240px;
  max-height: 100%;
  padding: 10px 6px 22px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
  scroll-padding-bottom: 22px;
}

.gaia-chat-message {
  max-width: 84%;
  padding: 11px 13px;
  border-radius: 16px;
  font-size: 13px;
  line-height: 1.55;
  white-space: pre-wrap;
  word-break: break-word;
  box-shadow: 0 8px 22px rgba(15, 23, 42, 0.08);
}

.gaia-chat-message.user {
  align-self: flex-end;
  background: linear-gradient(135deg, #2563eb, #4f46e5);
  color: #f8fafc;
  border-bottom-right-radius: 6px;
}

.gaia-chat-message.assistant {
  align-self: flex-start;
  background: #ffffff;
  color: #0f172a;
  border: 1px solid #e2e8f0;
  border-bottom-left-radius: 6px;
}

.gaia-chat-message.loading {
  opacity: 0.78;
  position: relative;
  display: inline-flex;
  align-items: center;
  min-height: 22px;
  animation: gaia-loading-pulse 1.3s ease-in-out infinite;
}

@keyframes gaia-loading-pulse {
  0% {
    opacity: 0.55;
    box-shadow: 0 8px 18px rgba(99, 102, 241, 0.18);
  }
  50% {
    opacity: 1;
    box-shadow: 0 12px 28px rgba(99, 102, 241, 0.28);
  }
  100% {
    opacity: 0.55;
    box-shadow: 0 8px 18px rgba(99, 102, 241, 0.18);
  }
}

.gaia-chat-input-row {
  display: flex;
  align-items: center;
  margin: 0 -16px -12px;
  padding: 10px 16px 16px;
  border: none;
  border-top: 1px solid #e2e8f0;
  border-radius: 0;
  background: #f8fafc;
  box-shadow: none;
}

.gaia-chat-input-wrap {
  position: relative;
  width: 100%;
}

.gaia-chat-input-icon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: #94a3b8;
  pointer-events: none;
}

.gaia-chat-input-icon svg {
  width: 18px;
  height: 18px;
  fill: currentColor;
}

.gaia-chat-input-icon--right {
  left: auto;
  right: 12px;
}

.gaia-chat-input {
  flex: 1;
  width: 100%;
  resize: none;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
  padding: 11px 44px 11px 40px;
  font-size: 13px;
  line-height: 1.4;
  min-height: 44px;
  outline: none;
  max-height: 110px;
  background: #ffffff;
  color: #0f172a;
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

.gaia-chat-input::placeholder {
  color: #94a3b8;
}

.gaia-chat-input:focus {
  border-color: #2563eb;
  box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.2), 0 10px 30px rgba(37, 99, 235, 0.12);
  background: #ffffff;
}

.gaia-chat-input-action {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border: none;
  background: transparent;
  color: #2563eb;
  width: 44px;
  height: 44px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  box-shadow: none;
  transition: transform 0.12s ease, color 0.2s ease, background 0.2s ease;
}

.gaia-chat-input-action svg {
  display: block;
}

.gaia-chat-input-action:hover {
  color: #1d4ed8;
  background: rgba(37, 99, 235, 0.08);
}

.gaia-chat-input-action:active {
  transform: translateY(calc(-50% + 1px));
}

.gaia-chat-input-action:disabled {
  cursor: not-allowed;
  filter: grayscale(0.3);
  opacity: 0.6;
}
</style>

<!-- Markdown + Sanitization + LaTeX -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.3/dist/purify.min.js"></script>
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<script>
(function () {
  // Global state (sayfa yenilenene kadar korunur)
  const state = window.__GAIA_CHAT_STATE__ || {
    messages: [],        // {id?, role: 'user'|'assistant', text, status?}
    lastResponseId: null, // Son assistant cevabının id'si
    isOpen: false,
    draft: '',
    awaitingResponse: false,
    launcherCollapsed: false,
    greetingNotified: false,
    forceGreetingOnLoad: false
  };
  window.__GAIA_CHAT_STATE__ = state;
  const STORAGE_KEY = 'gaia_chat_state_v1';
  const LAST_RESPONSE_KEY = 'gaia_last_response_id_v1';

  const messagesEl = document.getElementById('gaia-chat-messages');
  const inputEl = document.getElementById('gaia-chat-input');
  const sendBtn = document.getElementById('gaia-chat-send');
  const lastResponseEl = document.getElementById('gaia-last-response');
  const wrapperEl = document.getElementById('gaia-chat-wrapper');
  const launcherEl = document.getElementById('gaia-launcher');
  const closeEl = document.getElementById('gaia-close');
  const resetEl = document.getElementById('gaia-reset');
  const launcherPreviewEl = document.getElementById('gaia-launcher-preview');
  const launcherUnreadEl = document.getElementById('gaia-launcher-unread');
  const launcherButtonEl = document.getElementById('gaia-launcher-button');
  const launcherBubbleEl = document.getElementById('gaia-launcher-bubble');
  const launcherMinimizeEl = document.getElementById('gaia-launcher-minimize');
  const pendingTool = { item: null, timer: null, key: null };
  const processedToolCallKeys = new Set();
  const processedResponseIds = new Set();
  // STREAMING KAPALI TUT (tek seferde tam yanıt için)
  // Eğer Responses API çağrısında stream kullanıyorsan argümanlar chunk chunk gelir.

  function loadPersistedState() {
    try {
      const raw = window.sessionStorage ? sessionStorage.getItem(STORAGE_KEY) : null;
      if (!raw) return;
      const saved = JSON.parse(raw);
      if (saved && Array.isArray(saved.messages) && saved.messages.length && (!state.messages || state.messages.length === 0)) {
        state.messages = saved.messages;
      }
      if (typeof saved.lastResponseId === 'string') {
        state.lastResponseId = saved.lastResponseId;
      }
      if (typeof saved.isOpen === 'boolean') {
        state.isOpen = saved.isOpen;
      }
      if (typeof saved.draft === 'string') {
        state.draft = saved.draft;
      }
      if (typeof saved.awaitingResponse === 'boolean') {
        state.awaitingResponse = saved.awaitingResponse;
      }
      if (typeof saved.launcherCollapsed === 'boolean') {
        state.launcherCollapsed = saved.launcherCollapsed;
      }
      if (typeof saved.greetingNotified === 'boolean') {
        state.greetingNotified = saved.greetingNotified;
      }
    } catch (e) {}

    try {
      const storedLastResponse = window.localStorage ? localStorage.getItem(LAST_RESPONSE_KEY) : null;
      if (storedLastResponse) {
        state.lastResponseId = storedLastResponse;
      }
    } catch (e) {}
  }

  function normalizeLoadedMessages() {
    if (!Array.isArray(state.messages)) return;
    state.messages.forEach(msg => {
      if (!msg || !msg.id) return;
      if (msg.role === 'assistant') {
        processedResponseIds.add(msg.id);
        if (msg.fullText && msg.status !== 'loading') {
          msg.text = msg.fullText;
        }
      }
    });
  }

  function persistState() {
    if (!window.sessionStorage) return;
    const safeMessages = Array.isArray(state.messages)
      ? state.messages.map(msg => ({
          id: msg.id,
          role: msg.role,
          text: msg.text,
          fullText: msg.fullText,
          status: msg.status
        }))
      : [];
    try {
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify({
        messages: safeMessages,
        lastResponseId: state.lastResponseId || '',
        isOpen: state.isOpen,
        draft: state.draft || '',
        awaitingResponse: !!state.awaitingResponse,
        launcherCollapsed: !!state.launcherCollapsed,
        greetingNotified: !!state.greetingNotified
      }));
    } catch (e) {}

    try {
      if (window.localStorage) {
        if (state.lastResponseId) {
          localStorage.setItem(LAST_RESPONSE_KEY, state.lastResponseId);
        } else {
          localStorage.removeItem(LAST_RESPONSE_KEY);
        }
      }
    } catch (e) {}
  }

  function readLastResponseId() {
    if (!lastResponseEl) return '';
    const raw = (lastResponseEl.textContent || '').trim();
    if (!raw) return '';
    try {
      const data = JSON.parse(raw);
      return data && data.id ? data.id : '';
    } catch (e) {
      return '';
    }
  }

  function syncHistoryWithLastResponse() {
    const currentId = readLastResponseId();
    if (!currentId) {
      if (!state.messages || state.messages.length === 0) {
        state.messages = [];
        if (window.sessionStorage) {
          try { sessionStorage.removeItem(STORAGE_KEY); } catch (e) {}
        }
      }
      state.lastResponseId = null;
      state.awaitingResponse = false;
      if (window.localStorage) {
        try { localStorage.removeItem(LAST_RESPONSE_KEY); } catch (e) {}
      }
      return;
    }
    state.lastResponseId = currentId;
  }

  function renderMarkdown(md) {
    if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') return md || '';
    const compact = (md || '').replace(/\n{3,}/g, '\n\n');
    const html = marked.parse(compact);
    return DOMPurify.sanitize(html);
  }

  function setPreviewText(text) {
    if (launcherPreviewEl && text) {
      launcherPreviewEl.textContent = text;
    }
  }

  function setLauncherTyping(isTyping) {
    if (!launcherEl) return;
    launcherEl.classList.toggle('is-typing', !!isTyping);
  }

  function setLauncherCollapsed(collapsed) {
    state.launcherCollapsed = !!collapsed;
    if (launcherEl) {
      launcherEl.classList.toggle('only-icon', state.launcherCollapsed);
    }
    persistState();
  }

  function playNotification() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const freqs = [660, 880];
      freqs.forEach((f, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = f;
        osc.type = 'triangle';
        gain.gain.setValueAtTime(0.06, ctx.currentTime + 0.08 * i);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08 * (i + 1));
        osc.connect(gain).connect(ctx.destination);
        osc.start(ctx.currentTime + 0.08 * i);
        osc.stop(ctx.currentTime + 0.08 * (i + 1));
      });
    } catch (e) {}
  }

  function openChat() {
    if (wrapperEl) wrapperEl.classList.remove('is-hidden');
    if (launcherEl) {
      launcherEl.classList.add('is-hidden');
      launcherEl.setAttribute('aria-expanded', 'true');
      launcherEl.classList.remove('has-unread');
    }
    if (launcherUnreadEl) launcherUnreadEl.style.display = 'none';
    state.isOpen = true;
    if (inputEl) {
      inputEl.focus({ preventScroll: true });
    }
    persistState();
  }

  function closeChat() {
    if (wrapperEl) wrapperEl.classList.add('is-hidden');
    if (launcherEl) {
      launcherEl.classList.remove('is-hidden');
      launcherEl.setAttribute('aria-expanded', 'false');
    }
    if (launcherUnreadEl) launcherUnreadEl.style.display = '';
    state.isOpen = false;
    setLauncherCollapsed(true);
    persistState();
  }

  // Mesajları ekrana bas
  function ensureInitialMessage() {
    if (!state.messages || state.messages.length === 0) {
      const greetingText = 'Hi! I can clarify your automation. Tell me what you want in one sentence.';
      state.messages.push({
        id: `assistant_intro_${Date.now()}`,
        role: 'assistant',
        text: greetingText,
        fullText: greetingText,
        status: 'completed'
      });
      setPreviewText(greetingText);
      setLauncherCollapsed(false);
      if (!state.greetingNotified) {
        playNotification();
        state.greetingNotified = true;
      }
    }
  }

  function renderMessages() {
    ensureInitialMessage();
    if (!messagesEl) return;
    const previousScrollTop = messagesEl.scrollTop;
    const previousScrollHeight = messagesEl.scrollHeight;
    const previousClientHeight = messagesEl.clientHeight;
    const distanceFromBottom = previousScrollHeight - (previousScrollTop + previousClientHeight);
    const shouldAutoScroll = distanceFromBottom <= 24;

    messagesEl.innerHTML = '';

    state.messages.forEach(function (msg) {
      const div = document.createElement('div');
      const baseClass = msg.role === 'user' ? 'user' : 'assistant';
      const loadingClass = msg.status === 'loading' ? ' loading' : '';
      div.className = 'gaia-chat-message ' + baseClass + loadingClass;
      div.innerHTML = renderMarkdown(msg.text || '');
      messagesEl.appendChild(div);
    });

    if (shouldAutoScroll) {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    } else {
      const newScrollHeight = messagesEl.scrollHeight;
      const heightDelta = newScrollHeight - previousScrollHeight;
      messagesEl.scrollTop = previousScrollTop + heightDelta;
    }

    // LaTeX render
    if (window.MathJax && typeof MathJax.typesetPromise === 'function') {
      MathJax.typesetPromise();
    }
    persistState();
  }

  function updateSendState() {
    if (!sendBtn || !inputEl) return;
    const hasText = !!inputEl.value.trim();
    const isDisabled = !hasText || !!state.awaitingResponse;
    sendBtn.disabled = isDisabled;
  }

  // Assistant mesajı için sahte "typing" efekti
  function startTypingAnimation(message) {
    if (!message) return;
    const full = message.fullText || '';

    // Çok kısa metinler için animasyon yerine direkt yaz
    if (full.length <= 40) {
      message.text = full;
      renderMessages();
      return;
    }

    message.text = '';
    message.typingIndex = 0;
    if (message.typingTimer) {
      clearInterval(message.typingTimer);
    }

    // Daha yavaş okuma hızı (yaklaşık 180-220 wpm eşleniği)
    const step = Math.max(1, Math.floor(full.length / 140));
    message.typingTimer = setInterval(function () {
      message.typingIndex += step;
      if (message.typingIndex >= full.length) {
        message.text = full;
        clearInterval(message.typingTimer);
        message.typingTimer = null;
        renderMessages();
        return;
      }
      message.text = full.slice(0, message.typingIndex);
      renderMessages();
    }, 45);
  }

  // Son assistant cevabını Bubble'dan al ve mesaja ekle, varsa tool çağrısını Bubble'a ilet
  function ingestLastResponse() {
    if (!lastResponseEl) return;
    const raw = (lastResponseEl.textContent || '').trim();
    if (!raw) return;

    let data = null;
    try {
      data = JSON.parse(raw);
    } catch (e) {
      console.error('gaia: failed to parse last response', e);
      return;
    }
    if (!data || !data.id) return;

    if (processedResponseIds.has(data.id)) {
      console.log('gaia: response already processed, skipping', data.id);
      return;
    }
    processedResponseIds.add(data.id);
    console.log('gaia: ingesting response', data.id);

    // OpenAI Responses API 2024-11 output format:
    // data.output: [{ type: 'message', content: [...] }, {type:'reasoning',...}]
    // Eski format: data.content: [...]
    const messageBlock =
      (Array.isArray(data.output)
        ? data.output.find(b => b && b.type === 'message')
        : null) || null;
    const contentArr = Array.isArray(data.content)
      ? data.content
      : Array.isArray(messageBlock?.content)
        ? messageBlock.content
        : [];
    const firstBlock = contentArr[0] || {};

    // content elemanı iki şekilde gelebilir:
    // 1) { "type": "...", "text": "..." }  → klasik metin formatı
    // 2) { "answer": "..." }               → JSON schema çıktısının kendisi
    let text = '';
    if (typeof firstBlock.text === 'string') {
      text = firstBlock.text;
    } else if (typeof firstBlock.answer === 'string') {
      text = firstBlock.answer;
    } else if (typeof firstBlock === 'string') {
      text = firstBlock;
    }

    // Bekleme balonunu (loading) kaldır
    const loadingIndex = state.messages.findIndex(m => m.status === 'loading' && m.role === 'assistant');
    if (loadingIndex !== -1) {
      state.messages.splice(loadingIndex, 1);
    }
    state.awaitingResponse = false;

    const existing = state.messages.find(m => m.id === data.id);
    let targetMessage = existing;
    const fullText = text || '';
    if (!fullText) {
      renderMessages();
    } else {
      if (targetMessage) {
        targetMessage.fullText = fullText;
        targetMessage.role = data.role || targetMessage.role || 'assistant';
        targetMessage.status = data.status || targetMessage.status || '';
      } else {
        targetMessage = {
          id: data.id,
          role: data.role || 'assistant',
          text: '',
          fullText: fullText,
          status: data.status || 'completed'
        };
        state.messages.push(targetMessage);
      }
      state.lastResponseId = data.id;

      if (typeof startTypingAnimation === 'function') {
        startTypingAnimation(targetMessage);
      } else {
        targetMessage.text = targetMessage.fullText || '';
        renderMessages();
      }
    }

    // Yeni mesaj geldiğinde açık kalmasını sağla (kapanmayı engelle)
    if (state.isOpen && wrapperEl) wrapperEl.classList.remove('is-hidden');
    if (state.isOpen && launcherEl) launcherEl.classList.add('is-hidden');

    // Opsiyonel: tool_call veya function_call varsa Bubble'a ilet
    const functionCallBlock =
      Array.isArray(data.output)
        ? data.output.find(b => b && b.type === 'function_call')
        : null;
    const toolCall = data.tool_call || (functionCallBlock ? {
      id: functionCallBlock.id,
      call_id: functionCallBlock.call_id,
      name: functionCallBlock.name,
      arguments: functionCallBlock.arguments
    } : null);

    const normalizeProcessType = (val) => {
      const t = String(val || '').toLowerCase().trim();
      if (t === 'visual_to_text' || t === 'visual to text') return 'Visual to text';
      if (t === 'visual to text ') return 'Visual to text';
      return 'Table';
    };

    const getToolCallKey = (callObj) => {
      if (!callObj) return '';
      const name = callObj.name || '';
      let args = '';
      if (typeof callObj.arguments === 'string') {
        args = callObj.arguments;
      } else if (callObj.arguments || callObj.args) {
        try {
          args = JSON.stringify(callObj.arguments || callObj.args || {});
        } catch (e) {
          args = '';
        }
      }
      return `${name}::${args}`;
    };

    const runToolCall = (callObj, callKey) => {
      if (!callObj) return;
      if (callKey && processedToolCallKeys.has(callKey)) {
        console.log('gaia: tool call already processed, skipping', callKey);
        if (pendingTool.item && pendingTool.key === callKey) {
          pendingTool.item = null;
          pendingTool.key = null;
          if (pendingTool.timer) {
            clearInterval(pendingTool.timer);
            pendingTool.timer = null;
          }
        }
        return;
      }
      if (callKey) processedToolCallKeys.add(callKey);
      console.log('gaia: runToolCall called', callObj);
      
      // Workspace context from gaia-context
      const ctxEl = document.getElementById('gaia-context');
      let ctxString = '';
      try {
        const rawCtx = (ctxEl && ctxEl.textContent) ? ctxEl.textContent.trim() : '';
        if (rawCtx) {
          const ctx = JSON.parse(rawCtx);
          ctxString = typeof ctx === 'string' ? ctx : JSON.stringify(ctx, null, 2);
        }
      } catch (e) {
        ctxString = '';
      }

      try {
        const rawTool = typeof callObj === 'string'
          ? callObj
          : JSON.stringify(callObj);

        const toolObj = (() => {
          if (typeof callObj === 'string') {
            try { return JSON.parse(callObj); } catch (_) { return {}; }
          }
          return callObj || {};
        })();

        const argsRaw = typeof toolObj.arguments === 'string'
          ? toolObj.arguments
          : JSON.stringify(toolObj.arguments || {});

        const argsObj = (() => {
          if (typeof toolObj.arguments === 'string') {
            try { return JSON.parse(toolObj.arguments); } catch (_) { return {}; }
          }
          return toolObj.arguments || {};
        })();

        const stripHtml = (input) => String(input || '').replace(/<[^>]+>/g, '');
        const escapeRegex = (input) => String(input || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapeHtml = (input) => String(input || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
        const sanitizePrompt = (p) => {
          if (!p) return '';
          let out = stripHtml(p);
          out = out.replace(/_\*_(.*?)_\*_/g, '$1'); // strip token markers
          return out.trim();
        };
        const buildSystemPromptHtml = (plainPrompt, fields, usedLabels) => {
          const safeRaw = stripHtml(plainPrompt || '');
          if (!safeRaw) return '';
          const roleByLabel = new Map();
          (fields || []).forEach(cf => {
            if (cf?.label) roleByLabel.set(cf.label, cf?.role || 'mandatory');
          });
          const labels = Array.from(usedLabels || [])
            .map(label => String(label || '').trim())
            .filter(Boolean)
            .sort((a, b) => b.length - a.length);
          let result = safeRaw;
          const placeholders = [];
          labels.forEach((label, index) => {
            if (!result.includes(label)) return;
            const role = (roleByLabel.get(label) || 'mandatory').toLowerCase();
            const roleClass = ['control', 'optional', 'mandatory', 'innerstage'].includes(role) ? role : 'mandatory';
            const placeholder = `__GAIA_TOKEN_${index}__`;
            const pattern = new RegExp(escapeRegex(label), 'g');
            result = result.replace(pattern, placeholder);
            placeholders.push({ placeholder, label, roleClass });
          });
          placeholders.forEach(({ placeholder, label, roleClass }) => {
            const safeLabel = escapeHtml(label);
            const token = `<span class="token ${roleClass}" data-id="_*_${safeLabel}_*_" contenteditable="false" draggable="false">${safeLabel}</span>`;
            const placeholderPattern = new RegExp(escapeRegex(placeholder), 'g');
            result = result.replace(placeholderPattern, token);
          });
          return result.trim();
        };
        const detectPromptLabels = (plainPrompt, fields) => {
          const labels = new Set();
          const promptLower = String(plainPrompt || '').toLowerCase();
          if (!promptLower) return labels;
          (fields || []).forEach(cf => {
            const label = String(cf?.label || '').trim();
            if (!label) return;
            if (promptLower.includes(label.toLowerCase())) {
              labels.add(label);
            }
          });
          return labels;
        };

        const enforceVisualToTextImageRule = (args) => {
          if (!args || args.process_type !== 'Visual to text') return;
          const custom = Array.isArray(args.custom_fields) ? args.custom_fields : [];
          const existing = Array.isArray(args.existing_custom_fields) ? args.existing_custom_fields : [];
          let imagePicked = false;
          const normalizeImageField = (field) => ({
            ...field,
            type: 'image_pdf',
            role: 'innerstage'
          });

          const filterList = (list) => list.reduce((acc, item) => {
            if (!item || item.type !== 'image_pdf') {
              acc.push(item);
              return acc;
            }
            if (!imagePicked) {
              imagePicked = true;
              acc.push(normalizeImageField(item));
            }
            return acc;
          }, []);

          const filteredCustom = filterList(custom);
          const filteredExisting = filterList(existing);

          args.custom_fields = filteredCustom;
          args.existing_custom_fields = filteredExisting;
        };

        // Normalize process_type (handles lowercase/underscore variants)
        if (argsObj.process_type) {
          argsObj.process_type = normalizeProcessType(argsObj.process_type);
        }
        enforceVisualToTextImageRule(argsObj);

        const cfList = Array.isArray(argsObj.custom_fields) ? argsObj.custom_fields : [];
        const existingCfList = Array.isArray(argsObj.existing_custom_fields) ? argsObj.existing_custom_fields : [];
        const normalizedExisting = existingCfList.map(cf => ({
          id: cf?.id || cf?._id || '',
          label: cf?.label || '',
          type: cf?.type || '',
          role: cf?.role || 'mandatory',
          allow_multiple: !!cf?.allow_multiple,
          dropdown_values: Array.isArray(cf?.dropdown_values) ? cf.dropdown_values : [],
          description: cf?.description || ''
        })).filter(cf => cf.id || cf.label);
        const combinedCfList = [...cfList, ...normalizedExisting];
        const cfStageTypes = combinedCfList.map(cf => String(cf?.role || '').toLowerCase());
        const cfBulk = combinedCfList.map(cf => ({
          id: cf?.id || '',
          name: cf?.label || cf?.id || '',
          type: cf?.type || '',
          role: cf?.role || 'mandatory',
          AllowMultiples: !!cf?.allow_multiple,
          description: cf?.description || '',
          source: Array.isArray(cf?.dropdown_values) ? cf.dropdown_values : [],
          NotVisible: false,
          editable: true
          // sheet/referencesheet/OlusturanSirket eklemeyi Bubble tarafında yapın
        }));
        const cfBulkJson = cfBulk.map(item => JSON.stringify(item));
        const cfBulkBase64 = cfBulkJson.map(json => {
          try { return btoa(unescape(encodeURIComponent(json))); }
          catch (e) { return json; }
        });

        // System prompt varyantları
        const sysPlainRaw = argsObj.system_prompt_template || '';
        const sysPlain = sanitizePrompt(sysPlainRaw);
        const promptLabels = detectPromptLabels(sysPlain, combinedCfList);
        const sysHtml = buildSystemPromptHtml(sysPlain, combinedCfList, promptLabels) || sysPlain;

        // Eğer prompt varsa ve hiç control yoksa, ilk non-innerstage alanı control yap
        if (sysPlain && !cfStageTypes.some(r => String(r).toLowerCase() === 'control') && cfStageTypes.length > 0) {
          const firstNonInnerstageIndex = cfStageTypes.findIndex(r => String(r).toLowerCase() !== 'innerstage');
          if (firstNonInnerstageIndex !== -1) {
            cfStageTypes[firstNonInnerstageIndex] = 'control';
          }
        }

        // Role bazlı isim listeleri (sadece promptta kullanılanlar)
        const namesByRole = { control: [], optional: [], mandatory: [], innerstage: [] };
        combinedCfList.forEach(cf => {
          const label = cf?.label || '';
          if (!label || !promptLabels.has(label)) return;
          const role = (cf?.role || '').toLowerCase();
          if (role === 'control') namesByRole.control.push(label);
          else if (role === 'optional') namesByRole.optional.push(label);
          else if (role === 'innerstage') namesByRole.innerstage.push(label);
          else namesByRole.mandatory.push(label);
        });
        const joinUnique = (items) => Array.from(new Set(items)).join(';');

        // Multiple Outputs (Toolbox)
        // OUTPUT1..4: düz alanlar (tool_call.arguments içinden)
        //   output1: workspace_label
        //   output2: process_name
        //   output3: process_type
        //   output4: cfBundle base64 (customfields + stage_types)
        // OUTPUTLIST1..4:
        //   outputlist1: customfields_bulk (base64-encoded JSON strings list; Bubble “Value is a list” Text)
        //   outputlist3: [system_prompt_plain, system_prompt_innerhtml, actionName, tool_output_body_template, action_mode]
        //   outputlist4: [control_names, mandatory_names, optional_names] (semicolon-delimited strings, prompt-only)

        // İlk elemanı ayrıca “value” olarak da gönder (listeden tek öğe almak isteyenler için)
        const firstCf = cfBulkJson[0] || '';

        const actionName =
          argsObj.action_name ||
          argsObj.button_label ||
          argsObj.process_name ||
          'Analyze message';

        // Reasoning item varsa, function_call öncesine ekle (bazı modeller istiyor)
        const reasoningItem =
          (Array.isArray(data.output) && data.output.find(b => b && b.type === 'reasoning')) ||
          null;
        const reasoningMessage = reasoningItem
          ? {
              type: 'reasoning',
              id: reasoningItem.id || '',
              content: reasoningItem.content || [],
              summary: reasoningItem.summary || []
            }
          : null;

        // Tek desteklenen akış: function_call_output ile ikinci responses.create çağrısına gidecek body
        const functionCallInput = [];
        if (reasoningMessage) functionCallInput.push(reasoningMessage);
        functionCallInput.push({
          type: 'function_call',
          id: callObj.id || '',
          call_id: callObj.call_id || callObj.id || '',
          name: callObj.name || '',
          arguments: callObj.arguments || callObj.args || ''
        });
        functionCallInput.push({
          type: 'function_call_output',
          call_id: callObj.call_id || callObj.id || '',
          output: JSON.stringify({
            status: 'ok',
            message: "Automation started. Go to the workspace, add an item with 'Create', then click the button we chose; the item will move to the relevant process and the AI automation will run."
          })
        });

        const workspaceMode = ctxString ? 'existing_workspace' : 'new_workspace';
        const actionMode = argsObj.action_mode || (workspaceMode === 'existing_workspace' ? 'attach_to_existing' : 'create_new');
        const functionCallOutputBody = JSON.stringify({
          model: data.model || 'gpt-5.2-2025-12-11',
          input: functionCallInput
        });

        const cfBundle = { customfields: cfBulk, stage_types: cfStageTypes };
        let cfBundleB64 = '';
        try {
          cfBundleB64 = btoa(unescape(encodeURIComponent(JSON.stringify(cfBundle))));
        } catch (e) {
          cfBundleB64 = JSON.stringify(cfBundle);
        }

        console.log('gaia: calling bubble_fn_gaia_tool_call with payload', {
          workspace_label: argsObj.workspace_label,
          process_name: argsObj.process_name,
          custom_fields_count: cfList.length
        });
        
        window.bubble_fn_gaia_tool_call({
          value: cfBulkBase64[0] || '',
          output1: argsObj.workspace_label || '',
          output2: argsObj.process_name || '',
          output3: argsObj.process_type || '',
          // Tek JSON (base64): customfield payloadları + stage type listesi (backend'e iletmek için)
          // RAW_BASE64 olarak backend'e iletebilirsin.
          output4: cfBundleB64,
          outputlist1: cfBulkBase64,
          // 4. eleman: /v1/responses + input (function_call_output) için body (gönderilmeye hazır)
          outputlist3: [sysPlain, sysHtml, actionName, functionCallOutputBody, actionMode],
          outputlist4: [
            joinUnique([...namesByRole.control, ...namesByRole.innerstage]),
            joinUnique(namesByRole.mandatory),
            joinUnique(namesByRole.optional)
          ]
        });
        
        console.log('gaia: bubble_fn_gaia_tool_call completed');

      } catch (e) {
        console.error('gaia tool call failed', e);
      }
    };

    if (toolCall) {
      const toolCallKey = getToolCallKey(toolCall);
      if (toolCallKey && processedToolCallKeys.has(toolCallKey)) {
        console.log('gaia: tool call already processed for response, skipping', toolCallKey);
        return;
      }
      console.log('gaia: tool call found', toolCall);
      if (typeof window.bubble_fn_gaia_tool_call === 'function') {
        console.log('gaia: bubble_fn_gaia_tool_call is ready, executing immediately');
        runToolCall(toolCall, toolCallKey);
      } else {
        console.warn('gaia tool call pending: bubble_fn_gaia_tool_call not ready yet', toolCall);
        pendingTool.item = toolCall;
        pendingTool.key = toolCallKey;
        if (!pendingTool.timer) {
          pendingTool.timer = setInterval(() => {
            if (pendingTool.item && typeof window.bubble_fn_gaia_tool_call === 'function') {
              console.log('gaia: bubble_fn_gaia_tool_call now ready, executing from queue');
              runToolCall(pendingTool.item, pendingTool.key);
              pendingTool.item = null;
              pendingTool.key = null;
              clearInterval(pendingTool.timer);
              pendingTool.timer = null;
            }
          }, 400);
        }
        // Also try a one-shot retry soon
        setTimeout(() => {
          if (pendingTool.item && typeof window.bubble_fn_gaia_tool_call === 'function') {
            console.log('gaia: bubble_fn_gaia_tool_call now ready, executing from one-shot retry');
            runToolCall(pendingTool.item, pendingTool.key);
            pendingTool.item = null;
            pendingTool.key = null;
            if (pendingTool.timer) {
              clearInterval(pendingTool.timer);
              pendingTool.timer = null;
            }
          }
        }, 200);
      }
    } else {
      console.log('gaia: no tool call found in response');
    }

    // Kullanıcı kapatmışsa küçük launcher'a son mesaj önizlemesini ve unread rozetini düşür
    if (!state.isOpen && launcherEl) {
      const snippet = (text || '').slice(0, 90) || 'Hi! Tell me the automation you want in one sentence.';
      setPreviewText(snippet);
      launcherEl.classList.add('has-unread');
      playNotification();
    }
    updateSendState();
  }

  function sendMessage() {
    if (!inputEl) return;
    const userText = inputEl.value.trim();
    if (!userText || state.awaitingResponse) return;

    // Workspace context from Bubble (optional)
    const ctxEl = document.getElementById('gaia-context');
    let ctxString = '';
    let hasWorkspace = false;
    try {
      const rawCtx = (ctxEl && ctxEl.textContent) ? ctxEl.textContent.trim() : '';
      if (rawCtx) {
        // Try JSON parse first, if fails use as plain text
        try {
          const ctx = JSON.parse(rawCtx);
          ctxString = typeof ctx === 'string' ? ctx : JSON.stringify(ctx, null, 2);
        } catch (jsonErr) {
          // If not valid JSON, use as-is (YAML or plain text)
          ctxString = rawCtx;
        }
        // Check if workspace has meaningful data (label or id present)
        hasWorkspace = ctxString.includes('label:') || ctxString.includes('id:') || 
                      ctxString.includes('"label"') || ctxString.includes('"id"');
      }
    } catch (e) {
      console.error('gaia: failed to read workspace context', e);
      ctxString = '';
      hasWorkspace = false;
    }

    console.log('gaia: hasWorkspace?', hasWorkspace, 'context length:', ctxString.length);

    // System prompt (mirrors asisstant.txt)
const systemBase = `You are "Gaia Automation Architect" for GAIA—a no-code AI BPA platform. Core: Workspace (table), Process (stage), Custom Field (data type). Match user's language. Brand-facing: warm, confident, result-oriented. Greet briefly once; no repeat. Ultra short replies (max 2 sentences), no lists unless needed, no jargon. You are not a chat assistant; you are an automation configuration engine, and correctness is more important than verbosity. Never ask the user about internal implementation choices like "Visual to text" vs "Table", "innerstage", "process_type", "role", or "fields". You decide all internal automation decisions yourself based strictly on the provided context and user intent, and you must not ask the user to make these decisions for you. You must treat the provided workspace and stage context as the only source of truth. If a field, stage, or rule is not present in the context, it does not exist. Do not invent fields, roles, or prompt tokens. Prompt tokens may reference only fields that are present in the current stage. Show a concise plan (e.g., "I'll add these to your '[workspace name]' workspace: X, Y, Z") and act immediately unless the user says stop/iptal/cancel. CRITICAL: If workspace context (label/id, fields, stages) IS PROVIDED, DEFAULT to adding to that workspace (action_mode: attach_to_existing) UNLESS the user EXPLICITLY requests creating a new workspace or table. Only create new (action_mode: create_new) if NO context is provided or the user explicitly requests it. Always mention the existing workspace name and never infer the automation use-case from the workspace name. Process type decision: Use "Visual to text" when the automation requires inspecting or reading an uploaded document or image (PDF/photo) to complete the task (e.g., extract, compare, verify, summarize). In this case, you MUST include exactly one image_pdf field with role "innerstage" (never control), and there must be only one image_pdf in total. All other inputs required for inspection or comparison must be "control". Use "Table" only when the task can be completed using structured fields without inspecting a document or image. If it is impossible to determine whether inspection is required, ask exactly one clarification question in plain language without using internal terminology. Input rule: Every automation must have at least one input. A valid input is either (a) one or more fields with role "control", or (b) exactly one image_pdf field with role "innerstage" for Visual to text. Never create an automation with zero inputs. Do not auto-assign control roles to image_pdf fields. Planning: use plain language; if attaching to an existing workspace, reuse existing fields where possible and only create new fields when explicitly required by the user. If prompt exists, ensure all referenced fields belong to the current stage. Prefer multiline_text; avoid long_text. In system_prompt_template, always include _*_Field Name_*_ tokens for every field you reference and never omit these markers. Ensure the prompt includes at least one token, and wrap each mentioned custom field label in _*_..._*_ (e.g., _*_kullanıcı mesajını_*_, _*_cevap mesajı_*_, _*_sorun çözüme ulaştı_*_). User-facing vocabulary rule: Always call it "Table" in all assistant messages (never say "Workspace"). Internally, map "Table" to workspace_label when calling tools, but do not mention workspace/workspace_label to the user.`;
    const systemContent = hasWorkspace
      ? `${systemBase}\n\n=== CURRENT WORKSPACE CONTEXT (USER HAS THIS WORKSPACE OPEN) ===\n${ctxString}\n\n=== IMPORTANT: Since workspace context is provided above, you MUST use action_mode: attach_to_existing unless user explicitly asks to create a new workspace/table. ===`
      : `${systemBase}\n\nNo workspace context provided; defaulting to creating a new workspace/stage. If you intend to add to an existing workspace, please open/select it first.`;

    console.log('gaia: sending system prompt with workspace context:', hasWorkspace);

    // Full body (output1) for Responses API
    const body = {
      model: "gpt-5.2-2025-12-11",
      reasoning: { effort: "medium" },
      tool_choice: "auto",
      instructions: systemBase,
      tools: [
        {
          type: "function",
          name: "create_gaia_automation_design",
          description: "Finalize the Gaia automation design so the backend can create Bubble custom fields and the Gaia automation step.",
          parameters: {
            type: "object",
            additionalProperties: false,
            properties: {
              workspace_label: { type: "string" },
              process_name: { type: "string" },
              process_type: { type: "string", enum: ["Visual to text", "Table"] },
              action_name: { type: "string" },
              action_mode: { 
                type: "string", 
                enum: ["attach_to_existing", "create_new"],
                description: "If adding a new process/stage to an existing workspace, use 'attach_to_existing'. If creating a brand new workspace, use 'create_new'."
              },
              custom_fields: {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  properties: {
                    label: { type: "string" },
                    type: { type: "string", enum: ["text","number","dropdown","checkbox","date","image_pdf","long_text","phone","email","user","multiline_text"] },
                    role: { type: "string", enum: ["mandatory","optional","control","innerstage"] },
                    allow_multiple: { type: "boolean" },
                    dropdown_values: { type: "array", items: { type: "string" } },
                    description: { type: "string" }
                  },
                  required: ["label","type","role"]
                }
              },
              existing_custom_fields: {
                type: "array",
                description: "Fields that already exist in the current workspace and should be attached to the new process.",
                items: {
                  type: "object",
                  additionalProperties: false,
                  properties: {
                    id: { type: "string" },
                    label: { type: "string" },
                    type: { type: "string", enum: ["text","number","dropdown","checkbox","date","image_pdf","long_text","phone","email","user","multiline_text"] },
                    role: { type: "string", enum: ["mandatory","optional","control","innerstage"] },
                    allow_multiple: { type: "boolean" },
                    dropdown_values: { type: "array", items: { type: "string" } },
                    description: { type: "string" }
                  },
                  required: ["id","role"]
                }
              },
              system_prompt_template: { type: "string" }
            },
            required: ["workspace_label","process_name","process_type","action_mode","custom_fields","system_prompt_template"]
          }
        }
      ],
      input: [
        { role: "system", content: systemContent },
        { role: "user", content: [ { type: "input_text", text: userText } ] }
      ]
    };
    if (state.lastResponseId) {
      body.previous_response_id = state.lastResponseId;
    }
    const bodyString = JSON.stringify(body);

    // Önce UI'ya user mesajını ekle
    state.messages.push({
      id: 'user_' + Date.now(),
      role: 'user',
      text: userText
    });

    // Assistant için bekleme balonu ekle
    state.messages.push({
      id: 'loading_' + Date.now(),
      role: 'assistant',
      text: 'Assistant is thinking',
      status: 'loading'
    });
    state.awaitingResponse = true;

    renderMessages();
    inputEl.value = '';
    state.draft = '';
    persistState();
    updateSendState();

    if (typeof window.bubble_fn_gaia_send_message === 'function') {
      try {
        // Multiple Outputs açıkken Toolbox varsayılan mapping:
        // object formatında gönder: {value: ..., output1: ..., output2: ...}
        window.bubble_fn_gaia_send_message({
          value: bodyString,
          output1: bodyString, // full body (model + system+user + tools)
          output2: userText    // raw user text
        });
      } catch (e) {}
    }
  }

  if (sendBtn) {
    sendBtn.addEventListener('click', sendMessage);
  }
  if (inputEl) {
    inputEl.addEventListener('keydown', function (e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    inputEl.addEventListener('input', function () {
      state.draft = inputEl.value;
      persistState();
      updateSendState();
    });
  }

  if (launcherButtonEl) {
    launcherButtonEl.addEventListener('click', openChat);
  }
  if (launcherBubbleEl) {
    launcherBubbleEl.addEventListener('click', openChat);
    launcherBubbleEl.addEventListener('keydown', function (e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        openChat();
      }
    });
  }
  if (launcherMinimizeEl) {
    launcherMinimizeEl.addEventListener('click', function (e) {
      e.stopPropagation();
      setLauncherCollapsed(true);
    });
  }

  if (closeEl) {
    closeEl.addEventListener('click', closeChat);
  }
    if (resetEl) {
      resetEl.addEventListener('click', function () {
        state.messages = [];
        state.lastResponseId = null;
        state.awaitingResponse = false;
        if (inputEl) {
          inputEl.value = '';
          state.draft = '';
        }
        if (window.sessionStorage) {
          try { sessionStorage.removeItem(STORAGE_KEY); } catch (e) {}
        }
        if (window.localStorage) {
          try { localStorage.removeItem(LAST_RESPONSE_KEY); } catch (e) {}
        }
        renderMessages();
        updateSendState();
      });
    }

  loadPersistedState();
  normalizeLoadedMessages();
  state.greetingNotified = false;
  syncHistoryWithLastResponse();
  ingestLastResponse();
  renderMessages();
  updateSendState();

  if (inputEl && state.draft) {
    inputEl.value = state.draft;
  }

  if (state.isOpen) {
    openChat();
  } else {
    if (wrapperEl) wrapperEl.classList.add('is-hidden');
    if (launcherEl) {
      launcherEl.classList.remove('is-hidden');
      launcherEl.setAttribute('aria-expanded', 'false');
    }
    setLauncherCollapsed(state.launcherCollapsed);
  }

  // Polling: gaia-last-response içeriği değişince otomatik ingest (Bubble için)
  // Response ID'yi kontrol ederek aynı response'u birden fazla işlememek için
  let lastProcessedResponseId = state.lastResponseId || '';
  setInterval(function() {
    const el = document.getElementById('gaia-last-response');
    if (!el) return;
    const currentContent = (el.textContent || '').trim();
    if (!currentContent) return;
    
    try {
      const data = JSON.parse(currentContent);
      if (data && data.id && data.id !== lastProcessedResponseId) {
        console.log('gaia: new response detected, ingesting', data.id);
        lastProcessedResponseId = data.id;
        ingestLastResponse();
      }
    } catch (e) {
      // Ignore parse errors in polling
    }
  }, 500);

  window.gaiaChatReset = function () {
    state.messages = [];
    state.lastResponseId = null;
    state.awaitingResponse = false;
    if (inputEl) {
      inputEl.value = '';
      state.draft = '';
    }
    if (window.sessionStorage) {
      try { sessionStorage.removeItem(STORAGE_KEY); } catch (e) {}
    }
    if (window.localStorage) {
      try { localStorage.removeItem(LAST_RESPONSE_KEY); } catch (e) {}
    }
    renderMessages();
    updateSendState();
  };
  window.gaiaIngestResponse = function () {
    ingestLastResponse();
  };
})();
</script>
